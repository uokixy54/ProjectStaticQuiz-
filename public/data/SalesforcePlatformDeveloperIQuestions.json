[
    {
        "number": "1",
        "question": "デバッグログに書き込まれるときのxの値は何ですか。",
        "following-code": [
            "Integer x = 0;",
            "do {",
                "x = 1;",
                "x++;",
            "} while (x < 1);",
            "System.debug(x);"
        ],
        "choices": ["0", "1", "2", "3"],
        "correct": ["2"],
        "explanations":["0", "1", "2", "3","解説"],
        "descriptions":[
            "",
            "",
            "",
            "",
            "x の初期値は0です。\ndo ループが実行されます。\nx に1が代入されます。\nx の値がインクリメントされ、現在の値は2になります。\nwhile 条件式 x < 1 が評価されます。しかし、この時点で x の値は2なので条件式は false となります。\nループを抜けて System.debug(x); が実行され、 デバッグログには 2 が表示されます。"
        ]
    },
    {
        "number": "2",
        "question": "LightningコンポーネントからApexメソッドおよびプロパティへのアクセスを可能にするアノテーションはどれですか。",
        "choices": ["@RestResource", "@AuraEnabled", "@RemoteAction", "@Httplnvocable"],
        "correct": ["@AuraEnabled"],
        "explanations":["@RestResource", "@AuraEnabled", "@RemoteAction", "@Httplnvocable"],
        "descriptions":[
            "これは不正解です。@RestResource アノテーションは、ApexクラスをRESTful Webサービスとして公開するために使用されます。Lightningコンポーネントから直接このアノテーションを用いてApexメソッドにアクセスすることは推奨されません。",
            "これは正解です。LightningコンポーネントからApexメソッドおよびプロパティへのアクセスを可能にするアノテーションは「@AuraEnabled」です。このアノテーションをApexメソッドまたはプロパティに追加すると、そのメソッドやプロパティがLightningコンポーネントから呼び出し可能になります。",
            "これは不正解です。@RemoteAction アノテーションは、VisualforceページからApexメソッドにアクセスするために使用されます。しかし、Lightningコンポーネントからは使用できません。",
            "これは不正解です。@Httplnvocable アノテーションは、存在しないアノテーションです。"
        ]
    },
    {
        "number": "3",
        "question": "非同期Apexを実行して、ガバナ制限と実行制限が緩和されるものはどれですか。3つ選びなさい。",
        "choices": ["ヒープの合計サイズ", "Salesforce サーバの最大CPU時間", "Apexトランザクションごとの最大実行時間", "SOQLクエリによって取得されるレコードの合計数","SOQLクエリ発行総数"],
        "correct": ["ヒープの合計サイズ","Salesforceサーバの最大CPU時間","SOQLクエリ発行総数"],
        "explanations":["ヒープの合計サイズ", " Salesforceサーバの最大CPU時間", "Apexトランザクションごとの最大実行時間", " SOQLクエリによって取得されるレコードの合計数","SOQLクエリ発行総数"],
        "descriptions":[
            "これは正解です。非同期Apexでのヒープの合計サイズは、同期Apexと比較して増加します。同期Apexでは最大ヒープサイズは6MBですが、非同期Apexではこの制限が12MBに増えます。",
            "これは正解です。非同期ApexではCPU時間のガバナ制限が緩和されます。非同期Apexの最大CPU時間は60,000ミリ秒ですが、同期Apexではこの制限は10,000ミリ秒です。",
            "これは不正解です。Apexトランザクションごとの最大実行時間は同期も非同期も共に10分です。",
            "これは不正解です。非同期ApexでもSOQLによって取得される最大レコード数の制限は50,000レコードとなります。",
            "これは正解です。同期Apexでは1トランザクションあたりのSOQLクエリ発行回数が100回ですが、非同期Apexではこの制限はが200回まで増加します。"
        ]
    },
    {
        "number": "4",
        "question": "現在取引先が100個ある場合に、開発者コンソールを使用して次のコードを実行します。\nこのコードの実行後、組織にはいくつの取引先がありますか。",
        "following-code": [
            "Account myAccount = new Account(Name = 'MyAccount');",
            "insert myAccount;",
                "For(Integer x = 0; x < 250; x++) {;",
                "Account newAccount = new Account(Name = 'MyAccount' + x);",
            " try {",
            " Insert newAccount;",
            " } catch (Exception ex) {",
            " System.debug(ex);",
            "}",
            "insert new Account(Name = 'myAccount');",
            "}"
        ],
        "choices": ["101", "100", "102", "252"],
        "correct": ["100"],
        "explanations":["101", "100", "102", "252"],
        "descriptions":[
            "",
            "正解は100です。",
            "",
            ""
        ]
    },
    {
        "number": "5",
        "question": "トリガーの実行順序で、beforeトリガーが実行された後、およびafterトリガーが実行される前に、どのステップが発生しますか。正確な順序を答えなさい。1.システム検証ステップが再度実行され、ユーザー定義の入力規則がチェックされます。\n2.beforeトリガー\n3.afterトリガー\n4.レコードはデータベースに保存されますが、まだコミットされていません。\n5.重複ルールを実行します。",
        "choices": ["1→2→5→3→4", "2→3→4→1→5", "2→1→5→4→3", "2→1→5→3→4"],
        "correct": ["2→1→5→4→3"],
        "explanations":["", "", "", "","説明"],
        "descriptions":[
            "",
            "",
            "",
            "",
            "まず、beforeトリガー(ステップ2)が実行されます。これは新規レコードが保存される前、または既存レコードが更新される前に実施されます。",
            "次に、システム検証ステップが再度実行され、ユーザー定義の入力規則がチェックされます(ステップ1)。これは主に項目レベルセキュリティ検証として機能します。",
            "重複ルールが実行されます(ステップ5)。これにより、新規作成または更新の試みが重複レコードを作成することを防ぎます。",
            "レコードはデータベースに保存されますが、まだコミットされていません(ステップ4)。これはafterトリガーが実行される前のステップであり、これによりレコードは一時的に保存されますが、まだ最終的にはコミットされていません。",
            "最後に、afterトリガー(ステップ3)が実行されます。これはレコードが一時的に保存された後、最終的にデータベースにコミットされる前に行われます。"
        ]
    },
    {
        "number": "6",
        "question": "レコードセット内のレコード数が不明な場合、開発者は.size()または.length()メソッド呼び出しを実行せずに、レコードセット内のすべてのレコードに対して実行するコードセットを実装するためにどの制御ステートメントを使用する必要がありますか。",
        "choices": ["For(init_stmt, exit_condition; increment_stmt) { }", "Do { } While(Condition)", "For(variable : list_or_set) { }", "While(Condition) { … }"],
        "correct": ["For(variable : list_or_set) { }"],
        "explanations":[" For (init_stmt, exit_condition; increment_stmt) { }", "Do { } While (Condition)", "For(variable : list_or_set) { }", "While (Condition) { … }"],
        "descriptions":[
            "これは不正解です。これは一般的なforループの構造であり、ループが実行される回数(つまり、exit_conditionがfalseになるまで)を事前に知る必要があります。レコードセットのサイズが不明な場合、この方法では適切なexit_conditionを設定できないため、この選択肢は適切ではありません。",
            "これは不正解です。do-whileループは、まずブロック内のコードを実行し、その後で条件を評価します。条件が真であれば、再度コードブロックが実行されます。しかし、このループではレコードセットのサイズが不明な場合、適切な「Condition」を設定するのが難しいため、この選択肢は適切ではありません。",
            "これは正解です。このループは、「リスト反復またはセット反復の for ループ」と呼ばれ、リストやセットのすべての要素に対して繰り返し処理を実行します。このループを使用すると、コレクションの要素数を事前に知らなくても、すべての要素に対して操作を実行できます。",
            "これは不正解です。whileループは、指定した条件が真である限り、ループ内のコードを繰り返し実行します。しかし、レコードセットのサイズが不明な場合、適切な「Condition」を設定するのが難しいため、この選択肢も適切ではありません。"
        ]
    },
    {
        "number": "7",
        "question": "共有に関する正確な説明はどれですか。2つ選びなさい。",
        "choices": ["内部クラスまたは外部クラスのいずれかを共有と同様に宣言できますが、両方は宣言できません。", "内部クラスは外部クラスから共有設定を継承しません。", "内部クラスと外部クラスの両方を共有と同様に宣言できます。", "内部クラスは外部クラスから共有設定を継承します。"],
        "correct": ["内部クラスは外部クラスから共有設定を継承しません。","内部クラスと外部クラスの両方を共有と同様に宣言できます。"],
        "explanations":["内部クラスまたは外部クラスのいずれかを共有と同様に宣言できますが、両方は宣言できません。", "内部クラスは外部クラスから共有設定を継承しません。", "内部クラスと外部クラスの両方を共有と同様に宣言できます。", "内部クラスは外部クラスから共有設定を継承します。"],
        "descriptions":[
            "これは不正解です。内部クラスと外部クラスの両方を”with sharing”と宣言することができます。",
            "これは正解です。内部クラスは外部クラスの共有設定を継承しません。それは独自の共有設定を持ちます。",
            "これは正解です。Apexでは、内部クラスと外部クラスの両方を”with sharing”と宣言することができます。",
            "これは不正解です。前述のとおり、内部クラスは外部クラスから共有設定を継承しません。"
        ]
    },
    {
        "number": "8",
        "question": "開発者には、コードブロックを共有ありまたはなしで実行するかどうかを示すwith sharingおよびwithout sharingを省略したコードブロックがあります。Salesforce組織でコードを実行するユーザーの組織全体のデフォルトおよび共有設定に自動的に従うものは次のうちどれですか。",
        "choices": ["Apexトリガー", "HTTPコールアウト", "カスタムコントローラ", "匿名ブロック"],
        "correct": ["匿名ブロック"],
        "explanations":["Apexトリガー", " HTTPコールアウト", "カスタムコントローラ", " 匿名ブロック"],
        "descriptions":[
            "これは不正解です。Apex トリガーは、明示的な共有宣言を持つことができません。そのため、トリガーは常にwithout sharingの設定で実行されます。",
            "これは不正解です。HTTPコールアウトはSalesforceのデータアクセスや共有設定とは無関係に外部サービスにリクエストを送る動作をします。共有設定は影響を及ぼしません。",
            "これは不正解です。カスタムコントローラにwith sharingやwithout sharingを明示的に指定しない場合、実行するコードの動作はコードを書いたクラスやトリガーのデフォルトの動作に従います。ただし、それはユーザーの共有設定や権限に自動的に従うわけではありません。",
            "これは正解です。匿名ブロックは現在のユーザーとして実行されるため、ユーザーの組織全体のデフォルトおよび共有設定に従います。"
        ]
    },
    {
        "number": "9",
        "question": "SalesforceDXを使用する場合、スクラッチ組織を作成・管理するために開発者は何を有効にする必要がありますか。",
        "choices": ["Production", "Dev Hub", "環境ハブ", "Sandbox"],
        "correct": ["Dev Hub"],
        "explanations":["Production", "Dev Hub", "環境ハブ", "Sandbox"],
        "descriptions":[
            "これは不正解です。本番環境(Production)は、実際のユーザーにサービスを提供するための環境ですが、スクラッチ組織の作成や管理に直接関与するものではありません。Dev Hubは本番環境またはサンドボックス環境に有効にできますが、本番環境自体がスクラッチ組織の作成に必要なわけではありません。",
            "これは正解です。Salesforce DXでスクラッチ組織を作成・管理するためには、Dev Hubを有効にする必要があります。Dev Hubは、スクラッチ組織の作成、追跡、および管理を行うための中心的な場所です。Salesforceの開発者アカウントでDev Hubを有効にすることにより、開発者はスクラッチ組織を作成し、ソースコードを管理し、連続的インテグレーションおよびデリバリーを実施できます。",
            "これは不正解です。環境ハブは、複数のSalesforce組織を管理するためのツールですが、スクラッチ組織の作成や管理には直接関係ありません。Dev Hubは、特にSalesforce DXと連携してスクラッチ組織を管理するための機能を提供します。",
            "これは不正解です。サンドボックス(Sandbox)は、実際の本番環境とは別にテストや開発を行うための環境です。スクラッチ組織は一時的な、完全に分離された開発環境を提供しますが、サンドボックスは本番環境のコピーであり、スクラッチ組織の作成には関係ありません。スクラッチ組織の管理にはDev Hubが必要です。"
        ]
    },
    {
        "number": "10",
        "question": "開発者は、取引先を操作するApexメソッドに十分な テストカバレッジがあることを確認する必要があります。 開発者は テストデータを作成する必要があります。このテストデータをSalesforceに読み込むための好ましい方法は何ですか。2つ選びなさい。",
        "choices": ["CSVファイルを使用する", "HttpCalloutMocksを使用する", "WebServiceTestsを使用する", "静的リソースを使用する"],
        "correct": ["CSVファイルを使用する","静的リソースを使用する"],
        "explanations":["CSVファイルを使用する", "HttpCalloutMocksを使用する", "WebServiceTestsを使用する", "静的リソースを使用する"],
        "descriptions":[
            "これは正解です。 テストデータをSalesforceに読み込む際に、CSVファイルを使ってデータを整理・作成し、それを静的リソースとしてアップロードすることが一般的な手法です。Test.loadData メソッドを使用して、静的リソースから テストメソッドにデータを簡単に読み込むことができます。",
            "これは不正解です。HttpCalloutMocks は、外部サービスへのHTTPコールアウトを模倣(モック)するためのものであり、 テストデータの作成や読み込みには使用されません。",
            "これは不正解です。WebServiceTests は、Salesforce内のWebサービスメソッドを テストするためのものです。これも テストデータの作成や読み込みには関連しません。",
            "これは正解です。静的リソースを使用することで、CSVファイルなどのデータをSalesforceに保存することができます。そして、Test.loadData メソッドを使って、その静的リソースから テストデータを読み込むことができます。"
        ]
    },
    {
        "number": "11",
        "question": "開発者はオブジェクトProperty__cのレコードを作成する必要があります。\n開発者は次のコードブロックを使用します。レコードにエラーが発生して作成に失敗した場合でも、開発者は「/*Question*/」どのようなコードを挿入すれば、少なくともいくつかのレコードを作成することができるでしょうか。",
        "following-code":[
            "List<Property__c> propertiesToCreate = helperClass.CreateProperties();",
            "try {",
                "/*Question*/",
            "} catch (Exception exp) {",
                "//Exception handling",
            "}"
        ],  
        "choices": ["Database.insert(propertiesToCreate, System.ALLOW_PARTIAL);", "insert propertiesToCreate;", "Database.insert(propertiesToCreate, false);", "Database.insert(propertiesToCreate);"],
        "correct": ["Database.insert(propertiesToCreate, false);"],
        "explanations":["Database.insert(propertiesToCreate, System.ALLOW_PARTIAL);", " insert propertiesToCreate;", " Database.insert(propertiesToCreate, false);", " Database.insert(propertiesToCreate);"],
        "descriptions":[
            "これは不正解です。SalesforceのApexには「System.ALLOW_PARTIAL」というオプションは存在しません。したがって、このコードはコンパイルエラーとなります",
            "これは不正解です。、標準のinsertステートメントはすべてのレコードの成功を要求するため、1つのレコードでエラーが生じると、全レコードの操作がロールバックされます。",
            "これは正解です。Database.insert()の第二引数にfalseを指定することで、エラーのあるレコードのみがスキップされ、エラーのないレコードは正常に挿入されます。これにより、部分的な成功を可能にします。",
            "これは不正解です。Database.insert()メソッドに第二引数(allOrNoneパラメーター)を指定しない場合、デフォルト値はtrueとなります。これは、全体としての成功を要求します。つまり、処理対象の任意のレコードでエラーが発生した場合、全てのレコードの操作がロールバックされます。"
        ]
    },
    {
        "number": "12",
        "question": "サンドボックスで作業する開発者は、新しいテストクラスを実行するために何を使用する必要がありますか。2つ選びなさい。",
        "choices": ["REST APIおよびApexTestRunメソッド", "Salesforceセットアップの[テストの実行]ページ", "Salesforceセットアップの[Apexテスト実行]ページ", "開発者コンソールのテストメニュー"],
        "correct": ["Salesforceセットアップの[Apexテスト実行]ページ","開発者コンソールのテストメニュー"],
        "explanations":["REST APIおよびApexTestRunメソッド", "Salesforceセットアップの[テストの実行]ページ", "Salesforceセットアップの[Apex テスト実行]ページ", "開発者コンソールのテストメニュー"],
        "descriptions":[
            "これは不正解です。ApexTestRunメソッドは存在しないため、開発者はこれを使用して新しいテストクラスを実行することはできません。また、一般的には、REST APIは直接的にテストクラスを実行するための手段としては使用されません",
            "これは不正解です。Salesforceには「テストの実行」ページは存在しないため、これを使用してテストクラスを実行することはできません。正確なページ名は「Apex テスト実行」ページです。",
            "これは正解です。Salesforceのセットアップ内にある「Apex テスト実行」ページを通じて、開発者は新しいテストクラスを実行することができます。",
            "これは正解です。Salesforceの開発者コンソールは統合開発環境(IDE)であり、テストメニューから新しいテストクラスを実行することができます。"
        ]
    },
    {
        "number": "13",
        "question": "Universal Containers社は、注文管理アプリケーションを実装しました。各注文は1つ以上の注文明細項目を持つことができます。注文明細オブジェクトは、主従関係を通じて注文オブジェクトに関連しています。各注文明細について、合計価格は注文明細の価格に注文数量を掛け合わせることで計算されます。注文レコード上のすべての注文明細項目の合計を取得するためのベストプラクティスは何ですか。",
        "choices": ["クイックアクション", "Apex トリガー", "積み上げ集計項目", "数式項目"],
        "correct": ["積み上げ集計項目"],
        "explanations":["クイックアクション", "Apex トリガー", "積み上げ集計項目", "数式項目"],
        "descriptions":[
            "これは不正解です。クイックアクションは、ユーザーが特定のタスクを迅速に実行できるようにする機能です。たとえば、レコードを作成したり、データを更新したりするために使用されます。しかし、注文レコード上のすべての注文明細項目の合計を動的に計算するためには適していません。",
            "これは不正解です。Apex トリガーは、データベース操作(例えば、レコードが挿入、更新、削除される時)に応じてカスタムコードを実行するために使用されます。トリガーを使用して注文明細項目の合計を計算し、関連する注文レコードにその値を保存することは可能ですが、よりシンプルかつ宣言的なソリューションが存在する場合、これは最適な選択ではありません。",
            "これは正解です。積み上げ集計項目は、関連するレコードからのデータを集計するために設計されており、このケースに最適なソリューションです。積み上げ集計項目を使用することで、注文オブジェクトに関連するすべての注文明細オブジェクトの価格と数量の合計を自動的に計算し、その合計値を注文レコード上で直接表示することができます。これはコーディングを必要とせず、設定だけで実現できるため、ベストプラクティスと考えられます。",
            "これは不正解です。数式項目は、他の項目の値に基づいて動的に値を計算するために使用されます。ただし、数式項目は同一レコード内の項目または関連レコードの項目を基に計算を行うことはできますが、関連レコード群の集計(例えば、複数の注文明細項目の合計)を直接計算する機能は持っていません。従って、このシナリオで求められる合計値の計算には適していません。"
        ]
    },
    {
        "number": "14",
        "question": "開発者は次の匿名コードブロックを実行します。",
        "following-code":["List <Account> acc =[SELECT Id FROM Account LIMIT 10]; \nDelete acc;\nDatabase.emptyRecycleBin(acc);\nsystem.debug(Limits.getDMLStatements() + '、' + Limits.getLimitDMLStatements());"],
        "choices": ["2、150", "11、150", "150、2", "150、11"],
        "correct": ["2、150"],
        "explanations":["", "", "", "","解説"],
        "descriptions":[
            "",
            "",
            "",
            "",
            "Limits.getDMLStatements(): このメソッドは、現在のトランザクションで実行されたDML操作の数を返します。Delete acc; この操作はDMLとして1回カウントされます。Database.emptyRecycleBin(acc); この操作もDMLとして1回カウントされます。 従って、Limits.getDMLStatements() の返り値は2となります。Limits.getLimitDMLStatements(): このメソッドは、単一のトランザクション内で許されるDML操作の最大回数を示します。Salesforceにおける1トランザクション内のDML操作の上限は150回です。従って、Limits.getLimitDMLStatements() の返り値は150となります。※トランザクション: トランザクショととは、一連のデータ操作の単位であり、これらの操作はすべて成功するか、1つでも失敗した場合には全てが取り消される特性を持っています。 データベースにおいて、これは密接に関連するデータの一まとめに行われる処理や、そのデータ自体を指します。結論として、上記の匿名コードブロックのデバッグ出力は「2、150」となることが期待されます。"
        ]
    },
    {
        "number": "15",
        "question": "カスタム例外「RecordNotFoundException」は、次のブロックコードによって定義されます。",
        "following-code":[
            "public class RecordNotFoundException extends Exception() {",

            "}" 
        ],
        "choices": ["throw new RecordNotFoundException(“problem occured”);", "throw new RecordNotFoundException();", "throw RecordNotFoundException(“problem occured”);", "throw RecordNotFoundException();"],
        "correct": ["throw new RecordNotFoundException(“problem occured”);","throw new RecordNotFoundException();"],
        "explanations":["throw new RecordNotFoundException(“problem occured”);", "throw new RecordNotFoundException();", "throw RecordNotFoundException(“problem occured”);", "throw RecordNotFoundException();"],
        "descriptions":[
            "これは正解です。この文は新たにRecordNotFoundExceptionの例外を生成して、”problem occured”というメッセージとともにスローします。Apexでは、カスタム例外を生成するために”new”キーワードを使用し、その後に例外クラス名とメッセージを指定します。",
            "これは正解です。こちらも新たにRecordNotFoundExceptionの例外を生成してスローしますが、エラーメッセージは指定していません。エラーメッセージが不要な場合にこの形式を使用します。",
            "これは不正解です。Apexでは例外をスローするときに”new”キーワードを使用して新たに例外のインスタンスを生成する必要があります。この文では”new”キーワードが抜けているため正しくない文となります。",
            "これは不正解です。こちらも”new”キーワードが抜けているため、正しくない文となります。"
        ]
    },
    {
        "number": "16",
        "question": "Apexテストクラスを作成するときに使用できるメソッドは何ですか。2つ選びなさい。",
        "choices": ["開発者コンソールで無視するエラータイプを選択するメソッド", "@futureメソッドの後にテストするアサーションを作成するメソッド", "ApexテストでCreatedDateフィールドを設定および変更するメソッド", "ブレークポイントを設定して、特定のポイントで実行をフリーズするメソッド","システムに保存されているcsvファイルを使用してテストデータを選択するメソッド"],
        "correct": ["ApexテストでCreatedDateフィールドを設定および変更するメソッド","システムに保存されているcsvファイルを使用してテストデータを選択するメソッド"],
        "explanations":["開発者コンソールで無視するエラータイプを選択するメソッド", "@futureメソッドの後にテストするアサーションを作成するメソッド", "ApexテストでCreatedDateフィールドを設定および変更するメソッド", "ブレークポイントを設定して、特定のポイントで実行をフリーズするメソッド","システムに保存されているcsvファイルを使用してテストデータを選択するメソッド"],
        "descriptions":[
            "これは不正解です。開発者が特定のエラータイプをプログラムコード(Apexテストクラス)で「無視する」ような設定を行うメソッドは、Apexには存在しません。エラーハンドリングはtry/catchブロックを用いて行われますが、これはエラーを捕捉し処理するための構文であり、「無視する」設定ではありません。エラーは適切に捕捉し、適切な処理を行うことが期待されます。",
            "これは不正解です。そのようなテストメソッドは存在しません。テストメソッドにこのような@futureアノテーションがついたメソッドは非同期に実行されるため、@futureメソッドの直後にアサーションを書いても、そのメソッドの結果がまだ得られていないために、テストは失敗します。テストコード内で@futureメソッドをテストする場合、Test.startTest()とTest.stopTest()を使用します。Test.stopTest()は、@futureメソッドを含むすべての非同期処理が完了するまで待つことができます。",
            "これは正解です。ApexテストメソッドTest.setCreatedDate(recordId, createdDatetime)を使用して、テスト実行中にsObjectレコードのCreatedDateフィールドを設定することができます。",
            "これは不正解です。ブレークポイントはデバッグのためのツールであり、コードの特定のポイントで実行を一時停止することができますが、Apexテストクラス内でブレークポイントを設定するメソッドは存在しません。",
            "これは正解です。ApexのTest.loadDataメソッドを使うと、静的リソースとして保存されているCSVファイルからデータをロードし、テストデータとして使用することができます。"
        ]
    },
    {
        "number": "17",
        "question": "次のクエリを実行します。\n姓が「Smith」のレコードがない場合、クエリは何を返しますか。",
        "following-code": [
            "Contact con = [SELECT ID,FirstName,LastName,Email FROM Contact WHERE LastName = 'Smith'];"
        ],
        "choices": ["空の値を持つ取引先責任者", "nullに初期化された取引先責任者", "取引先責任者の空のリスト", "行が見つからないというエラー"],
        "correct": ["行が見つからないというエラー"],
        "explanations":["空の値を持つ取引先責任者", "nullに初期化された取引先責任者", "取引先責任者の空のリスト", "行が見つからないというエラー"],
        "descriptions":[
            "これは不正解です。SOQLクエリが一致するレコードを見つけられない場合でも、新たに空の値を持つ取引先責任者を作成することはありません。",
            "これは不正解です。SOQLクエリが一致するレコードを見つけられない場合でも、新たにnullに初期化された取引先責任者を作成することはありません。",
            "これは不正解です。もしクエリ結果をリスト型に代入しようとしていたなら、これは正しい答えになるかもしれません。なぜなら、SOQLクエリは常にリストを返し、もし結果が存在しない場合は空のリストになるからです。しかし、この問題ではクエリ結果を単一のSObject型変数(con)に代入しようとしており、その結果が0件(または2件以上)の場合、エラーが発生します。",
            "これは正解です。この問題では、クエリの結果を単一のSObject型変数に代入しようとしています。SOQLクエリが0件または複数件の結果を返した場合、この代入操作は失敗し、「System.QueryException: List has more than 1 row for assignment to SObject」のようなエラーが発生します。"
        ]
    },
    {
        "number": "18",
        "question": "Lightningコンポーネントフレームワークでは、クライアント側のコントローラーロジックはどこに含まれていますか。",
        "choices": ["Apex", "Visualforce", "HTML", "JavaScript"],
        "correct": ["JavaScript"],
        "explanations":["Apex", "Visualforce", "HTML", "JavaScript"],
        "descriptions":[
            "これは不正解です。ApexはSalesforceのサーバーサイド言語で、主にデータベース操作やビジネスロジックを担当します。クライアント側のロジックには使われません。",
            "これは不正解です。VisualforceはUIのカスタマイズに使用されるSalesforceのサーバーサイド技術ですが、クライアント側のロジックを実装するためのものではありません。",
            "これは不正解です。HTMLはウェブページの構造やコンテンツを定義するマークアップ言語です。プログラムロジックの実装には使われません。",
            "これは正解です。JavaScriptはクライアント側のスクリプト言語で、Lightningコンポーネントフレームワークにおいて、クライアント側のコントローラロジックを実装するために使用されます。"
        ]
    },
    {
        "number": "19",
        "question": "Full Sandboxには当てはまらないが、Partial Copy Sandboxに当てはまるものはどれですか。2つ選びなさい。",
        "choices": ["より頻繁に更新される", "コピーされる内容はメタデータのみ", "変更セットが使用できる", "データストレージに上限が存在する"],
        "correct": ["より頻繁に更新される","データストレージに上限が存在する"],
        "explanations":["より頻繁に更新される", "コピーされる内容はメタデータのみ", "変更セットが使用できる", "データストレージに上限が存在する"],
        "descriptions":[
            "これは正解です。Partial Copy SandboxはFull Sandboxよりも頻繁に更新することができます。具体的には、Full Sandboxの更新間隔は29日ですが、Partial Copy Sandboxは5日ごとに更新することができます。",
            "これは不正解です。Partial Copy Sandboxは選択的なデータと全てのメタデータを含むことができます。一方、Full Sandboxは本番組織と同じデータとメタデータを含むことができます。コピーされる内容がメタデータのみなのは「Developer Sandbox」と「Developer Pro Sandbox」です。",
            "これは不正解です。変更セットは、Developer Sandbox、Developer Pro Sandbox、Partial Copy Sandbox、および Full Sandboxのすべてのサンドボックスタイプで使用することができます。これらのサンドボックスを使用して、変更セットを介して組織間でメタデータの変更を移行することができます。",
            "これは正解です。Partial Copy Sandboxはデータストレージに5GBの制限があります。これはFull Sandboxには当てはまらない特徴で、Full Sandboxは本番組織と同じデータを含むことができます。"
        ]
    },
    {
        "number": "20",
        "question": "開発者は、取引先オブジェクトの不要なカスタム項目をスキーマビルダーを使用して削除するには、どうすればよいでしょうか。",
        "choices": ["コード内のすべての参照を削除すると、スキーマビルダーからカスタム項目が削除されます。", "コードからすべての参照を削除してから、スキーマビルダーからカスタム項目を削除します。", "スキーマビルダーで削除するカスタム項目をマークしてから、宣言型UIから削除します。", "スキーマビルダーからカスタム項目を削除すると、コード内のすべての参照が削除されます。"],
        "correct": ["コードからすべての参照を削除してから、スキーマビルダーからカスタム項目を削除します。"],
        "explanations":["コード内のすべての参照を削除すると、スキーマビルダーからカスタム項目が削除されます。", "コードからすべての参照を削除してから、スキーマビルダーからカスタム項目を削除します。", " スキーマビルダーで削除するカスタム項目をマークしてから、宣言型UIから削除します。", " スキーマビルダーからカスタム項目を削除すると、コード内のすべての参照が削除されます。"],
        "descriptions":[
            "これは不正解です。コードから参照を削除しても、自動的にスキーマビルダーから項目が削除されるわけではありません。項目の削除操作は明示的に行う必要があります。",
            "これは正解です。項目がコード内で使用されている場合、その参照を削除しないと項目を削除できません。したがって、まずコードからすべての参照を削除し、その後スキーマビルダーで項目を削除します。",
            "これは不正解です。スキーマビルダーで削除マークをつけるという手順は存在しません。また、宣言型UIから削除という手順も不適切です。これらの手順は適切な削除フローを追っていないため、エラーを引き起こす可能性があります。",
            "これは不正解です。Salesforceでは、項目を削除する前に、その項目への全てのコード参照を手動で削除する必要があります。つまり、スキーマビルダーから項目を削除しても、自動的にコード内の参照が削除されるわけではありません。このステップを飛ばして項目を削除しようとするとエラーが発生します。それぞれのコンポーネントが独立して管理されているため、これらの手順は重要です。"
        ]
    },
    {
        "number": "21",
        "question": "開発者は、すべての テストが合格しているかどうかを知る必要があります。開発者はどの機能を使用できますか。 2つ選びなさい。",
        "choices": ["開発者コンソール", "Ant 移行ツール", "Salesforce  UI [Apex  テスト実行]", "Workbenchメタデータの取得"],
        "correct": ["開発者コンソール","Salesforce  UI [Apex  テスト実行]"],
        "explanations":["開発者コンソール", "Ant 移行ツール", "Salesforce  UI [Apex  テスト実行]", " Workbenchメタデータの取得"],
        "descriptions":[
            "これは正解です。開発者コンソールを使用すると、Salesforce内で直接コードを作成、編集、 テストすることができます。 テスト実行機能を利用すれば、テスト結果を確認し、すべてのテストが合格しているかどうかを知ることができます。",
            "これは不正解です。Ant 移行ツールはSalesforceのメタデータを操作するためのツールで、主にメタデータのエクスポートやインポート、デプロイに使用されます。 テストの実行や結果の確認には使用できません。",
            "これは正解です。Salesforce  UIからApexテストを実行すると、テスト結果が表示されます。これにより、すべてのテストが合格しているかどうかを確認することができます。",
            "これは不正解です。WorkbenchはSalesforceのメタデータを取得、照会、更新するためのツールです。 テストの実行や結果の確認には使用できません。"
        ]
    },
    {
        "number": "22",
        "question": "Salesforce Lightning環境において、ユーザーページレイアウトのアクションに関係なく、ユーザープロファイルページに表示される標準的なChatterアクションは何ですか。2つ選びなさい。",
        "choices": ["投稿", "感謝(WDC)", "アンケート", "ファイル","メール"],
        "correct": ["投稿","アンケート"],
        "explanations":["投稿", "感謝(WDC)", "アンケート", "ファイル","メール"],
        "descriptions":[
            "これは正解です。ユーザープロファイルページには、ユーザーが自分のフィードにメッセージを投稿するための「投稿」アクションが標準的に表示されます。",
            "これは不正解です。ユーザープロファイルページでの「感謝」アクションは、Salesforce Classic環境専用のアクションです。",
            "これは正解です。ユーザープロファイルページには、「アンケート」アクションが標準的に表示されるChatterアクションの一部として含まれます。",
            "これは不正解です。ユーザープロファイルページでの「ファイル」アクションは、Salesforce Classic環境専用のアクションです。",
            "これは不正解です。「メール」アクションはユーザープロファイルページに標準的に表示されるアクションではありません。"
        ]
    },
    {
        "number": "23",
        "question": "Lightningコンポーネントバンドルに含めることができるリソースはどれですか。2つ選びなさい。",
        "choices": ["Apexクラス", " Adobe Flash", "JavaScript", "ドキュメント"],
        "correct": ["JavaScript","ドキュメント"],
        "explanations":["Apexクラス", "Adobe Flash", "JavaScript", "ドキュメント"],
        "descriptions":[
            "これは不正解です。公式ドキュメントに記載されているリソースの中に、Apexクラスに該当する項目は存在しません。",
            "これは不正解です。公式ドキュメントに記載されているリソースの中に、 Adobe Flashに該当する項目は存在しません。",
            "これは正解です。公式ドキュメントには、コンポーネント内のイベントを処理するクライアント側コントローラのメソッドを含む「コントローラ」や、コンポーネントのバンドル内の JavaScript コードからコール可能な JavaScript 関数を持つ「ヘルパー」というリソースが存在します。",
            "これは正解です。公式ドキュメントには、説明、サンプルコード、およびコンポーネント例への参照を含む「ドキュメント」というリソースが存在します。"
        ]
    },
    {
        "number": "24",
        "question": "ユーザーが特定のオブジェクト用の作成アクションを使って新しいデータを作成する場合、その新しいデータに関連する情報がどのタイムラインに表示されますか。3つ選びなさい。",
        "choices": ["レコードを作成したユーザーのChatterフィード", "新しいレコードが作成されたレコードのフィード", "レコードを表示できるすべてのユーザーのユーザープロフィールフィード", "新しいレコードのフィードの最初のエントリとして","レコードが作成されたレコードをフォローする最初のユーザーのChatterフィード"],
        "correct": ["レコードを作成したユーザーのChatterフィード","新しいレコードが作成されたレコードのフィード","新しいレコードのフィードの最初のエントリとして"],
        "explanations":["レコードを作成したユーザーのChatterフィード", "新しいレコードが作成されたレコードのフィード", "レコードを表示できるすべてのユーザーのユーザープロフィールフィード", " レコードが作成されたレコードをフォローする最初のユーザーのChatterフィード"],
        "descriptions":[
            "これは正解です。ユーザーが新しいレコードを作成すると、そのユーザーのChatterフィードにアクションが記録されます。",
            "これは正解です。作成された新しいレコード自体のフィードにも、そのレコードが作成されたという情報が表示されます。",
            "これは不正解です。すべてのユーザーのプロフィールフィードに新しいレコードの作成情報が表示されるわけではありません。そのレコードに関連する情報やアクションがユーザーと直接関係している場合のみ表示されます。",
            "これは正解です。新しいレコードが作成された時、そのレコードのフィードにその情報が最初のエントリとして表示されます。",
            "これは不正解です。ただレコードをフォローしているだけのユーザーのChatterフィードに、そのレコードの新しい作成情報が自動的に表示されるわけではありません。フォローしているユーザーがその情報を明示的に共有した場合のみ表示されます。"
        ]
    },
    {
        "number": "25",
        "question": "開発者は、商品( API名:Product2)と価格表(API名:Pricebook2)のテストデータを作成するときにどのステートメントを使用しますか。",
        "choices": ["List objList = Test.loadData(Account.sObjectType, “myResource”);", "Pricebook pb = new Pricebook();", "Id pricebookId = Test.getStandardPricebookId();", "IsTest(SeeAllData = false);"],
        "correct": ["Id pricebookId = Test.getStandardPricebookId();"],
        "explanations":["List objList = Test.loadData(Account.sObjectType, ‘myResource’);", "Pricebook pb = new Pricebook();", " Id pricebookId = Test.getStandardPricebookId();", " @IsTest(SeeAllData = false);"],
        "descriptions":[
            "これは不正解です。このステートメントは、テストデータをロードするために使用されますが、Account.sObjectTypeという部分が取引先オブジェクトを指しています。したがって、商品(API名:Product2)や価格表(API名:Pricebook2)のテストデータを作成するためのステートメントとは言えません。",
            "これは不正解です。このコードは価格表の新しいインスタンスを作成するものですが、Pricebookは正しいAPI名ではありません。正しいAPI名はPricebook2です。",
            "これは正解です。Test.getStandardPricebookId();は組織内の標準価格表のIDを返すSalesforce既存のメソッドです。このメソッドの知識がないと、解答が難しく感じられるかもしれません。参考：Test.getStandardPricebookId();",
            "これは不正解です。@IsTest(SeeAllData = false)はテストクラスやテストメソッドの上部にアノテーションとして付加されるもので、ステートメントとしての実行はできません。また、これはテストメソッドが組織の全データにアクセスするかどうかを制御するためのもので、直接的にテストデータの作成には関与しません。"
        ]
    },
    {
        "number": "26",
        "question": "次のデバッグステートメントを使用して、取引先オブジェクトのListViewを返すコードブロックはどれですか。",
        "following-code": [
            "system.debug(controller.getListViewOptions());"
        ],
        "choices": ["ApexPages.StandardSetController controller = new Apexpages.StandardSetController([SELECT id FROM Account LIMIT 1]);", "ApexPages.StandardController controller = new ApexPages.StandardController([SELECT Id FROM Account LIMIT 1]);", "ApexPages.StandardController controller = new ApexPages.StandardController(Database.getQueryLocator(‘SELECT Id FROM Account LIMIT 1’));", "ApexPages.StandardSetController controller = new ApexPages.StandardSetController(Database.getQueryLocator(‘SELECT Id FROM Account LIMIT 1’));"],
        "correct": ["ApexPages.StandardSetController controller = new ApexPages.StandardSetController(Database.getQueryLocator(‘SELECT Id FROM Account LIMIT 1’));"],
        "explanations":["ApexPages.StandardSetController controller = new Apexpages.StandardSetController([SELECT id FROM Account LIMIT 1]);", "ApexPages.StandardController controller = new ApexPages.StandardController([SELECT Id FROM Account LIMIT 1]);", "ApexPages.StandardController controller = new ApexPages.StandardController(Database.getQueryLocator(‘SELECT Id FROM Account LIMIT 1’));", "ApexPages.StandardSetController controller = new ApexPages.StandardSetController(Database.getQueryLocator(‘SELECT Id FROM Account LIMIT 1’));"],
        "descriptions":[
            "これは不正解です。StandardSetControllerは一連のレコード(例えば、リストビュー)を表すために使用されますが、このコードブロックではSOQLクエリを直接StandardSetControllerのコンストラクタに渡しており、これは正しい使い方ではありません。StandardSetControllerはリストやDatabase.QueryLocatorオブジェクトを引数に取るべきです。",
            "ApexPages.StandardController controller = new ApexPages.StandardController([SELECT Id FROM Account LIMIT 1]);",
            "ApexPages.StandardController controller = new ApexPages.StandardController(Database.getQueryLocator(‘SELECT Id FROM Account LIMIT 1’));",
            "ApexPages.StandardSetController controller = new ApexPages.StandardSetController(Database.getQueryLocator(‘SELECT Id FROM Account LIMIT 1’));"
        ]
    },
    {
        "number": "27",
        "question": "通貨項目は、Apexのどのプリミティブデータ型に自動的に割り当てられますか。",
        "choices": ["Integer", "Decimal", "Double", "Currency"],
        "correct": ["Decimal"],
        "explanations":["Integer", "Decimal", "Double", "Currency"],
        "descriptions":[
            "これは不正解です。Integer型は整数を表すために使用されますが、通貨項目には小数点以下の値が含まれることが一般的です。そのため、通貨項目を格納するためには、小数点以下の値をサポートするデータ型が必要です。",
            "これは正解です。Salesforce Apexでは、通貨項目はDecimal型に自動的に割り当てられます。Decimal型は固定小数点または浮動小数点の数値を表すことができ、通貨のような精度が必要な値に適しています。",
            "これは不正解です。Double型も浮動小数点数を表すことができますが、Salesforce Apexにおいて通貨項目はDecimal型に割り当てられます。Double型はより大きな範囲の数値を扱うことができますが、通貨値にはDecimalの精度が適しています。",
            "これは不正解です。ApexにはCurrencyというプリミティブデータ型は存在しません。"
        ]
    },
    {
        "number": "28",
        "question": "dowork() メソッドを呼び出す際に使用できるコードセグメントはどれですか。",
        "choices": ["For(Trigger.isInsert t: Trigger.new) { dowork(); }", "If(Trigger.isInsert) dowork();", "If(Trigger.isRunning) dowork();", "For(Trigger.isRunning t: Trigger.new) { dowork(); }"],
        "correct": ["If(Trigger.isInsert) dowork();"],
        "explanations":["For(Trigger.isInsert t: Trigger.new) { dowork(); }", " If(Trigger.isInsert) dowork();", " If(Trigger.isRunning) dowork();", " For(Trigger.isRunning t: Trigger.new) { dowork(); }"],
        "descriptions":[
            "これは不正解です。Trigger.isInsert はbooleanのプロパティであり、forループの初期化部分で変数に代入することはできません。また、For(Trigger.isInsert t: Trigger.new)という文法自体が正しくありません。正しくはforループ内で、コレクションから要素を取り出す形(例: for(SObject t : Trigger.new))となりますが、このコードではTrigger.isInsertというbooleanプロパティを変数tに代入しようとしています。",
            "これは正解です。Trigger.isInsertは、現在のトリガーがInsert操作の際に実行されているかを示すbooleanのプロパティです。したがって、これがtrueの場合、dowork()メソッドが呼び出されます。",
            "これは不正解です。Trigger.isRunningというプロパティはApexのTriggerコンテキストには存在しません。したがって、このコードはエラーとなります。",
            "これは不正解です。前述の通り、Trigger.isRunningというプロパティは存在しないため、このコードはエラーとなります。さらに、Trigger.isRunningをforループの初期化部分で変数に代入するという文法も不正確です。"
        ]
    },
    {
        "number": "29",
        "question": "企業は、候補者と面接をモデル化する求人アプリを求めています。各候補者レコードの面接の総数を表示します。面接レコードのセキュリティを、候補レコードのセキュリティとは独立して定義します。開発者はこのタスクを達成するために何をしますか。2つ選びなさい。",
        "choices": ["面接レコードをカウントする候補オブジェクトに積み上げ集計項目を作成します", "候補オブジェクトと面接オブジェクトの間に主従関係を作成します", "候補オブジェクトと面接オブジェクトの間に参照関係を作成します", "候補オブジェクトの項目を更新するトリガーを面接オブジェクトに作成します"],
        "correct": ["候補オブジェクトと面接オブジェクトの間に参照関係を作成します","候補オブジェクトの項目を更新するトリガーを面接オブジェクトに作成します"],
        "explanations":["面接レコードをカウントする候補オブジェクトに積み上げ集計項目を作成します", "候補オブジェクトと面接オブジェクトの間に主従関係を作成します", "候補オブジェクトと面接オブジェクトの間に参照関係を作成します", "候補オブジェクトの項目を更新するトリガーを面接オブジェクトに作成します"],
        "descriptions":[
            "これは不正解です。積み上げ集計フィールドは主従関係においてのみ作成可能ですが、このシナリオでは面接のセキュリティ設定を独立して持つ必要があるため、主従関係は使用できません。",
            "これは不正解です。主従関係はセキュリティ設定を共有するため、このケースの要件には適していません。",
            "これは正解です。参照関係を使用して2つのオブジェクト間の関連を作成することで、それぞれのセキュリティ設定を独立して持つことができます。",
            "これは正解です。積み上げ集計項目が利用できない場合、面接オブジェクトにトリガーを実装することで、面接レコードが追加または削除された際に関連する候補レコードの面接数を自動的に更新することが可能です。このアプローチは、参照関係で結ばれた２つのオブジェクト間で集計を行う際の一般的な方法の一つです。"
        ]
    },
    {
        "number": "30",
        "question": "組織には、取引先関連の機能を提供するさまざまなApexクラスがあります。新しい入力規則がオブジェクトに追加された後、多くのテストメソッドが失敗します。失敗を解決し、将来の入力規則に必要なコード変更の数を減らすために何ができますか。2つ選びなさい。",
        "choices": ["有効な取引先レコードを作成するメソッドを作成し、テストメソッド内からこのメソッドを呼び出します。", "有効な取引先レコードを静的リソースからロードするメソッドを作成し、テストメソッド内でこのメソッドを呼び出します。", "有効な取引先レコードのコールアウトを実行するメソッドを作成し、テストメソッド内からこのメソッドを呼び出します。", "有効な取引先レコードを照会するメソッドを作成し、テストメソッド内からこのメソッドを呼び出します。"],
        "correct": ["有効な取引先レコードを作成するメソッドを作成し、テストメソッド内からこのメソッドを呼び出します。","有効な取引先レコードを静的リソースからロードするメソッドを作成し、テストメソッド内でこのメソッドを呼び出します。"],
        "explanations":["有効な取引先レコードを作成するメソッドを作成し、テストメソッド内からこのメソッドを呼び出します。", "有効な取引先レコードを静的リソースからロードするメソッドを作成し、テストメソッド内でこのメソッドを呼び出します。", "有効な取引先レコードのコールアウトを実行するメソッドを作成し、テストメソッド内からこのメソッドを呼び出します。", " 有効な取引先レコードを照会するメソッドを作成し、テストメソッド内からこのメソッドを呼び出します。"],
        "descriptions":[
            "これは正解です。入力規則が変更されると、テストデータの作成方法も変わる可能性があります。しかし、すべてのテストメソッドで同一のメソッドを使用して取引先レコードを作成することで、入力規則が変更された場合にそのメソッドを更新するだけで、他の多くのテストメソッドの変更を回避することができます。",
            "これは正解です。静的リソースからテストデータをロードすることで、コード内でテストデータをハードコードする必要がなくなります。入力規則が変更された場合、静的リソースのみを更新することで対応が可能になり、テストメソッドの変更を最小限に抑えることができます。",
            "これは不正解です。テストメソッドの中で実際のコールアウトを実行するのは一般的に推奨されていません。また、テスト実行時に外部システムとの依存関係が生まれることは避けるべきです。",
            "これは不正解です。テストメソッドは他のデータに依存しない状態で実行されるべきです。つまり、テスト実行時に組織内の既存データを照会して使用するのは適切ではありません。テストメソッドは独立して、一貫した結果を提供する必要があります。"
        ]
    },
    {
        "number": "31",
        "question": "ある開発者が、エンジンとその部品を追跡する アプリケーションを作成しています。個々の部品は、異なるタイプのエンジンで使用することができます。データを追跡し、孤立したレコードを防ぐには、どのようなデータモデルを使用する必要がありますか。",
        "choices": ["エンジンと部品の一対多のモデルを表すために、主従関係を作成する。", "連結オブジェクトを作成し、主従関係を通じて多数のエンジンと多数の部品を関連付けます。", "参照関係を作成し、各部品が親エンジン・オブジェクトにどのように関係するかを表現します。", "連結オブジェクトを作成し、参照関係を通じて多数のエンジンと多数の部品を関連付けます。"],
        "correct": ["連結オブジェクトを作成し、主従関係を通じて多数のエンジンと多数の部品を関連付けます。"],
        "explanations":["エンジンと部品の一対多のモデルを表すために、主従関係を作成する。", "連結オブジェクトを作成し、主従関係を通じて多数のエンジンと多数の部品を関連付けます。", "参照関係を作成し、各部品が親エンジン・オブジェクトにどのように関係するかを表現します。", "連結オブジェクトを作成し、参照関係を通じて多数のエンジンと多数の部品を関連付けます。"],
        "descriptions":[
            "これは不正解です。主従関係は一対多の関係を表しますが、このシナリオでは多対多の関係が必要です。",
            "これは正解です。連結オブジェクトは、多対多の関係を表現するために使用されます。参考：多対多オブジェクトリレーションの作成",
            "これは不正解です。参照関係は、二つのオブジェクト間の関係を表すものですが、多対多の関係を直接表現することはできません。",
            "これは不正解です。連結オブジェクトは主従関係を通じて多対多の関係を表現するために使用されますが、参照関係を通じては多対多の関係を表現することはできません。"
        ]
    },
    {
        "number": "32",
        "question": "StandardControllerクラスで定義されているメソッドはどれですか。2つ選びなさい。",
        "choices": ["Merge", "Save", "Undelete", "Cancel"],
        "correct": ["Save","Cancel"],
        "explanations":[" Merge", "Save", " Undelete", "Cancel"],
        "descriptions":[
            "これは不正解です。StandardControllerクラスのメソッド「Merge」は含まれていません。",
            "これは正解です。「Save」はStandardControllerクラスに定義されているメソッドであり、変更を保存し、更新された PageReference を返します。",
            "これは不正解です。StandardControllerクラスのメソッド「Undelete」は含まれていません。",
            "これは正解です。「Cancel」はStandardControllerクラスに定義されているメソッドであり、キャンセルページの PageReference を返します。"
        ]
    },
    {
        "number": "33",
        "question": "取引先レコードの項目値が更新された場合、関連する商談のカスタム項目の値を更新する方法はどれですか。2つ選びなさい。",
        "choices": ["取引先オブジェクトのApexトリガー", "取引先オブジェクトの プロセスビルダー", "取引先オブジェクトのクロスオブジェクト数式項目", "取引先オブジェクトのワークフロールール"],
        "correct": ["取引先オブジェクトのApexトリガー","取引先オブジェクトのプロセスビルダー"],
        "explanations":["取引先オブジェクトのApexトリガー", "取引先オブジェクトの プロセスビルダー", "取引先オブジェクトのクロスオブジェクト数式項目", "取引先オブジェクトのワークフロールール"],
        "descriptions":[
            "これは正解です。Apexトリガーは特定のDML操作(例：レコードの更新)に応じてカスタムApexコードを実行します。このトリガーを使用して、取引先の更新時に関連する商談のカスタム項目を更新できます。",
            "これは正解です。プロセスビルダーはSalesforceでのビジュアルワークフロー作成ツールで、取引先レコードの更新に基づいて商談のカスタム項目の自動更新を行うことができます。しかし、現在Salesforceはプロセスビルダーの使用を非推奨とし、新しいオートメーションの作成には「フロー」の使用が推奨されています。既存のプロセスは引き続き動作しますが、新しいオートメーションを構築する際は、フローの利用を検討してください。",
            "これは不正解です。クロスオブジェクト数式項目は、あるオブジェクトの項目値を別の関連するオブジェクトの項目値に基づいて表示するためのものであり、実際の値の更新には使用できません。",
            "これは不正解です。ワークフロールールは特定の条件を満たすと、アクション(アラートの送信、タスクの生成、項目の更新など)を自動実行しますが、更新可能なのは同一オブジェクト内のフィールドのみです。したがって、取引先の変更により商談のカスタム項目を更新することは、ワークフロールールでは不可能です。また、Salesforceではワークフロールールや プロセスビルダーの使用を段階的に廃止し、より高機能な「フロー」への移行を進めています。"
        ]
    },
    {
        "number": "34",
        "question": "Lightningコンポーネントは次のうちどの製品で利用できますか。3つ選びなさい。",
        "choices": ["Salesforceモバイルアプリ", "Force.com", "コミュニティ", "Lightning Experience"],
        "correct": ["Salesforceモバイルアプリ","コミュニティ","Lightning Experience"],
        "explanations":["Salesforceモバイルアプリ", "Force.com", "コミュニティ", " Lightning Experience"],
        "descriptions":[
            "これは正解です。Salesforceのモバイルアプリを使用する時、顧客はLightningコンポーネントを通じて快適な操作体験を受けることができます。例えば、商品情報の参照や商談のアップデートなど、移動中や外出先でもスムーズに業務を進めることができます。",
            "これは不正解です。Force.comは、開発者が アプリケーションの開発やカスタマイズを行うプラットフォームです。一般の顧客が直接アクセスして作業をすることは想定されていません。Lightningコンポーネントは、主にエンドユーザー向けのインターフェースであるLightning Experienceでの利用が主です。従って、Force.comはLightningコンポーネントを使用できる場所ではありません。",
            "これは正解です。Salesforceコミュニティを利用すると、顧客やビジネスパートナーとのコミュニケーションが容易になります。Lightningコンポーネントは、このコミュニティページのデザインや機能性を向上させ、ユーザーに快適な操作体験を提供します。",
            "これは正解です。Lightning ExperienceはSalesforceの最新のユーザーインターフェースです。顧客は、この新しいインターフェースを通じて、Lightningコンポーネントの持つ直感的なデザインや高機能性を日常的に利用することができます。データの参照や更新がより簡単で効率的になります。"
        ]
    },
    {
        "number": "35",
        "question": "以下コードセグメントが実行された後のxの値は何ですか。",
        "following-code": [
            "String x = 'A';",
            "Integer i = 10;",
                "if (i < 15 ){",
                " i = 15;",
            " try {",
            "  x = 'B';",
            " } else if (i < 20 ){",
            "  x = 'C';",
            "} else {",
            " x = 'D';",
            "}"
        ],
        "choices": ["A", "B", "C", "D"],
        "correct": ["B"],
        "explanations":["A", "B", " C", "D"],
        "descriptions":[
            "これは不正解です。最初のif文の条件 ‘i < 15’ がtrueであるため、’x’は ‘B’ に変更されます。したがって、最終的な ‘x’ の値は ‘A’ ではなく ‘B’ となります。",
            "これは正解です。最初に’i’は10です。最初のif文の条件 ‘i < 15’ がtrueであるため、’i’は15に変更され、’x’は’B’に変更されます。その後のelse ifやelseの条件は評価されず、コードは実行を終了します。よって、最終的な ‘x’ の値は ‘B’ となります。",
            "これは不正解です。最初のif文の条件 ‘i < 15’ がtrueなので、その後のelse ifの条件 ‘i < 20’ は評価されません。",
            "これは不正解です。最初のif文の条件 ‘i < 15’ がtrueなので、その後のelseの部分は評価されません。"
        ]
    },
    {
        "number": "36",
        "question": "開発者がプログラムで新しい取引先責任者レコードを作成する際、どの標準項目が必須で入力が求められますか。",
        "choices": ["Accountld", "Name", "LastName", "FirstName"],
        "correct": ["LastName"],
        "explanations":["Accountld", "Name", "LastName", " FirstName"],
        "descriptions":[
            "これは不正解です。取引先責任者レコード(Contact)を作成する際にはAccountId項目は必須ではありません。AccountIdは取引先(Account)と取引先責任者(Contact)を関連付けるために使用されますが、必須条件ではなく、AccountIdを指定せずにContactレコードを作成することは可能です。ただし、これは通常の業務フローからは逸脱した操作となります。具体的には以下です。",
            "これは不正解です。取引先責任者レコード(Contact)を作成する際、Name項目に直接書き込むことはできません。Name項目は読み取り専用で、FirstNameとLastName項目から自動的に生成されます。そのため、プログラムで新しい取引先責任者レコードを挿入する場合、Name項目を直接指定するのではなく、FirstNameまたはLastName項目に値を設定することで間接的にName項目の値を制御します。これはSalesforceのデータモデルにおける標準的な振る舞いであり、開発者がName項目に直接値を書き込むことを試みると、「Field is not writeable: Contact.Name」というエラーが出るためです。",
            "これは正解です。取引先責任者レコード(Contact)を作成する際にはLastName項目が必須となります。LastName項目が入力されていない場合、Contactレコードの作成はエラーとなります。",
            "これは不正解です。取引先責任者レコード(Contact)を作成する際にはFirstName項目は必須ではありません。FirstName項目はオプションとなり、入力しなくてもContactレコードの作成は可能です。"
        ]
    },
    {
        "number": "37",
        "question": "Universal Containers社は、注文を外部データオブジェクトとしてSalesforceに含めています。 外部オブジェクトと取引先の両方にある取引先のキー項目を活用して、取引先と注文オブジェクトの関係(1対多の関係)を作成します。 どの関係を作成しますか。",
        "choices": ["主従関係", "間接参照関係", "参照関係", "階層関係","外部参照関係"],
        "correct": ["間接参照関係"],
        "explanations":["主従関係", "間接参照関係", "参照関係", "階層関係","外部参照関係"],
        "descriptions":[
            "これは不正解です。主従関係は、二つのオブジェクト間での強い関係を表します。従オブジェクトのレコードは主オブジェクトのレコードに所属しており、主オブジェクトのレコードが削除されると、関連する従オブジェクトのレコードも自動的に削除されます。外部オブジェクトは従オブジェクトとしての主従関係を持つことができません。",
            "これは正解です。間接参照関係は、外部オブジェクトと標準またはカスタムオブジェクトの間で作成されます。この関係は、外部オブジェクト上の外部キー項目を使用して、標準またはカスタムオブジェクトの項目と一致させることにより、レコード間の関係を確立します。このケースでは、取引先と注文オブジェクトの間で1対多の関係を確立するための適切な関係です。",
            "これは不正解です。参照関係は二つのオブジェクト間での弱い関係を表します。外部オブジェクトは参照関係を持つことができません。",
            "これは不正解です。階層関係は、ユーザーオブジェクト内のレコード間での関係を示すために特に設計されています。例えば、上司と部下のような関係を表現するために使われます。このケースには適用されません。",
            "これは不正解です。外部参照関係は、外部オブジェクト間の関係を作成するためのものであり、外部オブジェクトと標準またはカスタムオブジェクトの間の関係を表現するためのものではありません。"
        ]
    },
    {
        "number": "38",
        "question": "承認のためにロックされた後、どのユーザーがレコードを編集できますか。2つ選びなさい。システム管理者",
        "choices": ["システム管理者", "以前にレコードを承認したユーザー", "現在の承認者として割り当てられているユーザー", "階層内でより高い役割を持つユーザー"],
        "correct": ["システム管理者","現在の承認者として割り当てられているユーザー"],
        "explanations":["システム管理者", "以前にレコードを承認したユーザー", "現在の承認者として割り当てられているユーザー", " 階層内でより高い役割を持つユーザー"],
        "descriptions":[
            "これは正解です。Salesforceにおいて、システム管理者はほとんど全てのレコードや設定に対する権限を持っています。承認 プロセスによりロックされたレコードも、システム管理者は編集することができます。",
            "これは不正解です。レコードが以前に承認されたユーザーによって自動的に編集権限が与えられるわけではありません。このユーザーは、現在の承認者や設定に応じた特定の権限を持つ場合にのみ編集できます。",
            "これは正解です。承認 プロセスの設定に「管理者または…」オプションが選択されている場合、現在の承認者はロックされたレコードを編集することができます。",
            "これは不正解です。Salesforceの階層構造において、上位の役割を持つユーザーは通常、下位のユーザーが所有するレコードを表示または編集することができます。しかし、承認 プロセスによってロックされたレコードの編集権限は、単に階層内での位置に基づくものではありません。"
        ]
    },
    {
        "number": "39",
        "question": "Apexで単体テストを作成する場合、以下のどの記述が正しいですか。",
        "choices": ["複数のメソッドを使用した単体テストでは、1つのメソッドが失敗するたびにすべてのメソッドが失敗します。", "テストカバレッジを拡大するには、1つのメソッドに多数のコード行を含む大規模なテストクラスが必要です。", "トリガーは、サンドボックスから実稼働環境に展開するために単体テストを必要としません。", "コードカバレッジを増加させないSystem.Assert文は、単体テストで重要な役割を果たします。"],
        "correct": ["コードカバレッジを増加させないSystem.Assert文は、単体テストで重要な役割を果たします。"],
        "explanations":["複数のメソッドを使用した単体テストでは、1つのメソッドが失敗するたびにすべてのメソッドが失敗します。", "テストカバレッジを拡大するには、1つのメソッドに多数のコード行を含む大規模なテストクラスが必要です。", "トリガーは、サンドボックスから実稼働環境に展開するために単体テストを必要としません。", "コードカバレッジを増加させないSystem.Assert文は、単体テストで重要な役割を果たします。"],
        "descriptions":[
            "これは不正解です。Apexの単体テストでは、各テストメソッドは独立して実行されます。1つのテストメソッドが失敗しても、他のテストメソッドに影響はありません。失敗するテストメソッドのみが失敗とマークされ、他のテストメソッドはその結果に基づいて評価されます。",
            "これは不正解です。テストの目的は、可能な限り多くのコード行をテストすることではなく、重要な機能とエッジケースをカバーすることです。コードカバレッジを増やすために大量のコードを含むテストメソッドを作成すると、テストの可読性と保守性が低下し、テストの品質が落ちる可能性があります。",
            "これは不正解です。Apexトリガーは、サンドボックスから実稼働環境に展開する前に、全体のApexコード(クラスとトリガーを合わせたもの)の少なくとも75%のカバレッジを持っている必要があります。また、各トリガーには最低1%のカバレッジが必要です。この1%のカバレッジは、少なくとも1つのテストメソッドがトリガーの一部をカバーしていることを確認するためのものです。つまり、全体のカバレッジが75%以上であっても、任意のトリガーがテストされていない場合、そのトリガーはデプロイできないことを意味します。",
            "これは正解です。System.Assert文はテストメソッド内で期待される結果と実際の結果を比較するために使用されます。これはコードの正確性を確認するために不可欠です。System.Assert文自体はコードカバレッジを増やしませんが、テストの品質を確保する上で非常に重要です。"
        ]
    },
    {
        "number": "40",
        "question": "開発者が、LastModified項目の値が90日以上である場合に、List内の各Accountを非アクティブまたは非アクティブとしてマークしたいと考えています。開発者はどのApexテクニックを使用する必要がありますか。",
        "choices": ["内部にswitch文を含むforループ", "内部にforループを持つIf/else文", "内部にforループがあるswitch文", "内部にif/else文があるforループ"],
        "correct": ["内部にif/else文があるforループ"],
        "explanations":["内部にswitch文を含むforループ", "内部にforループを持つIf/else文", "内部にforループがあるswitch文", "内部にif/else文があるforループ"],
        "descriptions":[
            "これは不正解です。LastModified項目の値が90日以上であるかどうかを確認するためのシンプルな条件を評価する場合、switch文は不要です。これは、2つ以上の具体的なケースを比較する際に使用されることが多いです。",
            "これは不正解です。この選択肢では、if/else文が外部にあり、forループがその内部にあると解釈されます。このアプローチでは、条件が真か偽かに基づいて全体のループ処理が行われる可能性があります。",
            "これは不正解です。同様に、このシナリオではswitch文は不要です。",
            "これは正解です。リスト内の各Accountを反復処理するforループの内部で、if/else文を使用してLastModified項目の値をチェックします。この値が90日以上である場合、アカウントを非アクティブまたは非アクティブとしてマークします。"
        ]
    },
    {
        "number": "41",
        "question": "開発者は、複雑なトリガーロジックを処理するためにApexヘルパークラスを作成しました。トリガーがDMLガバナ制限を超えた場合、ヘルパークラスはどのようにユーザーに警告できますか。",
        "choices": ["Messaging.sendEmail()を使用してトランザクションを続行し、DML文の数を超えたらユーザーにアラートを送信する。", "PageReference.setRedirect()を使用して、DML文の数を超える前にユーザーをカスタムVisualforceページにリダイレクトする。", "Limits.getDMLRows()を使用して、DML文の数を超える前にエラーメッセージを表示する。", "ApexMessage.Messages()を使用して、DML文の数を超えた後にエラーメッセージを表示する。"],
        "correct": ["Limits.getDMLRows()を使用して、DML文の数を超える前にエラーメッセージを表示する。"],
        "explanations":["Messaging.sendEmail()を使用してトランザクションを続行し、DML文の数を超えたらユーザーにアラートを送信する。", "PageReference.setRedirect()を使用して、DML文の数を超える前にユーザーをカスタムVisualforceページにリダイレクトする。", "Limits.getDMLRows()を使用して、DML文の数を超える前にエラーメッセージを表示する。", "ApexMessage.Messages()を使用して、DML文の数を超えた後にエラーメッセージを表示する。"],
        "descriptions":[
            "これは不正解です。Messaging.sendEmail()メソッドはメールを送信するために使用されますが、DMLガバナ制限を超えた時点でトリガーが失敗し、トランザクションがロールバックされるため、メールの送信は実行されません。加えて、ガバナ制限を超える前に警告を行うことは不可能です。",
            "これは不正解です。PageReference.setRedirect()は通常、VisualforceページのコントローラやカスタムのApexロジックで使用されます。トリガーの中でこの方法を使うことはできません。",
            "これは正解です。Limits.getDMLRows()メソッドを使用して、トリガーが実行されている間に現在のトランザクションでどれだけのDML行が使用されているかを監視できます。これにより、ガバナ制限に達する前に適切なエラーメッセージをトリガーからスローしてユーザーに警告することが可能です。",
            "これは不正解です。ApexMessage.Messages()というメソッドは存在しないため、エラーメッセージを表示するために使用することはできません。"
        ]
    },
    {
        "number": "42",
        "question": "販売管理チームは新しいインターンを雇用します。 インターンは商談を表示することはできませんが、取引先レコードを表示するときは、すべての商談の最新の完了日を表示する必要があります。開発者はこの要件を満たすために何をすればよいでしょうか。",
        "choices": ["親取引先の項目を更新するワークフロールールを作成します。", "取引先オブジェクトに商談の完了予定日で最大を表示する数式項目を作成します。", "取引先オブジェクトに商談の完了予定日の最大を表示する積み上げ集計項目を作成します。", "最新の商談の完了予定日を照会するトリガーを取引先オブジェクトに作成します。"],
        "correct": ["取引先オブジェクトに商談の完了予定日の最大を表示する積み上げ集計項目を作成します。"],
        "explanations":["親取引先の項目を更新するワークフロールールを作成します。", "取引先オブジェクトに商談の完了予定日で最大を表示する数式項目を作成します。", "取引先オブジェクトに商談の完了予定日の最大を表示する積み上げ集計項目を作成します。", "最新の商談の完了予定日を照会するトリガーを取引先オブジェクトに作成します。"],
        "descriptions":[
            "これは不正解です。ワークフロールールは基本的な業務プロセスを自動化するために使用されますが、関連リストのレコードから情報を集計する操作を実現することはできません。",
            "これは不正解です。数式項目は単一のレコード内の値を計算するために使用されますが、関連する複数のレコードからの情報を集約することはできません。したがって、すべての商談の最新の完了日を表示することはできません。",
            "これは正解です。積み上げ集計項目は、特定の親オブジェクト(この場合は取引先)に関連する子オブジェクト(この場合は商談)のレコードの値を合計、平均、最小、最大などで集約することができます。この機能を使用して、すべての商談の最新(つまり最大)の完了日を取引先に表示することができます。",
            "これは不正解です。トリガーはコードを使用して複雑な業務ロジックを実装できますが、Salesforceでは積み上げ集計項目を使用してこれをよりシンプルに実装することができます。また、無駄なコーディングは保守コストを増加させ、パフォーマンスに影響を与える可能性があるため、必要以上にトリガーを使用することは推奨されません。"
        ]
    },
    {
        "number": "43",
        "previous-code": [
            "public class PaymentTax {",
            "    public static decimal SalesTax = 0.0875;",
            "}\n",
            "trigger OpportunityLineItemTrigger on OpportunityLineItem (before insert, before update) {",
            "    PaymentTax PayTax = new PaymentTax();",
            "    decimal ProductTax = ProductCost * XXXXXXXXXXX;",
            "}"
        ],
        "question": "開発者には以上のコードブロックがあります。\nproductTaxを計算するために、開発者はどのコードセグメントをXXXXXXXXXXXに挿入して、トリガー内でクラス変数SalesTaxの値にアクセスできるようにしますか。",
        "choices": ["SalesTax", "PayTax.SalesTax", "PaymentTax.SalesTax", "OpportunityLineItemTrigger.SalesTax"],
        "correct": ["PaymentTax.SalesTax"],
        "explanations":["SalesTax", "PayTax.SalesTax", "PaymentTax.SalesTax", "OpportunityLineItemTrigger.SalesTax"],
        "descriptions":[
            "これは不正解です。このコードセグメントは、トリガー内のローカル変数またはメンバ変数を参照することを試みますが、SalesTaxはPaymentTaxクラス内の静的変数です。トリガーのスコープ内にはこの名前の変数が存在しないため、この方法でアクセスすることはできません。",
            "これは不正解です。SalesTaxはPaymentTaxクラス内の静的変数です。静的変数は、特定のインスタンスに依存せずクラス自体に関連付けられているため、インスタンスを使用してアクセスすることはできません。",
            "これは正解です。SalesTaxはPaymentTaxクラスの静的変数であるため、クラス名を使用してアクセスすることができます。この方法で、静的変数の値に正しくアクセスできます。",
            "これは不正解です。OpportunityLineItemTriggerトリガー内にSalesTax変数は定義されていません。そのため、この方法でアクセスすることはできません。"
        ]
    },
    {
        "number": "44",
        "question": "ユーザーが生成したデバッグステートメントを表示するために必要な最小ログレベルはどれですか。",
        "choices": ["DEBUG", "FINE", "INFO", "WARN"],
        "correct": ["DEBUG"],
        "explanations":["DEBUG", "FINE", "INFO", "WARN"],
        "descriptions":[
            "これは正解です。”DEBUG”レベルでは、デバッグ情報を含む基本的な情報メッセージ、エラーメッセージ、警告メッセージがログに記録されます。ユーザーが生成したデバッグステートメントは、このレベルで記録されるため、デバッグステートメントを表示するためには最低でも”DEBUG”レベルのログが必要となります。",
            "これは不正解です。”FINE”レベルは、”DEBUG”よりも詳細な情報を提供しますが、ユーザーが生成したデバッグステートメントの表示には”DEBUG”レベルで十分です。選択肢に”DEBUG”が含まれているため、このレベルを選ぶ必要はありません。",
            "これは不正解です。”INFO”レベルでは、基本的な情報メッセージ、エラーメッセージ、および警告メッセージがログに記録されますが、ユーザーが生成したデバッグステートメントは含まれません。したがって、このレベルでデバッグステートメントを表示することはできません。",
            "これは不正解です。”WARN”レベルでは、エラーメッセージと警告メッセージのみがログに記録されます。デバッグ情報はこのレベルには含まれないため、ユーザーが生成したデバッグステートメントは表示されません。"
        ]
    },
    {
        "number": "45",
        "question": "変更セットを送受信できる有効な宛先と送信元のペアはどれですか。2つ選びなさい。",
        "choices": ["本番環境へのサンドボックス", "サンドボックスへの開発者エディション", "本番環境への開発者エディション", "サンドボックスへのサンドボックス"],
        "correct": ["本番環境へのサンドボックス", "サンドボックスへのサンドボックス"],
        "explanations":["本番環境へのサンドボックス", "サンドボックスへの開発者エディション", "本番環境への開発者エディション", "サンドボックスへのサンドボックス"],
        "descriptions":[
            "これは正解です。サンドボックスは本番環境から派生したテスト環境であり、変更セットを通じて新機能や設定の変更を本番環境に送信することができます。これにより、テストと検証が行われた変更を安全に本番環境に適用することができます。",
            "これは不正解です。開発者エディションは本番環境やサンドボックスと直接的な関連性がない独立した組織です。そのため、開発者エディションからサンドボックスへの変更セットの送信は許可されていません。",
            "これは不正解です。前述したように、開発者エディションは本番環境と直接的な関連性がない独立した組織です。そのため、開発者エディションから本番環境への変更セットの送信も許可されていません。",
            "これは正解です。同じ本番環境から派生したサンドボックス間では、変更セットを通じてデータのやり取りが可能です。これにより、一つのサンドボックスで行われた開発やテストの結果を、別のサンドボックスで利用することができます。"
        ]
    },
    {
        "number": "46",
        "question": "開発者は、before insertトリガーを作成します。 開発者はトリガー本体のレコードにどのようにアクセスできますか。",
        "choices": ["Trigger.newコンテキスト変数にアクセスする", "Trigger.newRecordsコンテキスト変数にアクセスする", "Trigger.newMapコンテキスト変数にアクセスする", "Trigger.newListコンテキスト変数にアクセスする"],
        "correct": ["Trigger.newコンテキスト変数にアクセスする"],
        "explanations":["Trigger.newコンテキスト変数にアクセスする", "Trigger.newRecordsコンテキスト変数にアクセスする", "Trigger.newMapコンテキスト変数にアクセスする", "Trigger.newListコンテキスト変数にアクセスする"],
        "descriptions":[
            "これは正解です。Trigger.newは、before insert トリガーの実行中に挿入される予定のレコードのリストを表します。この変数は、データベースに保存される前の新規レコードを含むリストを提供し、開発者はこのリストを通じてこれらのレコードに対して処理を行うことができます。",
            "これは不正解です。Salesforceのトリガーコンテキスト変数にTrigger.newRecordsという変数は存在しません。したがって、開発者はこれを使用してレコードにアクセスすることはできません。",
            "これは不正解です。Trigger.newMapはレコードのIDをキーとして、それに関連するsObjectレコードを値として持つマップを提供します。しかし、before insert トリガーのタイミングでは、レコードはまだ挿入されていないため、IDがまだ生成されていません。従って、この変数はbefore insert トリガーで利用できません。",
            "これは不正解です。Salesforceのトリガーコンテキスト変数にTrigger.newListという変数は存在しません。したがって、開発者はこれを使用してレコードにアクセスすることはできません。"
        ]
    },
    {
        "number": "47",
        "question": "StandardSetControllerの機能とは何ですか。2つ選びなさい。",
        "choices": ["標準またはカスタムコントローラの機能を拡張します", "ページでレコードの一括更新を実行できます", "ページで大きなレコードセットのページネーションを実行できます", "大規模なレコードセットを読み取るときに、項目レベルセキュリティを適用します"],
        "correct": ["ページでレコードの一括更新を実行できます", "ページで大きなレコードセットのページネーションを実行できます"],
        "explanations":["標準またはカスタムコントローラの機能を拡張します", "ページでレコードの一括更新を実行できます", "ページで大きなレコードセットのページネーションを実行できます", "大規模なレコードセットを読み取るときに、項目レベルセキュリティを適用します"],
        "descriptions":[
            "これは不正解です。StandardSetControllerは標準またはカスタムコントローラの機能を直接拡張するものではありません。これは、リストビューや関連リストのようなレコードのセットを扱うためのコントローラです。",
            "これは正解です。StandardSetControllerを利用することで、Visualforceページ上で一括操作を行うことが可能になります。たとえば、ユーザーが一覧表示から複数のレコードを選択し、それらすべてに対して一括更新といった操作を実行することができます。",
            "これは正解です。StandardSetControllerには、ページネーションをサポートするためのメソッドやプロパティ(例: next(), previous(), getHasNext(), getHasPrevious())が含まれています。これを利用することで、大量のレコードを持つセットに対するページネーションを実装することが容易になります。",
            "これは不正解です。項目レベルセキュリティは、Salesforceのセキュリティモデルに基づくものであり、StandardSetControllerの主要な機能とは関係ありません。項目レベルセキュリティは、ユーザーが特定の項目を表示・編集できるかどうかを決定するものですが、これはStandardSetControllerの機能範囲外です。"
        ]
    },
    {
        "number": "48",
        "question": "開発者は、組織データを変更せずに取引先トリガーが正常に機能していることを確認する必要があります。取引先トリガーをテストするには、開発者は何をすべきですか。　",
        "choices": ["[取引先]タブの[新規]ボタンを使用して新しいレコードを作成する", "開発者コンソールのテストメニューを使用して、取引先トリガーのすべてのテストクラスを実行する", "Force.com IDEを使用する", "開発者コンソールで匿名実行機能を使用する"],
        "correct": ["開発者コンソールのテストメニューを使用して、取引先トリガーのすべてのテストクラスを実行する"],
        "explanations":["[取引先]タブの[新規]ボタンを使用して新しいレコードを作成する", "開発者コンソールのテストメニューを使用して、取引先トリガーのすべてのテストクラスを実行する", "Force.com IDEを使用する", "開発者コンソールで匿名実行機能を使用する"],
        "descriptions":[
            "これは不正解です。この方法では、新規の取引先レコードが作成され、組織データが変更されます。目的は組織データを変更せずにトリガーの機能を確認することなので、この手法は適切ではありません。",
            "これは正解です。テストクラスを使用すると、開発者は組織データを変更せずにトリガーが正常に機能するかを確認することができます。Salesforceでは、本番データに影響を与えずにコードをテストできるようにテストクラスを使用することを推奨しています。",
            "これは不正解です。Force.com IDEは開発ツールであり、トリガーの動作を直接テストする機能はありません。コードの編集やデバッグなどは可能ですが、組織データを変更せずにトリガーの機能を確認するための適切なツールではありません。さらに、2019年10月12日をもって公式に廃止されたため、現在は使用することができません。",
            "これは不正解です。開発者コンソールの匿名実行機能を使用すると、実際の組織データに対してApexコードを実行することができます。このため、組織データを変更する可能性があります。組織データを変更せずにトリガーの機能を確認するためには、テストクラスを使用するのが最も適切です。"
        ]
    },
    {
        "number": "49",
        "question": "Salesforce AppExchangeからパッケージをインストールおよびアンインストールするには、どの権限が必要ですか。",
        "choices": ["パッケージライセンスの管理", "AppExchange パッケージのアップロード", "AppExchange パッケージのダウンロード", "AppExchange パッケージの作成"],
        "correct": ["AppExchange パッケージのダウンロード"],
        "explanations":["パッケージライセンスの管理", "AppExchange パッケージのアップロード", "AppExchange パッケージのダウンロード", "AppExchange パッケージの作成"],
        "descriptions":[
            "これは不正解です。この権限はインストール済み管理パッケージのライセンスを管理するためのものであり、インストールやアンインストールのプロセスには関連していません。",
            "これは不正解です。この権限は、開発者が自身のパッケージをAppExchangeに公開するためのものです。インストールやアンインストールとは直接関係ありません。AppExchangeでリストを公開するためには「AppExchange パッケージの作成」と「AppExchange パッケージのアップロード」の両方の権限が必要です。",
            "これは正解です。この権限はAppExchangeからパッケージをダウンロードしてSalesforce組織にインストールする際、またアンインストールする際に必要です。ただし、パッケージが正常に動作するためには、そのパッケージのコンポーネントが必要な権限や設定を持っていることを確認する必要がある点も重要です。",
            "これは不正解です。この権限は新しいパッケージをSalesforce内で作成し、それをAppExchangeに公開するためのものです。インストールやアンインストールのプロセスとは直接関係ありません。AppExchangeでリストを公開するためには「AppExchange パッケージの作成」と「AppExchange パッケージのアップロード」の両方の権限が必要です。"
        ]
    },
    {
        "number": "50",
        "question": "マルチテナント環境で開発する際の重要な考慮事項は何ですか。",
        "choices": ["ポリグロットパーシスタンスは、複数のインスタンスの複数の組織におけるグローバルな多言語ユーザーベースをサポートします。", "ガバナ制限により、テナントが同じインスタンスの複数の組織のパフォーマンスに影響を与えるのを防ぎます。", "一意のドメイン名は、複数のインスタンスの複数の組織用に開発されたコードの名前空間の代わりになります。", "組織全体のデータセキュリティは、他のテナントが同じインスタンスの複数の組織のデータを表示できるかどうかを決定します。"],
        "correct": ["ガバナ制限により、テナントが同じインスタンスの複数の組織のパフォーマンスに影響を与えるのを防ぎます。"],
        "explanations":["ポリグロットパーシスタンスは、複数のインスタンスの複数の組織におけるグローバルな多言語ユーザーベースをサポートします。", "ガバナ制限により、テナントが同じインスタンスの複数の組織のパフォーマンスに影響を与えるのを防ぎます。", "一意のドメイン名は、複数のインスタンスの複数の組織用に開発されたコードの名前空間の代わりになります。", "組織全体のデータセキュリティは、他のテナントが同じインスタンスの複数の組織のデータを表示できるかどうかを決定します。"],
        "descriptions":[
            "これは不正解です。Polyglot Persistenceとは、異なるデータストレージ技術を同時に使用することを指します。これにより、データの特性や要件に最適なデータストレージ技術を選択できます。多言語ユーザーベースのサポートとは直接関係ありません。また、”マルチテナント環境で開発する際の重要な考慮事項”としても該当しません。",
            "これは正解です。マルチテナント環境では、複数のテナントが同じインスタンスを共有しています。ガバナ制限は、各テナントがリソースを過度に消費し、他のテナントのパフォーマンスに影響を与えることを防ぐために存在します。",
            "これは不正解です。一意のドメイン名は、特定の組織やインスタンスを識別するためのものであり、コードの名前空間とは直接関係ありません。名前空間は、コード内のクラスや変数などの識別子を区別するためのものです。",
            "これは不正解です。マルチテナント環境では、各テナントのデータは他のテナントから隔離されています。これは、多数の組織が同じインスタンスやリソースを共有しても、互いのデータにアクセスすることができないようにするための基本的なセキュリティ原則です。したがって、組織全体のデータセキュリティ設定が他のテナントのデータアクセスを決定するわけではありません。各テナントのデータは、基本的に他のテナントから独立して保護されています。"
        ]
    },
    {
        "number": "51",
        "question": "Application__cという名前のsObjectは、Position__cという名前の別のsObjectとの参照関係を持っています。Application__cとPosition__cの両方に、Status__cという名前の選択リスト項目があります。\nPosition__cのStatus__c項目が更新されると、Application__cのStatus__c項目に同じ値を自動的に入力し、Application__cでワークフロールールを実行する必要があります。開発者はどのようにこれを達成できますか。",
        "choices": ["Application__c.Status__cを積み上げ集計項目に変更する。", "Application__c.Status__cを数式項目に変更する。", "DML操作でApexトリガーを使用する。", "ワークフローを使用してオブジェクト間項目更新を行う。"],
        "correct": ["DML操作でApexトリガーを使用する。"],
        "explanations":["Application__c.Status__cを積み上げ集計項目に変更する。", "Application__c.Status__cを数式項目に変更する。", "DML操作でApexトリガーを使用する。", "ワークフローを使用してオブジェクト間項目更新を行う。"],
        "descriptions":[
            "これは不正解です。積み上げ集計項目は主従関係にあるオブジェクト間で使用されます。このケースでは参照関係が存在するため、積み上げ集計項目は使用できません。",
            "これは不正解です。数式項目はあるオブジェクトの項目値を計算するために使用されますが、参照関係を介して他のオブジェクトの選択リスト項目を直接反映することはできません。数式項目は参照関係を通して基本的な項目値(数値、日付、テキストなど)にアクセスできますが、選択リストの同期には適していません。",
            "これは正解です。Apexトリガーを使用してPosition__cのStatus__cが変更されたときに関連するApplication__cのStatus__cを更新することができます。また、その変更をトリガーとしてApplication__cでのワークフローを実行することも可能です。",
            "これは不正解です。ワークフローによる項目更新は同一のオブジェクト内または主従関係にあるオブジェクトの項目に対してのみ可能です。参照関係にあるオブジェクト間の項目更新はワークフローだけでは実現できません。"
        ]
    },
    {
        "number": "52",
        "question": "Apexクラスとインターフェースに関して、次のうち正しいステートメントはどれでしょうか。３つ選択してください。",
        "choices": ["クラスはデフォルトでfinalです。", "インターフェースのメソッドはデフォルトでpublicです。", "内部クラスはデフォルトでprivateです。", "最上位クラスは1つの内部クラスレベルのみを持つことができます。"],
        "correct": ["クラスはデフォルトでfinalです。", "内部クラスはデフォルトでprivateです。", "最上位クラスは1つの内部クラスレベルのみを持つことができます。"],
        "explanations":["クラスはデフォルトでfinalです。", "インターフェースのメソッドはデフォルトでpublicです。", "内部クラスはデフォルトでprivateです。", "最上位クラスは1つの内部クラスレベルのみを持つことができます。"],
        "descriptions":[
            "これは正解です。Apexのメソッドおよびクラスはデフォルトでfinalです。これは、メソッドやクラスが上書きされるのを防ぐためのデフォルトの動作です。メソッドまたはクラスを上書きする場合、virtualキーワードを使用して明示的に上書きを許可する必要があります。",
            "これは不正解です。Apexのインターフェース内のメソッドは、アクセス修飾子を指定せずに定義され、自動的にグローバルとなります。したがって、「デフォルトでpublic」という表現は不正確で、「デフォルトでglobal」が正しいです。",
            "これは正解です。Apexでは、内部クラスはデフォルトでprivateとなります。これは、アクセス修飾子を明示的に指定しない限り、内部クラスはそれを含むクラスからしかアクセスできないことを意味します。",
            "これは正解です。Apexでは、内部クラスは一つのレベル深さしか持つことができません。つまり、内部クラス内にさらに内部クラスを定義することはできません。"
        ]
    },
    {
        "number": "53",
        "question": "階層カスタム設定は、Salesforceの各プロファイルの特定のURLを保存します。\n開発者は、どのステートメントを使用して現在のユーザーのプロファイルの正しいURLを取得し、このVisualforceページを表示できますか。",
        "choices": ["{!$Setup.Url_Settings__c.Instance[Profile.Id].URL__c}", "{!$Setup.Url_Settings__c.URL__c}", "{!$Setup.Url_Settings__c.[Profile.Id].URL__c}", "{!$Setup.Url_Settings__c.[$Profile.Id].URL__c}"],
        "correct": ["{!$Setup.Url_Settings__c.URL__c}"],
        "explanations":["{!$Setup.Url_Settings__c.Instance[Profile.Id].URL__c}", "{!$Setup.Url_Settings__c.URL__c}", "{!$Setup.Url_Settings__c.[Profile.Id].URL__c}", "{!$Setup.Url_Settings__c.[$Profile.Id].URL__c}"],
        "descriptions":[
            "これは不正解です。Salesforceの階層型カスタム設定ではInstanceや[Profile.Id]といった構文は使用しません。",
            "これは正解です。階層型カスタム設定をVisualforceページ上で参照する正しい構文は{!$Setup.CustomSettingName__c.FieldName__c}形式です。この場合、Url_Settings__cはカスタム設定のAPI名、URL__cはフィールドのAPI名となります。",
            "これは不正解です。[Profile.Id]は階層型カスタム設定を参照する際の正しい構文ではありません。",
            "これは不正解です。$Profile.Idのような変数にアクセスする正しい文法では[]は使用されません。さらに、$Profileというグローバル変数は存在しないため、この構文を使用しても期待する値を取得することはできません。"
        ]
    },
    {
        "number": "54",
        "question": "APIツールを使用してレコードを挿入するとき、開発者は何を考慮する必要がありますか。2つ選びなさい。",
        "choices": ["ページレイアウトの必須項目が適用されます。", "必須項目の設定が適用されます。", "Apexトリガーは無視されます。", "入力規則が適用されます。"],
        "correct": ["必須項目の設定が適用されます。", "入力規則が適用されます。"],
        "explanations":["ページレイアウトの必須項目が適用されます。", "必須項目の設定が適用されます。", "Apexトリガーは無視されます。", "入力規則が適用されます。"],
        "descriptions":[
            "これは不正解です。APIを使用してレコードを挿入する場合、ページレイアウトの制約は適用されません。ページレイアウトは主にユーザーインターフェース上での表示や入力を制御するものであり、APIを通じてのデータ操作には影響を及ぼしません。",
            "これは正解です。オブジェクトの項目設定で「必須」に設定されているフィールドは、APIを使用したデータ操作でもその制約が適用されます。そのため、そのフィールドに値が入力されていない場合、レコードの挿入や更新は失敗します。",
            "これは不正解です。APIを通じてレコードを挿入または更新する場合、関連するApexトリガーも実行されます。これはデータの整合性を保つための重要な動作であり、トリガー内で定義されたロジックや検証がAPIを通じた操作にも適用されることを意味します。",
            "これは正解です。入力規則は、レコードが保存される前に特定の条件を満たしているかを検証するためのものです。APIを通じてもこれらの規則は適用され、規則の条件を満たさない場合はレコードの挿入や更新が失敗します。"
        ]
    },
    {
        "number": "55",
        "question": "Visualforceページで取引先責任者の標準コントローラを使用しています。親取引先レコードの名前をページに表示するにはどうすればよいですか。",
        "choices": ["コントローラ内で追加のApexロジックを使用して、名前項目を検索する。", "{!contact.account.name}の差し込み項目を使用する。", "取引先の標準コントローラを追加する。", "SOQLを使用して、関連する取引先名の項目をクエリする。"],
        "correct": ["{!contact.account.name}の差し込み項目を使用する。"],
        "explanations":["コントローラ内で追加のApexロジックを使用して、名前項目を検索する。", "{!contact.account.name}の差し込み項目を使用する。", "取引先の標準コントローラを追加する。", "SOQLを使用して、関連する取引先名の項目をクエリする。"],
        "descriptions":[
            "これは不正解です。取引先責任者(Contact)の標準コントローラを使用している場合、関連する取引先(Account)のフィールドには、既にVisualforceページから直接アクセスできます。追加のApexロジックを書く必要はありません。",
            "これは正解です。Visualforceページでは、差し込み項目を使用して関連オブジェクトのフィールドにアクセスできます。この場合、{!contact.account.name}は、関連する取引先(Account)の名前に直接アクセスするための正しい方法です。",
            "これは不正解です。取引先責任者(Contact)のレコードには、関連する取引先(Account)への参照が既に含まれており、その情報にアクセスすることができます。",
            "これは不正解です。Visualforceページ内で直接SOQLクエリを使用することはできません。また、標準コントローラを使用している場合、SOQLクエリを書く必要はありません。親オブジェクトのフィールドには差し込み項目を使用してアクセスすることが推奨されます。"
        ]
    },
    {
        "number": "56",
        "question": "Apex単体テストの適切なプロセスは何ですか。",
        "choices": ["SeeAllData=trueを使用してテストデータをクエリします。テストするメソッドを呼び出します。結果が正しいことを確認します。", "テスト用のデータを作成します。runAllTests()を実行します。結果が正しいことを確認します。", "テスト用のデータを作成します。テストするメソッドを呼び出します。結果が正しいことを確認します。", "SeeAllData=trueを使用してテストデータをクエリします。runAllTests()を実行します。結果が正しいことを確認します。"],
        "correct": ["テスト用のデータを作成します。テストするメソッドを呼び出します。結果が正しいことを確認します。"],
        "explanations":["SeeAllData=trueを使用してテストデータをクエリします。テストするメソッドを呼び出します。結果が正しいことを確認します。", "テスト用のデータを作成します。runAllTests()を実行します。結果が正しいことを確認します。", "テスト用のデータを作成します。テストするメソッドを呼び出します。結果が正しいことを確認します。", "SeeAllData=trueを使用してテストデータをクエリします。runAllTests()を実行します。結果が正しいことを確認します。"],
        "descriptions":[
            "これは不正解です。SeeAllData=trueを使用すると、テスト実行中に実際の組織データにアクセスすることができます。しかし、これは一般的なベストプラクティスではありません。テストは独立しており、実データに依存しない形で行うべきです。",
            "これは不正解です。SalesforceにrunAllTests()というメソッドは存在しません。一方、Salesforceの開発者コンソールのテストタブには「Run All (すべて実行)」というオプションがあり、これを利用することで保存されているすべてのテストメソッドを実行することが可能です。",
            "これは正解です。単体テストのベストプラクティスは、テスト内でテストデータを作成し、それを使用してメソッドをテストし、結果を確認することです。この選択肢はそのプロセスを正確に反映しています。",
            "これは不正解です。SalesforceにrunAllTests()というメソッドは存在しない上、通常SeeAllData=trueの使用は避けるべきです。"
        ]
    },
    {
        "number": "57",
        "question": "サンドボックス内のLightningWebコンポーネントのバグを修正するには、開発者は何を使用する必要がありますか。",
        "choices": ["VSCode", "匿名実行", "開発者コンソール", "Force.com IDE"],
        "correct": ["VSCode"],
        "explanations":["VSCode", "匿名実行", "開発者コンソール", "Force.com IDE"],
        "descriptions":[
            "これは正解です。Lightning Web コンポーネント (LWC) の開発やデバッグには、Salesforce Extension Pack という拡張機能が提供されており、VSCode上でこれを使用することでLWCのコーディングやデバッグが可能です。VSCodeは、Salesforceの公式推奨のIDEとして、LWCの開発やデバッグに広く使われています。",
            "これは不正解です。匿名実行は、一時的なApexコードの実行を行うツールです。LWCの開発やデバッグには使用されません。",
            "これは不正解です。開発者コンソールは、Apexコードの開発やデバッグ、SOQLの実行などを行うためのツールですが、LWCの開発には最適ではありません。VSCodeなどのより専門的なIDEの使用が推奨されています。",
            "これは不正解です。Force.com IDEは以前にSalesforce開発のためのEclipseベースのIDEとして提供されていましたが、現在は非推奨となっています。LWCの開発に関しても、公式にはVSCodeの使用が推奨されています。"
        ]
    },
    {
        "number": "58",
        "question": "Universal Containers社は、取引先オブジェクトのプライベート共有モデルを実装しました。Apexでカスタム取引先検索ツールを開発し、営業担当者が指定した複数の条件に一致する取引先を検索できるようにしました。リリース以来、このツールのユーザーは、自分が所有していない取引先を見ることができると報告しています。開発者は、カスタム検索ツールを使用している間、現在ログインしているユーザーに対して共有権限を強制するために何を使用する必要がありますか。",
        "choices": ["Schemaクラスのメソッドを使用して、ログインしているユーザーが取引先オブジェクトへのアクセス権を持っているかどうかを判断します。", "UserInfoクラスを使用して、ログインしているユーザーが所有するレコードを返すようにすべてのSOQLクエリを絞り込みます。", "クラス宣言でwith sharingキーワードを使用します。", "クラス宣言でwithout sharingキーワードを使用します。"],
        "correct": ["クラス宣言でwith sharingキーワードを使用します。"],
        "explanations":["Schemaクラスのメソッドを使用して、ログインしているユーザーが取引先オブジェクトへのアクセス権を持っているかどうかを判断します。", "UserInfoクラスを使用して、ログインしているユーザーが所有するレコードを返すようにすべてのSOQLクエリを絞り込みます。", "クラス宣言でwith sharingキーワードを使用します。", "クラス宣言でwithout sharingキーワードを使用します。"],
        "descriptions":[
            "これは不正解です。Schemaクラスはメタデータ情報にアクセスするために使用されますが、実行時の共有ルールやユーザーのアクセス権を動的に判断するためには適していません。ユーザーが特定のレコードに対して持つアクセス権を判断するための直接的な手段を提供しません。",
            "これは不正解です。UserInfoクラスは現在のユーザーの情報を取得するためのものであり、これを使用してレコードの所有者を特定するのに使用することはできます。しかし、これだけで取引先オブジェクトへのアクセス権を強制することはできません。",
            "これは正解です。”with sharing”キーワードをApexクラス宣言に使用すると、そのクラス内でのデータアクセスは現在のユーザーの共有設定に従います。これにより、ユーザーがアクセスできないレコードを取得・編集することはできなくなります。",
            "これは不正解です。”without sharing”キーワードを使用すると、そのクラスは共有設定を無視してデータにアクセスします。このキーワードを使用すると、現在のユーザーの共有設定に関係なくレコードにアクセスできるため、この問題の状況では不適切です。"
        ]
    },
    {
        "number": "59",
        "question": "開発者は、販売活動中にユーザーが商品固有の情報を入力できるVisualforceページを提供する必要があります。どうすればこれを達成できますか。2つ選びなさい。",
        "choices": ["新しいVisualforceページとApexコントローラを作成して、商品データ入力を提供します。", "標準ページをコピーし、商品データ入力用の新しいVisualforceページを作成します。", "変更するカスタムVisualforceページを提供するAppExchangeから管理パッケージをダウンロードします。", "変更するカスタムVisualforceページを提供するAppExchangeから未管理パッケージをダウンロードします。"],
        "correct": ["新しいVisualforceページとApexコントローラを作成して、商品データ入力を提供します。", "変更するカスタムVisualforceページを提供するAppExchangeから未管理パッケージをダウンロードします。"],
        "explanations":["新しいVisualforceページとApexコントローラを作成して、商品データ入力を提供します。", "標準ページをコピーし、商品データ入力用の新しいVisualforceページを作成します。", "変更するカスタムVisualforceページを提供するAppExchangeから管理パッケージをダウンロードします。", "変更するカスタムVisualforceページを提供するAppExchangeから未管理パッケージをダウンロードします。"],
        "descriptions":[
            "これは正解です。Visualforceページを使用してカスタムのユーザーインターフェースを作成し、Apexコントローラを使用してデータのロジックを処理することができます。この方法を使用すると、開発者は完全にカスタマイズされたデータ入力ページを提供できます。",
            "これは不正解です。Salesforceの標準ページを直接「コピー」することはできません。新しいVisualforceページを作成する場合は、ゼロからページを作成するか、既存のページを参考にしながら作成する必要があります。",
            "これは不正解です。管理パッケージは、パッケージのコンテンツを変更することができません。したがって、管理パッケージのVisualforceページをカスタマイズすることはできません。そのため、この方法は商品固有の情報の入力ページを提供するための適切な選択ではありません。",
            "これは正解です。未管理パッケージのコンテンツは変更可能です。したがって、AppExchangeから適切な未管理パッケージをダウンロードした後、Visualforceページをカスタマイズして商品固有の情報の入力ページを提供することができます。"
        ]
    },
    {
        "number": "60",
        "question": "複数の通貨を有効にしている組織では、開発者は、CampaignオブジェクトでTotal_estimated_value__cと呼ばれる積み上げ集計項目を使用して、CampaignMemberオブジェクトからEstimated_value__c通貨項目の合計を集計する必要があります。Total_estimated_value__c積み上げ集計項目の通貨はどのように決定されますか。",
        "choices": ["Campaignmember.Estimated_value__cの値は、Campaignオブジェクトのレコードの通貨に変換され、合計はCampaignオブジェクトのレコードの通貨を使用して表示されます。", "CampaignMember.Estimated_value__cの値は、CampaignMemberレコードの大半で通貨に変換され、その通貨を使用して合計が表示されます。", "CampaignMember.Estimated_value__cの値が合計され、結果のTotal_estimated_value__cフィールドがCampaignオブジェクトのレコードの数値項目として表示されます。", "CampaignMember.Estimated_value__cの値は現在のユーザーの通貨に変換され、合計はCampaignオブジェクトのレコードの通貨を使用して表示されます。"],
        "correct": ["Campaignmember.Estimated_value__cの値は、Campaignオブジェクトのレコードの通貨に変換され、合計はCampaignオブジェクトのレコードの通貨を使用して表示されます。"],
        "explanations":["Campaignmember.Estimated_value__cの値は、Campaignオブジェクトのレコードの通貨に変換され、合計はCampaignオブジェクトのレコードの通貨を使用して表示されます。", "CampaignMember.Estimated_value__cの値は、CampaignMemberレコードの大半で通貨に変換され、その通貨を使用して合計が表示されます。", "CampaignMember.Estimated_value__cの値が合計され、結果のTotal_estimated_value__cフィールドがCampaignオブジェクトのレコードの数値項目として表示されます。", "CampaignMember.Estimated_value__cの値は現在のユーザーの通貨に変換され、合計はCampaignオブジェクトのレコードの通貨を使用して表示されます。"],
        "descriptions":[
            "これは正解です。複数の通貨を有効にしている組織では、積み上げ集計項目の通貨は、親レコード(この場合はCampaignオブジェクト)の通貨に基づいています。したがって、CampaignMemberのEstimated_value__cフィールドの値は、Campaignオブジェクトのレコードレコードの通貨に変換されて合計されます。",
            "これは不正解です。Salesforceの複数通貨機能では、積み上げ集計項目の通貨は親レコードの通貨に基づいています。CampaignMemberレコードの大半の通貨に基づくわけではありません。",
            "これは不正解です。この選択肢は通貨の変換について触れていません。複数の通貨を有効にしている場合、通貨の変換は必須です。",
            "これは不正解です。積み上げ集計項目の通貨は親レコードの通貨に基づいており、現在のユーザーの通貨には基づいていません。"
        ]
    },
    {
        "number": "61",
        "question": "開発者は、顧客の請求書を追跡するカスタムオブジェクトを作成したいと考えています。\n取引先にアクセスできるすべてのユーザーにすべての請求書が表示されるようにするには、請求書と取引先をどのように関連付ける必要がありますか。",
        "choices": ["取引先は、請求書に対する参照関係が必要です。", "請求書は、取引先に対する主従関係が必要です。", "取引先は、請求書に対する主従関係が必要です。", "請求書は、取引先に対する参照関係が必要です。"],
        "correct": ["請求書は、取引先に対する主従関係が必要です。"],
        "explanations":["取引先は、請求書に対する参照関係が必要です。", "請求書は、取引先に対する主従関係が必要です。", "取引先は、請求書に対する主従関係が必要です。", "請求書は、取引先に対する参照関係が必要です。"],
        "descriptions":[
            "これは不正解です。参照関係では、取引先の詳細ページに関連する請求書のリストが表示されますが、取引先の共有設定に基づいて請求書が自動的に表示されるわけではありません。",
            "これは正解です。主従関係では、子オブジェクト(請求書)の表示設定は親オブジェクト(取引先)に依存します。したがって、取引先の詳細ページにアクセスするユーザーには、関連する請求書も自動的に表示されます。",
            "これは不正解です。この設定において、請求書が親オブジェクトとなり取引先が子オブジェクトとなることを意味します。しかし、通常のビジネスプロセスでは、一つの取引先が複数の請求書を持つことが一般的なので、このような設定は一般的なユースケースには適合しないと考えられます。",
            "これは不正解です。参照関係では、取引先の詳細ページに関連する請求書のリストが表示されますが、取引先の共有設定に基づいて請求書が自動的に表示されるわけではありません。"
        ]
    },
    {
        "number": "62",
        "question": "レビュアーは、候補者の採用が推奨されている場合にのみ、コメント項目に理由を入力する必要があります。 開発者はこの要件を実施するためにどのアクションを実行できますか。",
        "choices": ["必須のコメント項目を作成します。", "数式項目を作成します。", "入力規則を作成します。", "必要なVisualforceコンポーネントを作成します。"],
        "correct": ["入力規則を作成します。"],
        "explanations":["必須のコメント項目を作成します。", "数式項目を作成します。", "入力規則を作成します。", "必要なVisualforceコンポーネントを作成します。"],
        "descriptions":[
            "これは不正解です。これは常にコメント項目の入力を必須とするだけで、特定の条件(採用が推奨されている場合)下でのみ入力を必須とするロジックを提供しません。",
            "これは不正解です。数式項目は、他のフィールドの値に基づいて計算される値を表示するためのものであり、入力の制御や検証のためのものではありません。",
            "これは正解です。入力規則は、特定の条件下でのみフィールドの入力を必須とするロジックを実装するための最適な方法です。この場合、採用が推奨されているときにのみコメント項目が入力されているかどうかを検証する入力規則を作成することができます。",
            "これは不正解です。VisualforceはカスタムUIを作成するためのものであり、このシンプルな要件を実現するためには過度です。入力規則を使用することで、標準のUIを使用しながらも要件を満たすことができます。"
        ]
    },
    {
        "number": "63",
        "question": "開発者がTest.startTest()およびTest.stopTest()を使用する理由は次のうちどれですか。",
        "choices": ["この２つの行間のコードのApexコードカバレッジ要件を回避するため", "匿名Apexコードの実行時に匿名ブロックの実行を開始および停止するため", "テストコードを指定して、Apexの行数ガバナ制限に影響を与えないようにするため", "単一のテストクラスの実行中にガバナ制限の追加セットを作成するため"],
        "correct": ["単一のテストクラスの実行中にガバナ制限の追加セットを作成するため"],
        "explanations":["この２つの行間のコードのApexコードカバレッジ要件を回避するため", "匿名Apexコードの実行時に匿名ブロックの実行を開始および停止するため", "テストコードを指定して、Apexの行数ガバナ制限に影響を与えないようにするため", "単一のテストクラスの実行中にガバナ制限の追加セットを作成するため"],
        "descriptions":[
            "これは不正解です。Test.startTest()およびTest.stopTest()はコードカバレッジ要件を回避するためのものではありません。これらはガバナ制限をリセットするためや非同期プロセスを即座に実行するために使用されます。",
            "これは不正解です。匿名Apexの実行に関して、Test.startTest()およびTest.stopTest()は特に役立つわけではありません。これらのメソッドはテストメソッド内で使用され、主にガバナ制限のリセットや非同期プロセスの即座の実行に使用されます。",
            "これは不正解です。Test.startTest()とTest.stopTest()の間に記述されたコードは、ガバナ制限のリセットの恩恵を受けることができますが、それは「行数」ガバナ制限とは異なるものです。",
            "これは正解です。Test.startTest()を呼び出した後、ガバナ制限がリセットされ、Test.stopTest()までの間に実行されるコードは、この新しいセットのガバナ制限に基づいて動作します。これにより、テスト内で行われる前の設定や後の検証でのガバナ制限の消費を防ぐことができます。"
        ]
    },
    {
        "number": "64",
        "question": "標準の商談ビューボタンを上書きするには、Visulforceページのコントローラで何を使用する必要がありますか。",
        "choices": ["ページネーション用の関連リストをサポートするStandardSetController", "StandardControllerを参照するコールバックコンストラクタ", "商談オブジェクトの変数を初期化するコンストラクタ", "あらかじめ組み込まれた機能の商談オブジェクトのStandardController"],
        "correct": ["あらかじめ組み込まれた機能の商談オブジェクトのStandardController"],
        "explanations":["ページネーション用の関連リストをサポートするStandardSetController", "StandardControllerを参照するコールバックコンストラクタ", "商談オブジェクトの変数を初期化するコンストラクタ", "あらかじめ組み込まれた機能の商談オブジェクトのStandardController"],
        "descriptions":[
            "これは不正解です。StandardSetControllerは、関連リストや一覧ビューのページネーションをサポートするためのものですが、標準の商談ビューボタンを上書きするためのものではありません。",
            "これは不正解です。コールバックコンストラクタは、StandardControllerを拡張するカスタムコントローラの中で使用されることがありますが、標準のビューボタンを上書きするためには直接必要ではありません。",
            "これは不正解です。商談の変数を初期化するコンストラクタは、カスタムロジックやビジネスロジックの実装に必要かもしれませんが、標準のビューボタンを上書きするために必須ではありません。",
            "これは正解です。Visualforceページが標準のビューを上書きする場合、そのページのコントローラは標準のオブジェクト(この場合は商談)のStandardControllerを使用することで、標準の機能を利用できます。"
        ]
    },
    {
        "number": "65",
        "question": "開発者が、プライベートメソッドを含む Apex クラスを作成しました。プライベートメソッドがテストクラスからアクセスできるようにするために、開発者は何をすればよいでしょうか。",
        "choices": ["TestVisible属性をApexクラスに追加する", "SeeAllData属性をテストメソッドに追加する", "SeeAllData属性をテストクラスに追加する", "TestVisible属性をApexメソッドに追加する"],
        "correct": ["TestVisible属性をApexメソッドに追加する"],
        "explanations":["TestVisible属性をApexクラスに追加する", "SeeAllData属性をテストメソッドに追加する", "SeeAllData属性をテストクラスに追加する", "TestVisible属性をApexメソッドに追加する"],
        "descriptions":[
            "これは不正解です。@TestVisible アノテーションは、特定のメソッドや変数に適用されるものであり、全体のクラスに適用するものではありません。",
            "これは不正解です。@SeeAllData アノテーションは、テストメソッドが実際のデータにアクセスするかどうかを制御するためのものであり、プライベートメソッドへのアクセスとは関係ありません。",
            "これは不正解です。@SeeAllData アノテーションは、テストクラスが実際のデータにアクセスするかどうかを制御するためのものであり、プライベートメソッドへのアクセスとは関係ありません。",
            "これは正解です。@TestVisible アノテーションをプライベートメソッドに適用することで、そのメソッドはテストメソッドからアクセス可能となります。"
        ]
    },
    {
        "number": "66",
        "question": "カスタムボタンとカスタムリンクでサポートされるコンテンツソースは何ですか。2つ選びなさい。",
        "choices": ["VisualForceページ", "静的リソース", "URL", "Chatterファイル", "Lightningページ"],
        "correct": ["VisualForceページ", "URL"],
        "explanations":["VisualForceページ", "静的リソース", "URL", "Chatterファイル", "Lightningページ"],
        "descriptions":[
            "これは正解です。カスタムボタンやカスタムリンクは、特定のVisualForceページにユーザーをリダイレクトするために設定することができます。",
            "これは不正解です。静的リソースは主に画像、JavaScript、CSSなどのファイルを保存するためのものであり、直接カスタムボタンやリンクのコンテンツソースとして使用することはできません。",
            "これは正解です。カスタムボタンやカスタムリンクは、特定のURLにユーザーをリダイレクトするために設定することができます。",
            "これは不正解です。Chatterファイルは、Chatterの投稿やコメントに添付されるファイルを指します。これはカスタムボタンやリンクのコンテンツソースとして直接使用することはできません。",
            "これは不正解です。ライトニングページは、Lightning ExperienceやSalesforceモバイルアプリでのカスタムページを作成するためのものです。しかし、カスタムボタンやリンクのコンテンツソースとして直接指定することはできません。"
        ]
    },
    {
        "number": "67",
        "question": "開発者は、ケースオブジェクトで使用可能なすべてのレコードタイプを表示したいと考えています。開発者は、ケースオブジェクトの状況項目の選択リスト値も表示したいと考えています。 ケースオブジェクトとケースオブジェクトの状況項目は、カスタムVisualforceページにあります。コントローラでレコードタイプと選択リスト値を取得するために、開発者はどのアクションを実行できますか。 ２つ選択してください。",
        "choices": ["Case.Status.getDescribe().getPicklistValues()によって返されるSchema.PicklistEntryを使用する。", "Case.SObjectType.getDescribe().getRecordTypeInfos()によって返されるSchema.RecordTypeInfoを使用する。", "SOQLを使用して組織内のケースレコードをクエリし、ケースオブジェクトで使用可能なすべてのRecordType値を取得する。", "SOQLを使用して組織内のケースレコードをクエリし、状況項目のすべての値を取得する。"],
        "correct": ["Case.Status.getDescribe().getPicklistValues()によって返されるSchema.PicklistEntryを使用する。", "Case.SObjectType.getDescribe().getRecordTypeInfos()によって返されるSchema.RecordTypeInfoを使用する。"],
        "explanations":["Case.Status.getDescribe().getPicklistValues()によって返されるSchema.PicklistEntryを使用する。", "Case.SObjectType.getDescribe().getRecordTypeInfos()によって返されるSchema.RecordTypeInfoを使用する。", "SOQLを使用して組織内のケースレコードをクエリし、ケースオブジェクトで使用可能なすべてのRecordType値を取得する。", "SOQLを使用して組織内のケースレコードをクエリし、状況項目のすべての値を取得する。"],
        "descriptions":[
            "これは正解です。このメソッドはCaseオブジェクトのStatusフィールドの選択リスト値を取得するための正しい方法です。getDescribe().getPicklistValues()は、指定された選択リストフィールドのすべての選択リスト値を取得するために使用されます。",
            "これは正解です。このメソッドはCaseオブジェクトで利用可能なすべてのレコードタイプ情報を取得するための正しい方法です。getDescribe().getRecordTypeInfos()は、指定されたオブジェクトのレコードタイプ情報を取得するために使用されます。",
            "これは不正解です。この方法も実際にはケースオブジェクトのレコードタイプ情報を取得するために使用できますが、getDescribe().getRecordTypeInfos()を使用する方法の方が効率的であるため、この選択肢は最適ではありません。またSOQLのガバナ制限に引っかかるリスクも低いです。",
            "これは不正解です。この方法は状況項目の選択リスト値を取得するための効果的な方法ではありません。具体的なレコードから状況の値をクエリすると、そのレコードに存在する選択リスト値のみが返されます。すべての選択リスト値を取得するためには、getDescribe().getPicklistValues()のようなメソッドを使用する必要があります。"
        ]
    },
    {
        "number": "68",
        "question": "変数のスコープについての正確な記述はどれですか。3つ選びなさい。",
        "choices": ["子ブロックは親ブロックの変数名を再利用できません。", "ブロック内の任意のポイントで変数を定義できます。", "並列ブロックは同じ変数名を使用できます。", "変数の値がnullの場合、子ブロックは親ブロックの変数名を再利用できます。", "変数の値がnullの場合、静的変数はスコープを現在のブロックに制限できます。"],
        "correct": ["子ブロックは親ブロックの変数名を再利用できません。", "ブロック内の任意のポイントで変数を定義できます。", "並列ブロックは同じ変数名を使用できます。"],
        "explanations":["子ブロックは親ブロックの変数名を再利用できません。", "ブロック内の任意のポイントで変数を定義できます。", "並列ブロックは同じ変数名を使用できます。", "変数の値がnullの場合、子ブロックは親ブロックの変数名を再利用できます。", "変数の値がnullの場合、静的変数はスコープを現在のブロックに制限できます。"],
        "descriptions":[
            "これは正解です。Apexでは、同じメソッドやクラス内で既に宣言されている変数名を再宣言することはできません。子ブロックで同じ名前を持つ新しい変数を宣言しようとすると、コンパイルエラーになります。",
            "これは正解です。Apexでは、ブロック内の任意の位置で変数を定義することができます。ただし、変数は定義されたポイントからブロックの終わりまでの間のみ有効です。",
            "これは正解です。互いに独立したブロック(例えば異なるメソッド内や、異なるループ内など)は、同じ名前の変数をそれぞれで使用できます。これらの変数はスコープが異なるため、互いに影響しません。",
            "これは不正解です。変数の値が何であれ、変数名のスコープは変数の値に依存しません。null値であっても、親ブロックで宣言された変数名は子ブロックで再宣言できません。",
            "これは不正解です。静的変数のスコープはその変数が宣言されたクラス全体に及びます。変数の値が何であれ、スコープをメソッドやブロックに制限することはできません。"
        ]
    },
    {
        "number": "69",
        "question": "建設会社の運用管理者は、機械と呼ばれるカスタムオブジェクトを使用して、クレーンやその他の機械の使用と保守を管理します。管理者は、機械をさまざまな建設作業に割り当て、各作業に関連する日付とコストを追跡できるようにしたいと考えています。1つの建設作業に複数の機械を割り当てることも可能です。これらの要件を満たすために開発者は何をすべきですか。",
        "choices": ["建設作業オブジェクトに機械オブジェクトへの参照関係を作成する。", "機械オブジェクトに建設作業オブジェクトへの参照関係を作成する。", "機械オブジェクトと建設作業オブジェクトの両方に主従関係を持つ連結オブジェクトを作成する。", "機械オブジェクトに、建設作業オブジェクトへの主従関係を作成する。"],
        "correct": ["機械オブジェクトと建設作業オブジェクトの両方に主従関係を持つ連結オブジェクトを作成する。"],
        "explanations":["建設作業オブジェクトに機械オブジェクトへの参照関係を作成する。", "機械オブジェクトに建設作業オブジェクトへの参照関係を作成する。", "機械オブジェクトと建設作業オブジェクトの両方に主従関係を持つ連結オブジェクトを作成する。", "機械オブジェクトに、建設作業オブジェクトへの主従関係を作成する。"],
        "descriptions":[
            "これは不正解です。このアプローチでは、一対多の関係しか表現できないため、一つの建設作業に複数の機械を関連付ける多対多の要件には適していません。この設定では、各建設作業に一台の機械のみを関連付けることになります。",
            "これは不正解です。こちらも先ほどと同様に、一対多の関係を構築するため、問題の要件である「一つの機械を複数の建設作業に関連付ける」ことはできません。結果として、各機械が一つの建設作業にしか割り当てられない状況になります。",
            "これは正解です。連結オブジェクトを用いることで、機械と建設作業の間に多対多の関係を確立できます。連結オブジェクトは2つの主従関係を持ち、一つの建設作業に複数の機械を割り当てることも、一つの機械を複数の建設作業に割り当てることも可能にします。この方法は柔軟性が高く、要件を正確に満たすことができます。",
            "これは不正解です。このアプローチは一対多の関係を作成するため、問題の要件には合いません。主従関係は、子オブジェクト(この場合は機械)が親オブジェクト(建設作業)に密接に結び付けられる場合に使用されますが、一つの機械を複数の建設作業に割り当てることはできません。"
        ]
    },
    {
        "number": "70",
        "question": "クイックアクションでレコードを作成する際、フィード項目を投稿する最も簡単な方法は何ですか。",
        "choices": ["クイックアクションでフィード項目の作成を選択する。", "新しいレコードでケースフィードの作成を選択する。", "新しいレコードにワークフロールールを追加する。", "新しいレコードにトリガーを追加する。"],
        "correct": ["クイックアクションでフィード項目の作成を選択する。"],
        "explanations":["クイックアクションでフィード項目の作成を選択する。", "新しいレコードでケースフィードの作成を選択する。", "新しいレコードにワークフロールールを追加する。", "新しいレコードにトリガーを追加する。"],
        "descriptions":[
            "これは正解です。クイックアクションを定義する際に「フィード項目を作成」オプションを有効にすると、レコードが作成されると同時に関連するフィードが自動的に更新されます。これはユーザーに追加の操作を要求せずに、情報共有を容易にします。",
            "これは不正解です。「ケースフィードの作成」は、特定のシナリオ、つまりケースオブジェクトに関連するアクションに限られています。一般的なレコード作成時には適切な選択肢ではありません。",
            "これは不正解です。ワークフロールールは条件に基づいて特定のアクションを自動化しますが、単純なレコード作成時にフィード項目を生成する直接的な方法ではありません。ワークフロールールはフィードの更新を自動化するより複雑なプロセスに適しています。",
            "これは不正解です。トリガーはApexコードを使用してデータベースレベルのイベントに対応するカスタムロジックを実装するためのものです。一般的なフィード項目の投稿は、クイックアクションによるシンプルな操作で実現できるため、トリガーを使用するのは過度に複雑です。"
        ]
    },
    {
        "number": "71",
        "question": "ある会社には、Warehouseという名前のカスタムオブジェクトがあります。各Warehouseレコードには個別のレコード所有者がおり、Salesforceの親Accountに関連付けられています。開発者は、AccountとWarehouseを関連付けるために、どのような関係を使用しますか。",
        "choices": ["1対多", "参照", "主従", "親子"],
        "correct": ["参照"],
        "explanations":["1対多", "参照", "主従", "親子"],
        "descriptions":[
            "これは不正解です。一対多は関係のタイプを示す一般的な用語ですが、Salesforceの具体的な関係タイプを指すものではありません。",
            "これは正解です。参照関係は、2つのオブジェクト間にリンクを作成しますが、親のレコードが削除された場合、子のレコードは削除されません。また、参照関係では、子のレコードは独自の所有者を持つことができます。このケースでは、各Warehouseレコードには独自の所有者がいるため、参照関係が適切です。",
            "これは不正解です。主従関係では、子のレコードは所有者フィールドを持たず、親レコードと同じ所有者を共有します。また、親のレコードが削除されると、子のレコードも自動的に削除されます。このケースでは、各Warehouseレコードには独自の所有者がいるため、主従関係は適切ではありません。",
            "これは不正解です。親子は一般的な関係のタイプを示す用語ですが、Salesforceの具体的な関係タイプを指すものではありません。"
        ]
    },
    {
        "number": "72",
        "question": "開発者が、映画、俳優、契約を追跡するスキーマを作成することになりました。1つの映画は多くの契約を持つことができ、1人の俳優は多くの契約を持つことができます。各契約は、1 人のユーザーによって所有され、アクティブに管理されます。映画や俳優のレコードにアクセスすることなく、ユーザーが所有する契約を簡単に管理できるようにするには、どのスキーマを作成する必要がありますか。",
        "choices": ["映画オブジェクトへの主従関係と俳優オブジェクトへの参照関係", "映画オブジェクトへの参照関係と俳優オブジェクトへの主従関係", "映画オブジェクトへの主従関係と俳優オブジェクトへの主従関係", "映画オブジェクトへの参照関係と俳優オブジェクトへの参照関係"],
        "correct": ["映画オブジェクトへの参照関係と俳優オブジェクトへの参照関係"],
        "explanations":["開発者が、映画、俳優、契約を追跡するスキーマを作成することになりました。1つの映画は多くの契約を持つことができ、1人の俳優は多くの契約を持つことができます。各契約は、1 人のユーザーによって所有され、アクティブに管理されます。映画や俳優のレコードにアクセスすることなく、ユーザーが所有する契約を簡単に管理できるようにするには、どのスキーマを作成する必要がありますか。"],
        "descriptions":[
            "これは不正解です。主従関係を映画オブジェクトに設定すると、契約は映画に依存する子レコードになります。これは、映画が削除された場合、すべての関連する契約も削除されることを意味します。また、契約は俳優オブジェクトに対して参照関係を持つため、独自の所有者を持つことができますが、契約が映画と俳優の両方に関連しているため、この設定では要件を満たしていません。",
            "これは不正解です。俳優オブジェクトへの主従関係を設定すると、契約は俳優に依存する子レコードになります。これは俳優が削除された場合、その俳優に関連するすべての契約が削除されることを意味します。また、映画に対する参照関係は設定可能ですが、契約が映画と俳優の両方に関連している必要があるため、このスキーマは要件を満たしていません。",
            "これは不正解です。契約が映画と俳優の両方に依存する子レコードになる場合、Salesforceでは1つの子レコードが2つの主従関係を持つことはできません。したがって、このスキーマは実装不可能です。",
            "これは正解です。参照関係は、1つのレコードが別のレコードに関連していることを示しますが、依存関係はありません。つまり、映画や俳優が削除されても、契約レコードは影響を受けません。各契約は独自の所有者を持ち、映画や俳優レコードにアクセスせずに管理することができます。このスキーマは、問題で説明されている要件を満たしています。"
        ]
    },
    {
        "number": "73",
        "question": "以下のコードでは、Booleanはどのタイプから継承しますか。",
        "following-code": [
            "Boolean b = true;"
        ],
        "choices": ["Enum", "Object", "String", "Class"],
        "correct": ["Object"],
        "explanations":["Enum", "Object", "String", "Class"],
        "descriptions":[
            "これは不正解です。Booleanは列挙型(Enum)から継承されるものではありません。Enumは異なる固定値のセットを定義するためのものであり、Booleanはtrueまたはfalseの値のみを持つことができます。",
            "これは正解です。Salesforce Apexにおいて、すべてのデータ型はObjectクラスから継承されます。したがって、BooleanもObjectクラスから継承されることになります。",
            "これは不正解です。Booleanは文字列(String)から継承されるものではありません。Stringは文字のシーケンスを表すものであり、Booleanはtrueまたはfalseの値のみを持つことができます。",
            "これは不正解です。BooleanはClassという特定のクラスから継承されるものではありません。Classは一般的なクラス定義を指すものであり、Booleanは具体的なデータ型です。"
        ]
    },
    {
        "number": "74",
        "question": "Visualforceページには、親オブジェクトへの参照関係を持つオブジェクトの標準コントローラがあります。開発者が親レコードのデータをページに表示するにはどうすればよいですか。",
        "choices": ["VisualforceページでSOQLを使用して、親レコードのデータを取得する。", "差し込み項目の構文を使用して、親レコードからデータを取得する。", "親レコード用のページに2つ目の標準コントローラを追加する。", "子レコードの積み上げ集計項目を使用して、親レコードのデータを含める。"],
        "correct": ["差し込み項目の構文を使用して、親レコードからデータを取得する。"],
        "explanations":["VisualforceページでSOQLを使用して、親レコードのデータを取得する。", "差し込み項目の構文を使用して、親レコードからデータを取得する。", "親レコード用のページに2つ目の標準コントローラを追加する。", "子レコードの積み上げ集計項目を使用して、親レコードのデータを含める。"],
        "descriptions":[
            "これは不正解です。Visualforceページ内でSOQLを直接使用することは通常できません。ApexコントローラまたはApex拡張を通じてSOQLクエリを実行することは可能ですが、標準コントローラが提供する機能を使用する場合はこの方法は必要ありません。",
            "これは正解です。Visualforceでは差し込み項目の構文({!relationshipName.fieldName})を使用して、標準コントローラ経由で親オブジェクトのフィールドにアクセスできます。これが最も簡単で直接的な方法です。",
            "これは不正解です。Visualforceページには1つの標準コントローラしか関連付けることができません。親レコードに対しては、既に述べた差し込み項目の構文を使用します。",
            "これは不正解です。積み上げ集計項目は、子レコードから計算された結果を親レコードに表示するために使用します。これは親レコードの既存のデータを表示するためのメカニズムではありません。"
        ]
    },
    {
        "number": "75",
        "previous-code": [
            "try {",
            "    List<String> nameList;",
            "    Account a;",
            "    String s = a.Name;",
            "    nameList.add(s);",
            "} catch (ListException le) {",
            "    System.debug('List Exception');",
            "} catch (NullPointerException npe) {",
            "    System.debug('NullPointer Exception');",
            "} catch (Exception e) {",
            "    System.debug('Generic Exception');",
            "}"
        ],
        "question": "開発者は以上のコードを持っています。\nどのメッセージがログに記録されますか。",
        "choices": ["メッセージは記録されない", "Generic Exception", "List Exception", "NullPointer Exception"],
        "correct": ["NullPointer Exception"],
        "explanations":["メッセージは記録されない", "Generic Exception", "List Exception", "NullPointer Exception"],
        "descriptions":[
            "これは不正解です。コードは例外をキャッチするためのcatchブロックを持っているので、例外が発生した場合、関連するメッセージがログに記録されます。",
            "これは不正解です。例外が発生することは確かですが、このケースでは NullPointerException が発生するため、最も具体的な例外に対応する catch ブロックが実行されます。Generic Exception は、特定されないその他の例外に対してログを記録するためのもので、ここでは実行されません。",
            "これは不正解です。このコードにおいて ListException は発生しません。ListException はリスト操作で発生する特定の問題に関連しており、nameList の初期化がされていないために発生するのは NullPointerException です。",
            "これは正解です。Account a; は初期化されておらず、a.Name にアクセスしようとすると a が null を参照しているため NullPointerException が発生します。また、List<String> nameList; も初期化されていないため、nameList.add(s); を呼び出すところでも NullPointerException が発生します。NullPointerException に該当する catch ブロックがこの例外を捕捉し、”NullPointer Exception” メッセージがログに記録されます。"
        ]
    },
    {
        "number": "76",
        "question": "Force.comプラットフォームのMVCアーキテクチャのコントローラーを表すコードのタイプはどれですか。2つ選びなさい。",
        "choices": ["CSSと画像を含む静的リソース", "データの操作に使用されるカスタムApexおよびJavaScript", "Visualforceによって参照されるStandardControllerシステムメソッド", "メニュー項目を表示するために使用されるJavaScript"],
        "correct": ["データの操作に使用されるカスタムApexおよびJavaScript", "Visualforceによって参照されるStandardControllerシステムメソッド"],
        "explanations":["CSSと画像を含む静的リソース", "データの操作に使用されるカスタムApexおよびJavaScript", "Visualforceによって参照されるStandardControllerシステムメソッド", "メニュー項目を表示するために使用されるJavaScript"],
        "descriptions":[
            "これは不正解です。CSSファイルや画像などの静的リソースは、MVCアーキテクチャにおいて主にビュー(View)の装飾に使用されます。コントローラー(Controller)はデータの流れを制御し、モデル(Model)とビュー(View)の間のやり取りを管理する役割を持っています。",
            "これは正解です。ApexはSalesforce上で動作するサーバーサイドのプログラミング言語であり、データの操作やビジネスロジックを実行するカスタムコントローラーやコントローラー拡張を記述するのに使用されます。また、JavaScriptは主にクライアントサイドで実行され、ビジュアルフォースページの動的な挙動を制御するために用いられます。この両者はコントローラーの役割を果たすことができます。",
            "これは正解です。StandardControllerはForce.comプラットフォームに組み込まれた標準的なコントローラーで、特定のsObjectに基づいた操作を行うための一連のシステムメソッドを提供します。これはビジュアルフォースページで使用され、モデル(Model)のデータにアクセスし、ビュー(View)に表示するためのコードとして機能します。",
            "これは不正解です。メニュー項目を表示するために使用されるJavaScriptは、主にビュー(View)のユーザーインターフェースの一部として機能し、コントローラー(Controller)の役割ではありません。コントローラーはアプリケーションのロジックを処理し、データの取得や更新を担当しますが、メニューの表示はビューの役割です。"
        ]
    },
    {
        "number": "77",
        "question": "開発者コンソールの機能は何ですか。",
        "choices": ["匿名Apexコードの実行、REST APIの実行、コードの作成/編集", "匿名Apexコードの実行、コードの作成/編集、デバッグログの表示", "匿名Apexコードの実行、コードの作成/編集、コード変更のデプロイ", "匿名Apexコードの実行、REST APIの実行、コード変更のデプロイ"],
        "correct": ["匿名Apexコードの実行、コードの作成/編集、デバッグログの表示"],
        "explanations":["匿名Apexコードの実行、REST APIの実行、コードの作成/編集", "匿名Apexコードの実行、コードの作成/編集、デバッグログの表示", "匿名Apexコードの実行、コードの作成/編集、コード変更のデプロイ", "匿名Apexコードの実行、REST APIの実行、コード変更のデプロイ"],
        "descriptions":[
            "これは不正解です。開発者コンソールは匿名Apexコードの実行やコードの作成/編集をサポートしますが、REST APIの実行は主な機能としては含まれていません。",
            "これは正解です。開発者コンソールは、匿名Apexコードの実行、コードの作成/編集、デバッグログの表示などの機能を提供しています。",
            "これは不正解です。開発者コンソールはコードの作成や編集をサポートしますが、コード変更のデプロイは主な機能としては提供していません。",
            "これは不正解です。開発者コンソールは匿名Apexコードの実行をサポートしますが、REST APIの実行やコード変更のデプロイは主な機能としては含まれていません。"
        ]
    },
    {
        "number": "78",
        "question": "単一レコードで、ユーザーは複数選択リストから複数の値を選択します。選択した値はApexでどのように表されますか。",
        "choices": ["各値をカンマで区切ったStringとして", "各値をSetの要素とした、Set<String>として", "各値をListの要素とした、List<String>として", "各値をセミコロンで区切ったStringとして"],
        "correct": ["各値をセミコロンで区切ったStringとして"],
        "explanations":["各値をカンマで区切ったStringとして", "各値をSetの要素とした、Set<String>として", "各値をListの要素とした、List<String>として", "各値をセミコロンで区切ったStringとして"],
        "descriptions":[
            "これは不正解です。Salesforceの複数選択リストの選択された値はカンマではなく、セミコロンで区切られた文字列として格納されます。",
            "これは不正解です。Apexコード内で複数選択リストの値を扱う場合、デフォルトではSetとして提供されるわけではありません。セミコロン区切りの文字列として提供されます。",
            "これは不正解です。Apexでは、複数選択リストの値は直接リストとして提供されるわけではありません。これらの値はセミコロンで区切られた単一の文字列として保存されます。",
            "これは正解です。Salesforceでは、複数選択リストから選択された値は、セミコロンで区切られて一つの文字列としてApexに渡されます。例えば、もしユーザーが「選択肢1」と「選択肢2」を選択した場合、Apexには「選択肢1;選択肢2」という文字列が提供されます。"
        ]
    },
    {
        "number": "79",
        "question": "カスタムSVGをLightning Webコンポーネントに含めることができる３つのステップはどれですか。3つ選びなさい。",
        "choices": ["SVGを静的リソースとしてアップロードします。", "HTMLテンプレートでgetterを参照します。", "SVGをコンテンツアセットファイルとしてインポートします。", "HTMLテンプレートでインポートを参照します。", "静的リソースをインポートし、JavaScriptでgetterを提供します。"],
        "correct": ["SVGを静的リソースとしてアップロードします。", "HTMLテンプレートでgetterを参照します。", "静的リソースをインポートし、JavaScriptでgetterを提供します。"],
        "explanations":["SVGを静的リソースとしてアップロードします。", "HTMLテンプレートでgetterを参照します。", "SVGをコンテンツアセットファイルとしてインポートします。", "HTMLテンプレートでインポートを参照します。", "静的リソースをインポートし、JavaScriptでgetterを提供します。"],
        "descriptions":[
            "これは正解です。Lightning Web コンポーネントでSVGを使用する際の一般的な手法は、SVGファイルを静的リソースとしてSalesforceにアップロードすることです。",
            "これは正解です。JavaScriptファイル内で定義されたgetterやプロパティは、HTMLテンプレート内で参照することができます。これにより、静的リソースから取得したデータやSVGのパスなどをHTMLテンプレートにバインドすることができます。",
            "これは不正解です。Lightning Web コンポーネントでSVGを使用する際、SVGをコンテンツアセットファイルとしてインポートする手法は一般的ではありません。静的リソースとしてのアップロードが推奨されます。",
            "これは不正解です。HTMLテンプレート内で直接インポートを行うことはできません。インポートはJavaScriptファイル内で行われ、その後、HTMLテンプレートでgetterやプロパティを介して参照されます。",
            "これは正解です。静的リソースをJavaScriptファイル内でインポートし、そのリソースをHTMLテンプレートで使用するためのgetterを提供することは、Lightning Web コンポーネントの一般的なパターンです。"
        ]
    },
    {
        "number": "80",
        "question": "外部IDの用途は何ですか。2つ選びなさい。",
        "choices": ["外部システムからインポートされたレコード間の関係を作成します。", "別の環境と同じSalesforceIDを使用して開発環境でレコードを作成します。", "SalesforceでsObjectタイプを識別します。", "Upsertを使用して重複レコードを作成するのを防ぎます。"],
        "correct": ["外部システムからインポートされたレコード間の関係を作成します。", "Upsertを使用して重複レコードを作成するのを防ぎます。"],
        "explanations":["外部システムからインポートされたレコード間の関係を作成します。", "別の環境と同じSalesforceIDを使用して開発環境でレコードを作成します。", "SalesforceでsObjectタイプを識別します。", "Upsertを使用して重複レコードを作成するのを防ぎます。"],
        "descriptions":[
            "これは正解です。外部IDは、データをインポートする際に関連レコードを照合するための参照ポイントとして機能します。例えば、Salesforceで取引先責任者と取引先の間に関連を作成する際に、取引先の外部IDを使用して関連する取引先レコードを参照することができます。これにより、インポートプロセス中に正確なレコード間の関係が維持されます。",
            "これは不正解です。 SalesforceのIDは、その環境内でのみ一意です。開発環境と本番環境など、異なる環境間で同じSalesforceIDを使用することはできません。外部IDは、異なるシステムやSalesforceの異なる環境間でレコードを一意に識別するために使用されますが、SalesforceIDとは独立しています。",
            "これは不正解です。sObjectタイプ(例：Account, Contact)はSalesforceにおけるオブジェクトの種類を識別しますが、これは外部IDとは関係がありません。外部IDはレコードレベルで一意性を持つためのものであり、オブジェクトタイプ自体を識別するものではありません。",
            "これは正解です。「Upsert」操作は、レコードが存在しない場合は新しいレコードを挿入(insert)し、存在する場合は更新(update)します。外部IDを使用することで、レコードが既に存在するかどうかを識別し、重複するレコードの挿入を防ぐことができます。これはデータの整合性を維持するのに非常に重要です。"
        ]
    },
    {
        "number": "81",
        "question": "組織には「NoContacts」という名前の単一の取引先があり、関連する取引先責任者はありません。\n以下のApexを実行した結果はどうなりますか。",
        "following-code": [
            "List<Account> accounts = [",
            "  SELECT Name, (SELECT Id, Name FROM Contacts)",
            "  FROM Account ",
            "  WHERE Name = 'NoContacts'",
            "]; "
        ],
        "choices": ["QueryExceptionがスローされます。", "accounts[0].contactsは空です。", "accounts[0].contactsはNullです。", "accounts[0].contactsは無効です。"],
        "correct": ["accounts[0].contactsは空です。"],
        "explanations":["QueryExceptionがスローされます。", "accounts[0].contactsは空です。", "accounts[0].contactsはNullです。", "accounts[0].contactsは無効です。"],
        "descriptions":[
            "これは不正解です。提供されたApexコードは正しいSOQLクエリを使用しており、NoContacts という名前の取引先が存在する場合、このクエリは問題なく実行されます。取引先責任者がいない場合でもQueryExceptionはスローされません。Salesforceでは、子関係クエリが結果を返さない場合は単に空のリストが返されます。",
            "これは正解です。サブクエリ (SELECT Id, Name FROM Contacts) は関連する取引先責任者のレコードを取得しようとしますが、NoContacts という名前の取引先に関連する取引先責任者がいないため、このリストは空になります(つまり、要素が0個です)。しかし、これはnullではなく、空のリスト(List<Contact>)です。",
            "これは不正解です。SalesforceのSOQLクエリで子関係をクエリすると、その子関係が空であったとしても、nullではなく空のリストが返されます。ですので、このリストはnullではなく、上記の通り空です。",
            "これは不正解です。accounts[0].contacts が無効という状態は存在しません。Salesforceでは、このようなクエリ結果は正しく扱われ、結果がない場合は単に空のリストが返されます。無効という状態は特にこのコンテキストには当てはまりません。"
        ]
    },
    {
        "number": "82",
        "question": "Lightningコンポーネントで外部JavaScriptライブラリをロードするために使用される<ltng：require>タグの機能は何ですか。3つ選びなさい。",
        "choices": ["ドキュメントからのファイルの読み込み", "重複するスクリプトの1回限りの読み込み", "読み込み順序の指定", "スクリプトを並行して読み込む", "外部でホストされているスクリプトの読み込み"],
        "correct": ["重複するスクリプトの1回限りの読み込み", "読み込み順序の指定", "スクリプトを並行して読み込む"],
        "explanations":["ドキュメントからのファイルの読み込み", "重複するスクリプトの1回限りの読み込み", "読み込み順序の指定", "スクリプトを並行して読み込む", "外部でホストされているスクリプトの読み込み"],
        "descriptions":[
            "これは不正解です。<ltng:require>タグは、ドキュメントから直接ファイルを読み込むために使用されるものではありません。このタグは外部のJavaScriptライブラリやCSSファイルをコンポーネントに含めるために使用されます。",
            "これは正解です。<ltng:require> タグは、指定されたスクリプトが既にロードされていれば、再度ロードすることなく一度だけロードすることを保証します。これにより、パフォーマンスの最適化が図られます。",
            "これは正解です。<ltng:require> タグでは、scripts 属性に指定したスクリプトはリストに記載された順に読み込まれます。これにより、依存関係を持つスクリプトが正しい順序で読み込まれるようになります。",
            "これは正解です。<ltng:require> タグを使用して、相互に依存しない複数のスクリプトを並行して読み込むことができます。これにより、複数のリソースを同時に読み込むことで読み込み時間を短縮できる可能性があります。",
            "これは不正解です。Salesforceは外部ソースからのスクリプトの直接読み込みをCSPにより制限しています。安全性を保つため、<ltng:require> タグで直接読み込む代わりに、静的リソースを介してロードする必要があります。"
        ]
    },
    {
        "number": "83",
        "question": "GetterメソッドとSetterメソッドに関する記述のうち、正しいものはどれですか。2つ選びなさい。",
        "choices": ["ページからコントローラーに値を渡すには、より適切なメソッドが必要です。", "Setterメソッドは常にグローバルに宣言する必要があります。", "GetterメソッドとSetterメソッドの実行順序は保証されません。", "Getterメソッドは、コントローラからページに値を渡すことができます。"],
        "correct": ["GetterメソッドとSetterメソッドの実行順序は保証されません。", "Getterメソッドは、コントローラからページに値を渡すことができます。"],
        "explanations":["ページからコントローラーに値を渡すには、より適切なメソッドが必要です。", "Setterメソッドは常にグローバルに宣言する必要があります。", "GetterメソッドとSetterメソッドの実行順序は保証されません。", "Getterメソッドは、コントローラからページに値を渡すことができます。"],
        "descriptions":[
            "これは不正解です。Visualforceのコンテキストにおいて、ページからコントローラーに値を渡す際にはSetterメソッドを使用します。Visualforceページ内でユーザーが入力したデータは、Setterメソッドを介してApexコントローラーに渡されるため、この文は誤りです。",
            "これは不正解です。VisualforceとApexコントローラーにおいて、Setterメソッド(およびGetterメソッド)は通常、特定のアクセス修飾子を使用してクラス内に宣言されます。これはpublicであることが多いですが、必ずしもグローバルである必要はありません。globalアクセス修飾子は異なる名前空間間でのアクセスが必要な場合に使用されることがありますが、通常のVisualforceページとApexコントローラー間のデータバインディングにはpublicで十分です。",
            "これは正解です。Visualforceページにおいて、GetterメソッドとSetterメソッドが呼び出される順序は固定されておらず、ページのレンダリング中に複数回呼び出されることがあります。ページのライフサイクルにおける特定の時点でこれらが呼び出されるため、開発者は順序に依存しないように注意する必要があります。",
            "これは正解です。Visualforceページに表示されるデータは、Getterメソッドを介してApexコントローラから取得されます。Getterメソッドはページが要求するデータを提供し、Visualforceページ上の特定のプロパティにバインドするために使用されます。"
        ]
    },
    {
        "number": "84",
        "previous-code": [
            "public with sharing class myFooController{",
            "    public integer prop {get; private set;}",
            "}"
        ],
        "question": "開発者は以上のコントローラクラスを持ちます。\nどのコードブロックが実行匿名ウィンドウで正常に実行されますか。",
        "choices": ["myFooController m = new myFooController();\nSystem.assert(m.prop == null);", "myFooController m = new myFooController();\nSystem.assert(m.prop == 0);", "myFooController m = new myFooController();\nSystem.assert(m.prop == 1);", "myFooController m = new myFooController();\nSystem.assert(m.prop != null);"],
        "correct": ["myFooController m = new myFooController();\nSystem.assert(m.prop == null);"],
        "explanations":["myFooController m = new myFooController();\nSystem.assert(m.prop == null);", "myFooController m = new myFooController();\nSystem.assert(m.prop == 0);", "myFooController m = new myFooController();\nSystem.assert(m.prop == 1);", "myFooController m = new myFooController();\nSystem.assert(m.prop != null);"],
        "descriptions":[
            "これは正解です。propは初期化されておらず、デフォルトでnullを持つため、このアサーションは成功します。",
            "これは不正解です。Apexでは整数型は自動的に0で初期化されないため、このアサーションは失敗します。propはnullであるためです。",
            "これは不正解です。propは初期化されていないためnullです。1で初期化されることはありませんので、このアサーションも失敗します。",
            "これは不正解です。前述の通り、propはnullで初期化されるため、このアサーションは失敗します。"
        ]
    },
    {
        "number": "85",
        "question": "マルチテナント環境で開発する場合、開発者がガバナ制限に達するのを避けるために使用すべき戦略はどれですか。2つ選びなさい。",
        "choices": ["コレクションを使用して、最低限必要な項目だけでなく、関連するオブジェクトのすべての項目を保存する。", "Apexクラス内の変数を使用して、大量のデータを保存する。", "SOQL For ループを使用して、多数の行を返すクエリから取得したデータを繰り返し処理する。", "Limitsクラスのメソッドを使用して、ガバナ制限を監視する。"],
        "correct": ["SOQL For ループを使用して、多数の行を返すクエリから取得したデータを繰り返し処理する。", "Limitsクラスのメソッドを使用して、ガバナ制限を監視する。"],
        "explanations":["コレクションを使用して、最低限必要な項目だけでなく、関連するオブジェクトのすべての項目を保存する。", "Apexクラス内の変数を使用して、大量のデータを保存する。", "SOQL For ループを使用して、多数の行を返すクエリから取得したデータを繰り返し処理する。", "Limitsクラスのメソッドを使用して、ガバナ制限を監視する。"],
        "descriptions":[
            "これは不正解です。コレクションを使用することは良い実践ですが、関連するオブジェクトの「すべての項目」を保存するのは無駄が多く、ガバナ制限に達する原因となる可能性があります。代わりに、必要なデータのみをコレクションに格納するべきです。これにより、ヒープ制限に達するのを避け、メモリを効率的に使用することができます。",
            "これは不正解です。Apexクラス内の変数に大量のデータを保存することは、ヒープサイズのガバナ制限に達するリスクを高めます。代わりに、データを必要とする時点で、必要最小限のデータのみを取得するように処理を行うべきです。",
            "これは正解です。SOQL For ループは、取得したデータをバッチで処理することを可能にし、メモリの消費を小さく抑えることができるため、ガバナ制限に達するのを防ぎます。これはSalesforceのベストプラクティスの一つです。",
            "これは正解です。Limitsクラスを使用すると、現在のトランザクションでどの程度のガバナ制限に達しているかをリアルタイムで監視することができます。これにより、開発者はリソースの消費を管理し、ガバナ制限に達する前に適切なアクションを取ることができます。"
        ]
    },
    {
        "number": "86",
        "question": "カスタムオブジェクトには、Food_Preference__cというカスタム選択リスト項目が存在します。この選択リストには、”Vegan”、”Kosher”、”No Preference”というオプションが含まれています。開発者は、レコードが作成または更新されるたびに値が入力されることを確認する必要があります。 レコードが保存されるたびに値が選択されることを確実にするための最も効率的な方法は何ですか。",
        "choices": ["項目定義で項目を必須としてマークします。", "選択リスト作成時に「最初の値をデフォルト値とする」にチェックを入れます。", "オブジェクトのページレイアウトで項目を必須としてマークします。", "値が選択されることを強制するための入力規則を設定します。"],
        "correct": ["項目定義で項目を必須としてマークします。"],
        "explanations":["項目定義で項目を必須としてマークします。", "選択リスト作成時に「最初の値をデフォルト値とする」にチェックを入れます。", "オブジェクトのページレイアウトで項目を必須としてマークします。", "値が選択されることを強制するための入力規則を設定します。"],
        "descriptions":[
            "これは正解です。カスタム項目を作成または編集する際に、項目を「必須」としてマークすることで、レコードが作成または更新される際にユーザーがその項目に値を入力することを強制できます。これは最も効率的な方法です。この設定により、APIを介してレコードが作成または更新される際にも、項目に値が入力されることが保証されます。",
            "これは不正解です。これは選択リストの値をデフォルトで選択された状態にするものであり、ユーザーが意図的に値を選択することを保証しません。ユーザーが何も選択せずにレコードを保存してしまう可能性があります。",
            "これは不正解です。ページレイアウトで項目を必須とする方法は、そのページレイアウトを使用してレコードが作成または編集される際にのみ有効です。API経由や他のページレイアウトを使用した場合は保証されません。",
            "これは不正解です。入力規則を使用して特定の項目に値が入力されることを強制することもできます。これは、レコードが保存される際に特定の条件を満たすことをユーザーに要求する一般的な方法ですが、項目を「必須」とするよりも管理が複雑になる可能性があります。"
        ]
    },
    {
        "number": "87",
        "previous-code": [
            "List<Account> acc = [SELECT Id FROM Account LIMIT 10];",
            "Delete acc;",
            "Database.emptyRecycleBin(acc);",
            "System.Debug(Limits.getDMLStatements()+', '+Limits.getLimitDMLStatements());"
        ],
        "question": "開発者は実行匿名ウィンドウで以上のコードを記述します。\nデバッグステートメントの結果は何ですか。",
        "choices": ["1, 150", "2, 150", "1, 100", "2, 200"],
        "correct": ["2, 150"],
        "explanations":["1, 150", "2, 150", "1, 100", "2, 200"],
        "descriptions":[
            "",
            "正解は2, 150。",
            "",
            ""
        ]
    },
    {
        "number": "88",
        "question": "Lightningコンポーネントはリソースバンドルに何を含めることができますか。2つ選びなさい。",
        "choices": ["カスタムクライアント側のレンダリング動作", "縮小化のためのスクリプト作成", "コンポーネントに割り当てられたCSSスタイル", "グローバル設定を含むプロパティファイル"],
        "correct": ["カスタムクライアント側のレンダリング動作", "コンポーネントに割り当てられたCSSスタイル"],
        "explanations":["カスタムクライアント側のレンダリング動作", "縮小化のためのスクリプト作成", "コンポーネントに割り当てられたCSSスタイル", "グローバル設定を含むプロパティファイル"],
        "descriptions":[
            "これは正解です。Lightning コンポーネントはカスタムのレンダリング動作を定義することができ、そのためにレンダラー JavaScript ファイルを使用します。",
            "これは不正解です。Lightning コンポーネントの開発では、開発者が縮小化スクリプトをリソースバンドルに含めることはありません。コードの縮小化はSalesforceプラットフォームが自動で行います。",
            "これは正解です。リソースバンドルにはコンポーネント固有のスタイルを定義するCSSファイルを含めることができます。",
            "これは不正解です。Salesforce Lightning コンポーネントでグローバル設定を管理するための「プロパティファイル」はありません。コンポーネントの属性として設定され、.designファイルでLightning アプリケーションビルダーで設定可能な属性として公開されることがあります。"
        ]
    },
    {
        "number": "89",
        "question": "開発者がSalesforce REST APIにリクエストを送信し、レスポンスを表示できるツールはどれですか。",
        "choices": ["Workbench RESTエクスプローラ", "RESTリソースパスのURL", "開発者コンソールのRESTタブ", "Force.com IDE RESTエクスプローラタブ"],
        "correct": ["Workbench RESTエクスプローラ"],
        "explanations":["Workbench RESTエクスプローラ", "RESTリソースパスのURL", "開発者コンソールのRESTタブ", "Force.com IDE RESTエクスプローラタブ"],
        "descriptions":[
            "これは正解です。WorkbenchはSalesforce開発者と管理者のための強力なツールであり、RESTエクスプローラを使用してSalesforce REST APIにリクエストを送信し、レスポンスを表示することができます。",
            "これは不正解です。RESTリソースパスのURLは、APIリクエストを指定するためのものであり、それ自体がツールではありません。このURLを使用してリクエストを送信するためのツールやライブラリが必要です。",
            "これは不正解です。開発者コンソールにはRESTタブは存在しません。開発者コンソールはクエリやApexコードの実行、デバッグログの確認などに使用されますが、REST APIリクエストを直接送信するためのタブや機能は提供していません。",
            "これは不正解です。Force.com IDEには「RESTエクスプローラタブ」は存在しません。また、Force.com IDEは現在非推奨となっており、Salesforce DXとVisual Studio Codeが推奨されています。"
        ]
    },
    {
        "number": "90",
        "question": "開発者は、ヘルパークラスを持つ新しいApexトリガーを作成し、新しいApexヘルパークラスの95%のカバレッジのみを実行するテストクラスを作成します。本番環境への変更セットのデプロイは、以下テストカバレッジの警告で失敗します。\n“選択したApexトリガーのテストカバレッジは0%です。少なくとも1%のテストカバレッジが必要です。”\n新しいApexトリガーとヘルパークラスのデプロイを成功させるために、開発者は何をする必要がありますか。",
        "choices": ["ヘルパークラスのテストクラスカバレッジを増やす。", "失敗したテストメソッドをテストクラスから削除する。", "開発者コンソールで「Run All」を使用してテストを実行する。", "Apexトリガーをカバーするテストクラスとメソッドを作成する。"],
        "correct": ["Apexトリガーをカバーするテストクラスとメソッドを作成する。"],
        "explanations":["ヘルパークラスのテストクラスカバレッジを増やす。", "失敗したテストメソッドをテストクラスから削除する。", "開発者コンソールで「Run All」を使用してテストを実行する。", "Apexトリガーをカバーするテストクラスとメソッドを作成する。"],
        "descriptions":[
            "これは不正解です。ヘルパークラスのカバレッジを増やすことは一般に良い習慣ですが、問題の原因はトリガーのカバレッジが0%であることなので、これが直接の解決策にはなりません。",
            "これは不正解です。テストメソッドが失敗しているという情報はありませんし、失敗しているテストメソッドを削除することは、テストカバレッジを改善する適切なアプローチではありません。問題はカバレッジの不足です。",
            "これは不正解です。このオプションは組織内の全てのテストを実行しますが、特定のトリガーのテストカバレッジを増やすためには、そのトリガーに対して特定のテストケースを実行する必要があります。",
            "これは正解です。Salesforceでは本番環境へのデプロイ前に、運用環境全体での全テストの合計カバレッジが75%以上であること、および各Apexトリガーのテストカバレッジが最低1%以上であることが必要です。そのため、トリガーがテストクラスによって全くカバーされていない場合、トリガーを適切にテストするテストクラスとメソッドを作成することが解決策になります。"
        ]
    },
    {
        "number": "91",
        "question": "VisualforceページのコンテンツをPDFとして表示するコードはどれですか。",
        "choices": ["<apex:page contentType=”pdf”>", "<apex:page renderAs=”pdf”>", "<apex:page contentType=”application/pdf”>", "<apex:page rendersAs=”application/pdf”>"],
        "correct": ["<apex:page renderAs=”pdf”>"],
        "explanations":["<apex:page contentType=”pdf”>", "<apex:page renderAs=”pdf”>", "<apex:page contentType=”application/pdf”>", "<apex:page rendersAs=”application/pdf”>"],
        "descriptions":[
            "これは不正解です。この属性の値は正しくありません。contentType 属性は、MIME(contentTypeはMultipurpose Internet Mail Extension)タイプを指定するためのもので、”pdf”は正しいMIMEタイプではありません。",
            "これは正解です。renderAs属性を使用して、VisualforceページのコンテンツをPDFとして表示することができます。この属性の値として”pdf”を指定することで、ページはPDFとしてレンダリングされます。",
            "これは不正解です。contentTypeはMIMEタイプを指定するためのものですが、VisualforceページをPDFとしてレンダリングするためにはrenderAs属性を使用する必要があります。",
            "これは不正解です。この属性名や値は正しくありません。正しい属性名はrenderAsで、正しい値は”pdf”です。"
        ]
    },
    {
        "number": "92",
        "question": "パス",
        "choices": ["", "", "", ""],
        "correct": [""],
        "explanations":["", "", "", ""],
        "descriptions":[
            "",
            "",
            "",
            ""
        ]
    },
    {
        "number": "93",
        "question": "開発者は、組織のデータを変更することなく、取引先トリガーが正しく動作していることを確認する必要があります。開発者は、取引先トリガーをテストするために何をすべきでしょうか。",
        "choices": ["開発者コンソールの[テスト]メニューを使用して、取引先トリガーのすべてのテストクラスを実行します。", "開発者コンソールの匿名実行機能を使用して、’insert Account’DML文を実行します。", "VSCode IDEのデプロイを使用して、’insert Account’Apexクラスをデプロイします。", "Salesforceの[取引先]タブの[新規]ボタンを使用して、新しい取引先レコードを作成します。"],
        "correct": ["開発者コンソールの[テスト]メニューを使用して、取引先トリガーのすべてのテストクラスを実行します。"],
        "explanations":["開発者コンソールの[テスト]メニューを使用して、取引先トリガーのすべてのテストクラスを実行します。", "開発者コンソールの匿名実行機能を使用して、’insert Account’DML文を実行します。", "VSCode IDEのデプロイを使用して、’insert Account’Apexクラスをデプロイします。", "Salesforceの[取引先]タブの[新規]ボタンを使用して、新しい取引先レコードを作成します。"],
        "descriptions":[
            "これは正解です。Salesforceでは、開発したトリガーやApexクラスの正確性を確認するために、テストクラスの作成と実行が必須です。開発者コンソールの[テスト]メニューを利用してテストクラスを実行することにより、トリガーが想定通りに機能しているかを検証できます。またテストクラスを作成することで、テストの実行は実際のデータベースには影響を与えずに行われます。",
            "これは不正解です。匿名実行は開発者が一時的なApexコードを実行できる機能ですが、これによって実際のDML操作が実行され、データベースに変更が加わります。テスト目的であれば、データを変更せずに機能を検証できるユニットテストを用いるべきです。",
            "これは不正解です。デプロイプロセスは開発環境から本番環境へのコード移行を意味しますが、これはテストの実行ではありません。トリガーの動作をテストするためには、テストクラスとテストメソッドを用いて、コードが期待通りに動作することを確認する必要があります。",
            "これは不正解です。この方法は実際に新しい取引先レコードを作成し、トリガーを発動させるものであり、テストではありません。テストクラスを使用することで、本番環境のデータを操作することなくトリガーの機能を安全に検証できます。"
        ]
    },
    {
        "number": "94",
        "question": "Apexコンパイラエラーが発生するステートメントはどれですか。",
        "choices": ["Map<Id, Lead> lmap = new Map<Id, Lead>([Select ID from Lead Limit 8]);", "Date d1 = Date.Today(), d2 = Date.ValueOf(‘2018-01-01’);", "Integer a=5, b=6, c, d = 7;", "List<String> s = List<String>{‘a’,’b’,’c’};"],
        "correct": ["List<String> s = List<String>{‘a’,’b’,’c’};"],
        "explanations":["Map<Id, Lead> lmap = new Map<Id, Lead>([Select ID from Lead Limit 8]);", "Date d1 = Date.Today(), d2 = Date.ValueOf(‘2018-01-01’);", "Integer a=5, b=6, c, d = 7;", "List<String> s = List<String>{‘a’,’b’,’c’};"],
        "descriptions":[
            "これは不正解です。 このステートメントは、SOQLクエリを利用してリードオブジェクトのリストを取得し、それをMapのコンストラクタに渡しています。この構文は正しく、IdをキーとしたリードオブジェクトのMapを生成するため、コンパイルエラーは発生しません。",
            "これは不正解です。 このステートメントは正しく、Dateクラスのメソッドを使用して日付を取得および変換しています。この行は、現在の日付を取得するためのTodayメソッドと、文字列から日付を生成するためのValueOfメソッドを使用しています。Apexにおいてこのように複数の変数を同じ行で宣言し、異なる値を割り当てることは有効であり、コンパイルエラーは発生しません。",
            "これは不正解です。 こちらは複数の変数を一行で宣言していますが、Apexではこのような宣言は有効で、コンパイルエラーを引き起こしません。変数cには値が割り当てられていないため、デフォルトでnullを持ちますが、これはエラーではありません。",
            "これは正解です。 これはコンパイルエラーが発生します。理由は、リストの宣言において new キーワードが欠けているためです。Apexでは、新しいオブジェクトやコレクションを作成する際には new キーワードが必須です。正しい書き方は以下の通りです。\n\nList<String> s = new List<String>{'a', 'b', 'c'};"
        ]
    },
    {
        "number": "95",
        "question": "新しく採用された開発者は、ケースオブジェクトに複数のトリガーがあることを発見しました。トリガーを使用する際に開発者は何を考慮すべきですか。",
        "choices": ["開発者はトリガーの実行順序を決めなければなりません。", "トリガーの実行順序は作成日時に基づいています。", "単体テストではテストするトリガーを指定する必要があります。", "同じsObjectに対するトリガーは実行順序が保証されません。"],
        "correct": ["同じsObjectに対するトリガーは実行順序が保証されません。"],
        "explanations":["開発者はトリガーの実行順序を決めなければなりません。", "トリガーの実行順序は作成日時に基づいています。", "単体テストではテストするトリガーを指定する必要があります。", "同じsObjectに対するトリガーは実行順序が保証されません。"],
        "descriptions":[
            "これは不正解です。 開発者はSalesforceのトリガーに対する実行順序を直接制御することはできません。代わりに、一つのトリガーの中で複数の処理を管理したり、ベストプラクティスとしてトリガーのロジックをヘルパークラスに分割することで、処理の流れをより制御できるようになります。",
            "これは不正解です。Salesforceでは、複数のトリガーがある場合、それらが実行される順序は保証されておらず、作成日時に基づくものではありません。実行順序が重要な場合は、ロジックを適切に設計する必要があります。",
            "これは不正解です。 単体テストでは特定のトリガーを指定してテストすることはできません。テスト中に特定の操作(例えばレコードの挿入や更新)を行った際に、関連する全てのトリガーが自動的に発火します。テストクラスは、その結果としてトリガーによる副作用も含めてシステムの振る舞いを検証する必要があります。",
            "これは正解です。Salesforceでは同一のオブジェクトに複数のトリガーがある場合、その実行順序は保証されていません。そのため、開発者はトリガー間で依存関係を持たせないように注意深く設計する必要があります。また、必要であればトリガーのロジックを一つのクラスに集約して、実行順序をコード内で管理する手法を取ることが推奨されます。"
        ]
    },
    {
        "number": "96",
        "question": "標準機能とカスタム機能の両方を含むケースレコードを表示および編集するVisualforceページが必要です。VisualforceページにmyControllerExtensionというApexクラスで定義されたコントローラ機能を正しく実装するためにどの属性を含める必要がありますか。",
        "choices": ["extensions = “myControllerExtension”", "controller = “myControllerExtension”", "controller = “Case” extensions = “myControllerExtension”", "standardController = “Case” extensions = “myControllerExtension”"],
        "correct": ["standardController = “Case” extensions = “myControllerExtension”"],
        "explanations":["extensions = “myControllerExtension”", "controller = “myControllerExtension”", "controller = “Case” extensions = “myControllerExtension”", "standardController = “Case” extensions = “myControllerExtension”"],
        "descriptions":[
            "これは不正解です。extensionsを指定するだけでは不十分です。standardControllerやcustomControllerの指定がないため、Visualforceページはどのオブジェクトのレコードを扱うのか分かりません。",
            "これは不正解です。controller属性はカスタムコントローラを指定するために使用されますが、この質問の要件ではCaseオブジェクトの標準コントローラに拡張機能を追加する必要があるため、この属性の使用方法が間違っています。",
            "これは不正解です。標準コントローラを指定する際にはstandardController属性を使用する必要があり、controllerはカスタムコントローラを指定するためのものです。",
            "これは正解です。standardController属性で標準コントローラ(この場合はCaseオブジェクト)を指定し、extensions属性でその標準コントローラを拡張するカスタムApexクラス(myControllerExtension)を指定しています。これにより、標準機能に加えてカスタム機能をVisualforceページに組み込むことができます。"
        ]
    },
    {
        "number": "97",
        "question": "開発者は、取引先責任者のリストを更新するApexメソッドを作成し、LightningWebコンポーネントで使用できるようにしたいと考えています。 これを実現するために、開発者はどのアノテーションをApexメソッドに追加する必要がありますか。",
        "choices": ["@RemoteAction", "@AuraEnabled", "@AuraEnabled(cacheable=true)", "@RemoteAction(cacheable=true)"],
        "correct": ["@AuraEnabled"],
        "explanations":["@RemoteAction", "@AuraEnabled", "@AuraEnabled(cacheable=true)", "@RemoteAction(cacheable=true)"],
        "descriptions":[
            "これは不正解です。@RemoteActionはVisualforceページのJavaScriptからApexメソッドを呼び出すためのアノテーションであり、Lightning Webコンポーネントでは使用されません。",
            "これは正解です。Lightning WebコンポーネントからApexメソッドを呼び出すためには@AuraEnabledアノテーションを使用する必要があります。",
            "これは不正解です。cacheable=true属性は、クライアント側でデータをキャッシュするために読み取り専用のメソッドにのみ使用されます。データを更新するメソッドには適用されません。",
            "これは不正解です。@RemoteActionアノテーションはcacheable=true属性と組み合わせて使用されず、またLightning Webコンポーネントでは使用されません。"
        ]
    },
    {
        "number": "98",
        "question": "Visualforceページにページネーションを追加するために、開発者が使用すべき手段はどれですか。",
        "choices": ["StandardController", "ページのaction属性", "ページのextensions属性", "StandardSetController"],
        "correct": ["StandardSetController"],
        "explanations":["StandardController", "ページのaction属性", "ページのextensions属性", "StandardSetController"],
        "descriptions":[
            "これは不正解です。StandardControllerは、単一のレコードを操作するためのメソッドを提供しますが、ページネーションを実装する機能は提供しません。",
            "これは不正解です。action属性は、ページが読み込まれたときに実行されるメソッドを指定するもので、ページネーションの直接的な実装には使用されません。",
            "これは不正解です。extensions属性は、標準のコントローラやカスタムコントローラに追加の機能を提供するクラスを指定するために使用されますが、これ単体でページネーション機能を提供するわけではありません。",
            "これは正解です。StandardSetControllerは、リストやコレクションのレコードを操作するためのメソッドを提供します。これにはページネーションを実装するためのメソッド(next、previous、setPageSizeなど)が含まれており、Visualforceページにページネーションを追加するのに最適です。"
        ]
    },
    {
        "number": "99",
        "question": "“without sharing”キーワードを使用してApexクラスを宣言すると、どのような影響がありますか。",
        "choices": ["現在のユーザーが所有するレコードのみを更新できます。", "現在のユーザーの共有ルールは適用されません。", "クラスが作成したレコードに共有ルールを設定することはできません。", "このクラスは、開発者権限を持つユーザーのみが使用できます。"],
        "correct": ["現在のユーザーの共有ルールは適用されません。"],
        "explanations":["現在のユーザーが所有するレコードのみを更新できます。", "現在のユーザーの共有ルールは適用されません。", "クラスが作成したレコードに共有ルールを設定することはできません。", "このクラスは、開発者権限を持つユーザーのみが使用できます。"],
        "descriptions":[
            "これは不正解です。”without sharing”キーワードは、ユーザーが所有するレコードに限定せず、共有ルールを無視するため、所有していないレコードに対しても更新を行うことができます。",
            "これは正解です。”without sharing”キーワードは共有ルールを無視し、コードは共有設定に関係なくデータベースのレコードにアクセスします。",
            "これは不正解です。”without sharing”キーワードの使用は、メソッドの実行において共有ルールを無視することを意味しますが、クラスが作成したレコードに対して共有ルールを設定できないわけではありません。レコードの共有は、後から設定することができます。",
            "これは不正解です。”without sharing”キーワードは実行ユーザーの権限レベルとは無関係であり、開発者権限を持つユーザーに限定されるわけではありません。どのユーザーがクラスを実行できるかは、プロファイルと権限セットによって制御されます。"
        ]
    },
    {
        "number": "100",
        "question": "どの数式が正しく評価されますか。2つ選びなさい。",
        "choices": ["Double d = 3.14159;", "Integer I = 3.14159;", "Decimal d = 3.14159;", "Long l = 3.14159;"],
        "correct": ["Double d = 3.14159;", "Decimal d = 3.14159;"],
        "explanations":["Double d = 3.14159;", "Integer I = 3.14159;", "Decimal d = 3.14159;", "Long l = 3.14159;"],
        "descriptions":[
            "これは正解です。Doubleは浮動小数点数を表すデータ型で、小数点以下の値を持つ数値を格納することができます。",
            "これは不正解です。Integerは整数を表すデータ型で、小数点以下の値を持つ数値は格納できません。",
            "これは正解です。Decimalは小数点を持つ数値を正確に表現するためのデータ型で、特に金融計算などでの使用が推奨されています。",
            "これは不正解です。Longは64ビットの整数値を表すデータ型で、小数点以下の値を持つ数値は格納できません。"
        ]
    },
    {
        "number": "101",
        "question": "変更セットのデプロイについて正しい説明はどれですか。3つ選びなさい。",
        "choices": ["変更セットはカスタム設定データをデプロイできます。", "変更セットは、関連する組織間でのみ使用できます。", "デプロイは一方向の単一トランザクションで行われます。", "2つの組織間で変更セットを送信するには、デプロイメント接続が必要です。", "変更セットはレコードの転送に使用できます。"],
        "correct": ["変更セットは、関連する組織間でのみ使用できます。", "デプロイは一方向の単一トランザクションで行われます。", "2つの組織間で変更セットを送信するには、デプロイメント接続が必要です。"],
        "explanations":["変更セットはカスタム設定データをデプロイできます。", "変更セットは、関連する組織間でのみ使用できます。", "デプロイは一方向の単一トランザクションで行われます。", "2つの組織間で変更セットを送信するには、デプロイメント接続が必要です。", "変更セットはレコードの転送に使用できます。"],
        "descriptions":[
            "これは不正解です。変更セットはメタデータのデプロイに使用され、カスタム設定のデータ(設定された値)をデプロイすることはできません。カスタム設定の構造はデプロイできますが、そのデータ自体はデプロイできません。",
            "これは正解です。変更セットはサンドボックスから本番環境、または関連するサンドボックス間でのみ使用できます。これは接続された組織でのみ機能します。",
            "これは正解です。変更セットによるデプロイプロセスは、始められたら変更セットに含まれるすべてのコンポーネントが一緒にデプロイされる一方通行のトランザクションです。",
            "これは正解です。送信元組織と受信先組織間で変更セットを使用するには、事前にデプロイメント接繋が設定されている必要があります。",
            "これは不正解です。変更セットはメタデータの転送に用いられ、レコードの内容(例えば、オブジェクトの実際のデータ)の転送には使用されません。レコードの転送には一括移行ツールなどが必要です。"
        ]
    },
    {
        "number": "102",
        "question": "before insertトリガーを使用する代わりにafter insertトリガーを使用する利点は何ですか。",
        "choices": ["after insertトリガーを使用すると、開発者は新しいレコードの項目を更新する際に入力規則を回避できます。", "after insertトリガーを使用すると、開発者は新しいレコードを参照する他のオブジェクトを挿入できます。", "after insertトリガーを使用すると、開発者は外部サービスにコールアウトを行うことができます。", "after insertトリガーを使用すると、開発者はクエリなしで新しいレコードの項目を変更できます。"],
        "correct": ["after insertトリガーを使用すると、開発者は新しいレコードを参照する他のオブジェクトを挿入できます。"],
        "explanations":["after insertトリガーを使用すると、開発者は新しいレコードの項目を更新する際に入力規則を回避できます。", "after insertトリガーを使用すると、開発者は新しいレコードを参照する他のオブジェクトを挿入できます。", "after insertトリガーを使用すると、開発者は外部サービスにコールアウトを行うことができます。", "after insertトリガーを使用すると、開発者はクエリなしで新しいレコードの項目を変更できます。"],
        "descriptions":[
            "これは不正解です。after insertトリガーはデータがデータベースに挿入された後に実行されるため、入力規則を回避することはできません。入力規則は挿入または更新操作がデータベースに保存される前に適用されます。",
            "これは正解です。レコードがデータベースに挿入された後、そのレコードのIDなどの識別情報が利用可能になります。そのため、after insertトリガーを使用して、これらの情報を参照する関連オブジェクトやレコードを作成することができます。",
            "これは不正解です。トリガー内でのコールアウトは、非同期処理を使用しない限り、直接サポートされていません。beforeまたはafterトリガーのいずれでも、直接コールアウトを行うことは推奨されません。",
            "これは不正解です。after insertトリガーではレコードがすでにデータベースに挿入されているため、そのレコードを変更するには別途更新操作(DML操作)が必要です。ただし、レコードの変更が必要な場合は、通常、before insertトリガーを使用して、データベースに保存される前に変更を行います。"
        ]
    },
    {
        "number": "103",
        "question": "開発者は、会社のブランドガイドラインを使用してフォーマットされたPDF見積書を作成し、それを商談レコードに自動的に保存するよう求められます。開発者がこの機能を実現する方法はどれですか。2つ選びなさい。",
        "choices": ["カスタムスタイルを使用してVisualforceページを作成します。", "会社の書式設定を実装するVisual workflowを作成します。", "AppExchangeからアプリケーションをインストールして文書を生成します。", "メールテンプレートを作成してプロセスビルダーで使用します。"],
        "correct": ["カスタムスタイルを使用してVisualforceページを作成します。", "AppExchangeからアプリケーションをインストールして文書を生成します。"],
        "explanations":["カスタムスタイルを使用してVisualforceページを作成します。", "会社の書式設定を実装するVisual workflowを作成します。", "AppExchangeからアプリケーションをインストールして文書を生成します。", "メールテンプレートを作成してプロセスビルダーで使用します。"],
        "descriptions":[
            "これは正解です。Visualforceページはカスタムスタイルを使用して会社のブランドガイドラインに従いフォーマットされたPDFを生成するのに非常に適しています。renderAs=”pdf” 属性を使用して、Visualforceページから直接PDF形式で出力することができます。さらに、このPDFはApexコードを使って商談レコードに関連付けて保存することも可能です。",
            "これは不正解です。Flow Builder(以前のLightning Flow Builderとして知られ、現在はSalesforce フローの一部として位置づけられています)は、ビジネスプロセスを自動化するためのツールです。しかし、ブランドガイドラインに従ったPDF文書の生成に関して、このツールだけでは直接的な機能を提供していません。",
            "これは正解です。Salesforce AppExchangeには、文書生成やPDF作成のための多くのアプリケーションがあります。これらのアプリケーションを使用することで、会社のブランドガイドラインに従ったPDF見積書を自動的に生成・保存することができます。",
            "これは不正解です。メールテンプレートは、Eメールを送信する際に使用する内容のフォーマットを定義するものであり、直接PDFを作成する機能はありませんので、PDF見積書を作成するという要件には合致しません。プロセスビルダーは、特定のイベントが発生したときに自動的にプロセス(ワークフロー)を実行するツールですが、PDF文書を作成してレコードに添付する機能は提供していません。また、Salesforceはワークフローおよびプロセスビルダーからより強力なフローへの移行を進めており、将来的にはこれらの機能は廃止されます。"
        ]
    },
    {
        "number": "104",
        "question": "DescribeSObjectResultを使用して、現在のユーザーがオブジェクトのレコードを編集できるかどうかを判断するために、開発者が使用できるApexメソッドはどれですか。",
        "choices": ["canUpdate()", "canEdit()", "isUpdateable()", "isEditable()"],
        "correct": ["isUpdateable()"],
        "explanations":["canUpdate()", "canEdit()", "isUpdateable()", "isEditable()"],
        "descriptions":[
            "これは不正解です。ApexのDescribeSObjectResultクラスには「canUpdate()」というメソッドは存在しません。",
            "これは不正解です。ApexのDescribeSObjectResultクラスには「canEdit()」というメソッドは存在しません。",
            "これは正解です。DescribeSObjectResultクラスの「isUpdateable()」メソッドは、現在のユーザーがオブジェクトのレコードを更新できるかどうかを判断するためのものです。",
            "これは不正解です。ApexのDescribeSObjectResultクラスには「isEditable()」というメソッドは存在しません。"
        ]
    },
    {
        "number": "105",
        "question": "開発者がサンドボックスの全体的なコードカバレッジを判断できるのはどこですか。2つ選びなさい。",
        "choices": ["「Apex テスト実行」ページ", "開発者コンソール の [Test Suite Run] パネル", "「Apex クラス」ページ", "開発者コンソールの [Tests] タブ"],
        "correct": ["「Apex クラス」ページ", "開発者コンソールの [Tests] タブ"],
        "explanations":["「Apex テスト実行」ページ", "開発者コンソール の [Test Suite Run] パネル", "「Apex クラス」ページ", "開発者コンソールの [Tests] タブ"],
        "descriptions":[
            "これは不正解です。「Apex テスト実行」ページではApex コードのテストを実行することはできますが、組織全体のコードカバレッジを表示する機能は提供していません。",
            "これは不正解です。開発者コンソールには[Test Suite Run] パネルというものは存在しません。テストスイートを実行する機能はありますが、それは[Test] タブまたはテストスイートの実行機能を通じてアクセスされます。",
            "これは正解です。「Apex クラス」ページには「組織のコードカバー率を見積る」というセクションがあり、組織全体のApexコードのカバレッジを確認することができます。",
            "これは正解です。開発者コンソールの [Tests] タブでは、テストの実行と、テストがカバーしているコード行、そして全体的なコードカバレッジを確認することができます。テスト実行の結果として得られるコードカバレッジの情報は、全体的なコードカバレッジを把握するのに役立ちます。"
        ]
    },
    {
        "number": "106",
        "question": "開発者は、CustomObject__cレコードが現在のユーザーと手動で共有されているかどうかを、Apexにおいてどのように判断しますか。",
        "choices": ["現在のユーザーのプロファイル設定を呼び出す", "レコードのisShared()メソッドを呼び出す", "CustomObject__shareをクエリする", "ロール階層をクエリする"],
        "correct": ["CustomObject__shareをクエリする"],
        "explanations":["現在のユーザーのプロファイル設定を呼び出す", "レコードのisShared()メソッドを呼び出す", "CustomObject__shareをクエリする", "ロール階層をクエリする"],
        "descriptions":[
            "これは不正解です。プロファイル設定はユーザーの権限やアクセスレベルを管理するものであり、特定のレコードが手動で共有されているかどうかを判断するための情報は含まれていません。",
            "これは不正解です。ApexにはisShared()というメソッドは存在しないため、この方法でレコードが共有されているかどうかを判断することはできません。",
            "これは正解です。Salesforceのオブジェクト共有モデルでは、手動で共有されたレコードは<ObjectName>__shareという名前の共有オブジェクトに保存されます。この共有オブジェクトをクエリすることで、特定のレコードが現在のユーザーと共有されているかどうかを判断することができます。",
            "これは不正解です。ロール階層は組織内のユーザー間の階層関係を示すものであり、特定のレコードが手動で共有されているかどうかの情報は含まれていません。"
        ]
    },
    {
        "number": "107",
        "question": "開発者がコントローラ拡張よりもカスタムコントローラを使用することを検討する理由は何ですか。",
        "choices": ["SOQLクエリのガバナ制限を引き上げるため", "ページのすべてのロジックを実装し、デフォルトのSalesforce機能を回避するため", "標準コントローラの組み込み機能を活用するため", "ユーザーの共有設定と権限を強制するため"],
        "correct": ["ページのすべてのロジックを実装し、デフォルトのSalesforce機能を回避するため"],
        "explanations":["SOQLクエリのガバナ制限を引き上げるため", "ページのすべてのロジックを実装し、デフォルトのSalesforce機能を回避するため", "標準コントローラの組み込み機能を活用するため", "ユーザーの共有設定と権限を強制するため"],
        "descriptions":[
            "これは不正解です。カスタムコントローラを使用しても、SOQLクエリのガバナ制限を引き上げることはできません。Salesforceのガバナ制限は、カスタムコントローラでもコントローラ拡張でも同じです。",
            "これは正解です。カスタムコントローラを使用する主な理由の1つは、ページのロジックを完全に制御し、デフォルトのSalesforceの動作を回避したい場合です。",
            "これは不正解です。標準コントローラの組み込み機能を活用する場合、コントローラ拡張を使用することが推奨されます。カスタムコントローラは、標準コントローラの機能から独立して動作します。",
            "これは不正解です。カスタムコントローラ自体は、ユーザーの共有設定や権限を強制する機能を提供しません。このような機能を実装するためには、Apexコード内で明示的にロジックを書く必要があります。"
        ]
    },
    {
        "number": "108",
        "question": "開発者は金融システムのApexクラスを実装しています。このクラスでは、変数creditAmountとdebtAmountは、一度値が代入されると変更できないようにする必要があります。値が1回しか代入されないようにするために、開発者が変数を宣言する方法はどれですか。2つ選びなさい。",
        "choices": ["staticキーワードを使用し、クラスのコンストラクタでその値を割り当てます。", "finalキーワードを使用し、クラスのコンストラクタでその値を割り当てます。", "staticキーワードを使用し、その値をstaticイニシャライザに割り当てます。", "finalキーワードを使用し、変数を宣言するときにその値を割り当てます。"],
        "correct": ["finalキーワードを使用し、クラスのコンストラクタでその値を割り当てます。", "finalキーワードを使用し、変数を宣言するときにその値を割り当てます。"],
        "explanations":["staticキーワードを使用し、クラスのコンストラクタでその値を割り当てます。", "finalキーワードを使用し、クラスのコンストラクタでその値を割り当てます。", "staticキーワードを使用し、その値をstaticイニシャライザに割り当てます。", "finalキーワードを使用し、変数を宣言するときにその値を割り当てます。"],
        "descriptions":[
            "これは不正解です。staticキーワードは変数がクラスレベルで一度だけ初期化されることを意味しますが、変数の値が変更できないことを保証するものではありません。",
            "これは正解です。finalキーワードは変数に値を一度だけ割り当てることを保証します。コンストラクタ内でfinal変数を初期化することにより、オブジェクトのインスタンスごとに一意の値を一度だけ割り当てることができます。",
            "これは不正解です。staticイニシャライザで初期化されたstatic変数は、クラスがロードされるときに一度だけ値が割り当てられますが、それはクラスのすべてのインスタンスで共有される値です。変数の値が変更できないことを保証するものではありません。",
            "これは正解です。finalキーワードは変数が初期化後に変更できないことを保証します。変数宣言時にfinal変数に値を割り当てることで、その値は変更不可能になります。"
        ]
    },
    {
        "number": "109",
        "question": "Apexで@InvocableMethodアノテーションを使用する場合の考慮事項は何ですか。3つ選びなさい。",
        "choices": ["@InvocableMethodアノテーションを使用するメソッドはstaticとして宣言する必要があります。", "@InvocableMethodアノテーションを使用するメソッドはPublicまたはGlobalとして宣言できます。", "@InvocableMethodアノテーションを使用するメソッドは複数の入力パラメータを持つことができます。", "@InvocableMethodアノテーションを使用するメソッドは戻り値を定義する必要があります。", "@InvocableMethodアノテーションを使用するメソッドは、Apexクラスごとに1つだけ定義できます。"],
        "correct": ["@InvocableMethodアノテーションを使用するメソッドはstaticとして宣言する必要があります。", "@InvocableMethodアノテーションを使用するメソッドはPublicまたはGlobalとして宣言できます。", "@InvocableMethodアノテーションを使用するメソッドは、Apexクラスごとに1つだけ定義できます。"],
        "explanations":["@InvocableMethodアノテーションを使用するメソッドはstaticとして宣言する必要があります。", "@InvocableMethodアノテーションを使用するメソッドはPublicまたはGlobalとして宣言できます。", "@InvocableMethodアノテーションを使用するメソッドは複数の入力パラメータを持つことができます。", "@InvocableMethodアノテーションを使用するメソッドは戻り値を定義する必要があります。", "@InvocableMethodアノテーションを使用するメソッドは、Apexクラスごとに1つだけ定義できます。"],
        "descriptions":[
            "これは正解です。このアノテーションが付与されたメソッドはクラスインスタンスを生成せずに呼び出すことができるよう、staticである必要があります。",
            "これは正解です。このアノテーションを使用するメソッドは外部のプロセスやアプリケーションから呼び出される可能性があるため、public または global アクセス修飾子で宣言される必要があります。これにより、Salesforceの自動化ツールなどの外部からメソッドをアクセスできるようになります。",
            "これは不正解です。 @InvocableMethodアノテーションを使用するメソッドは、単一のリスト型のパラメータのみを受け入れることができます。",
            "これは不正解です。 戻り値はオプションであり、必須ではありません。ただし、戻り値がある場合、特定の型のリストまたはリストのリストである必要があります。",
            "これは正解です。Apexクラス内で@InvocableMethodアノテーションを持つメソッドは一つだけに限定されます。これにより、特定のフローから呼び出されるべき唯一のメソッドが定義されます。"
        ]
    },
    {
        "number": "110",
        "question": "ApexPages.currentPage().getParameters()を使用してVisualforceコントローラからURLパラメータを取得する場合の戻り値のデータ型は何ですか。",
        "choices": ["List", "Map", "String[]", "Enum"],
        "correct": ["Map"],
        "explanations":["List", "Map", "String[]", "Enum"],
        "descriptions":[
            "これは不正解です。ApexPages.currentPage().getParameters()の戻り値はキーと値のペアのコレクションであり、単なる順序付けられたリストではありません。",
            "これは正解です。ApexPages.currentPage().getParameters()は、キー(パラメータ名)と値(パラメータの値)のペアのコレクション、つまりMap<String, String>として返されます。",
            "これは不正解です。戻り値は戻り値の配列ではなく、キーと値のペアのコレクションです。",
            "これは不正解です。Enumは、固定の名前付き値のセットを表すデータ型です。ApexPages.currentPage().getParameters()の戻り値はキーと値のペアのコレクションであり、Enumとは異なります。"
        ]
    },
    {
        "number": "111",
        "question": "開発者がVisualforceページでカスタムスタイルを使用する際に用いるものはどれですか。3つ選びなさい。",
        "choices": ["<apex:stylesheet>タグ", "インラインCSS", "<apex:style>タグ", "<apex:stylesheets>タグ", "静的リソース"],
        "correct": ["<apex:stylesheet>タグ", "インラインCSS", "静的リソース"],
        "explanations":["<apex:stylesheet>タグ", "インラインCSS", "<apex:style>タグ", "<apex:stylesheets>タグ", "静的リソース"],
        "descriptions":[
            "これは正解です。<apex:stylesheet>タグは、Visualforceページやコンポーネントにスタイルシートを適用するためのタグです。このタグを使用すると、指定されたスタイルシートへのリンクが生成されたHTMLページのhead要素に挿入されます。",
            "これは正解です。インラインCSSは、HTML要素内で直接スタイルを適用するための方法です。Visualforceページでもこの方法を使用して、特定の要素にスタイルを適用することができます。",
            "これは不正解です。Visualforceには<apex:style>タグは存在しません。",
            "これは不正解です。Visualforceには<apex:stylesheets>タグは存在しません。",
            "これは正解です。静的リソースを使用すると、画像、JavaScript、CSSなどのファイルをSalesforceにアップロードして、Visualforceページからそれらを参照することができます。これは再利用可能なリソースを管理する効率的な方法です。"
        ]
    },
    {
        "number": "112",
        "question": "@isTestアノテーションに関して正しい説明はどれですか。 3つ選びなさい。",
        "choices": ["@isTest(SeeAllData=false)が付けられたクラス内の@isTest(SeeAllData=true)が付けられたメソッドは、すべての組織データにアクセスできます。", "@isTest(SeeAllData=true)が付けられたクラス内の@isTest(SeeAllData=false)が付けられたメソッドは、すべての組織データにアクセスできます。", "テストメソッドを含むクラスは、@isTestアノテーションの有無に関係なく、Apexコードの制限にカウントされます。", "クラスが@isTest(SeeAllData=false)で付けられている場合でも、テスト内で製品と価格表は表示されます。", "クラスが@isTest(SeeAllData=false)で付けられている場合でも、テスト内でプロファイルは表示されます。"],
        "correct": ["@isTest(SeeAllData=false)が付けられたクラス内の@isTest(SeeAllData=true)が付けられたメソッドは、すべての組織データにアクセスできます。", "@isTest(SeeAllData=true)が付けられたクラス内の@isTest(SeeAllData=false)が付けられたメソッドは、すべての組織データにアクセスできます。", "クラスが@isTest(SeeAllData=false)で付けられている場合でも、テスト内でプロファイルは表示されます。"],
        "explanations":["@isTest(SeeAllData=false)が付けられたクラス内の@isTest(SeeAllData=true)が付けられたメソッドは、すべての組織データにアクセスできます。", "@isTest(SeeAllData=true)が付けられたクラス内の@isTest(SeeAllData=false)が付けられたメソッドは、すべての組織データにアクセスできます。", "テストメソッドを含むクラスは、@isTestアノテーションの有無に関係なく、Apexコードの制限にカウントされます。", "クラスが@isTest(SeeAllData=false)で付けられている場合でも、テスト内で製品と価格表は表示されます。", "クラスが@isTest(SeeAllData=false)で付けられている場合でも、テスト内でプロファイルは表示されます。"],
        "descriptions":[
            "これは正解です。メソッドレベルでの@isTest(SeeAllData=true)は、クラスレベルでの@isTest(SeeAllData=false)を上書きします。そのため、そのメソッドはすべての組織データにアクセスできます。",
            "これは正解です。クラスレベルでの@isTest(SeeAllData=true)が設定されている場合、メソッドレベルでの@isTest(SeeAllData=false)は無視され、そのメソッドはすべての組織データにアクセスできます。",
            "これは不正解です。@isTestアノテーションが付けられたクラスは、Apexコードの制限にカウントされません。",
            "これは不正解です。@isTest(SeeAllData=false)が指定されている場合、テストメソッドは組織の実データにアクセスできないようになります。製品と価格表も例外ではありません。",
            "これは正解です。@isTest(SeeAllData=false)が指定されている場合でも、一部のオブジェクト(例：UserやProfile)は例外としてアクセス可能です。"
        ]
    },
    {
        "number": "113",
        "question": "開発者は新しいカスタム例外クラスをどのように作成する必要がありますか。",
        "choices": ["public class CustomException extends Exception{}", "CustomException ex = new (CustomException)Exception();", "public class CustomException implements Exception{}", "(Exception)CustomException ex = new Exception();"],
        "correct": ["public class CustomException extends Exception{}"],
        "explanations":["public class CustomException extends Exception{}", "CustomException ex = new (CustomException)Exception();", "public class CustomException implements Exception{}", "(Exception)CustomException ex = new Exception();"],
        "descriptions":[
            "これは正解です。Apexでカスタム例外クラスを作成するための正しい方法は、Exceptionクラスを継承することです。この方法で、カスタム例外クラスを作成することができます。",
            "これは不正解です。このコードは、既存のExceptionオブジェクトをCustomExceptionタイプにキャストしようとしていますが、これは正しくありません。新しいカスタム例外をインスタンス化するには、new CustomException()を使用する必要があります。",
            "これは不正解です。Apexでは、例外クラスを作成するためにextendsキーワードを使用してExceptionクラスを継承する必要があります。implementsキーワードはインターフェースを実装するためのものであり、このコンテキストでは正しくありません。",
            "これは不正解です。このコードは、新しいExceptionオブジェクトを作成し、それをCustomExceptionタイプにキャストしようとしていますが、これは正しくありません。正しい方法は、new CustomException()を使用してカスタム例外をインスタンス化することです。"
        ]
    },
    {
        "number": "114",
        "question": "Universal Containers社は、サードパーティのJavaScriptフレームワークを使用して作成され、Visualforceページを使用して公開された多数のカスタムアプリケーションを持っています。\n同社は、これらのアプリケーションを更新して、Lightning Experienceの外観に似たスタイルを適用したいと考えています。ビジネス要求を最も迅速かつ効果的に満たすために、開発者は何をすべきですか。",
        "choices": ["定義で属性LightningStyleSheetsをtrueに設定します。", "カスタムアプリケーションで使用されるVisualforceページで、Lightning Experience、Lightning Communities、およびモバイルアプリで利用可能にするオプションを有効にします。", "Salesforce Lightning Design SystemのCSSスタイルシートをJavaScriptアプリケーションに組み込みます。", "すべてのVisualforceページをLightningコンポーネントとして書き直します。"],
        "correct": ["定義で属性LightningStyleSheetsをtrueに設定します。"],
        "explanations":["定義で属性LightningStyleSheetsをtrueに設定します。", "カスタムアプリケーションで使用されるVisualforceページで、Lightning Experience、Lightning Communities、およびモバイルアプリで利用可能にするオプションを有効にします。", "Salesforce Lightning Design SystemのCSSスタイルシートをJavaScriptアプリケーションに組み込みます。", "すべてのVisualforceページをLightningコンポーネントとして書き直します。"],
        "descriptions":[
            "これは正解です。lightningStylesheets属性をtrueに設定することで、VisualforceページにLightning Experienceのスタイルが適用され、開発者は迅速にLightning Experienceの外観を模倣することができます。この方法は、既存のVisualforceページのスタイルを変更する最も簡単で迅速な方法です。",
            "これは不正解です。このオプションは、VisualforceページをLightning Experienceやモバイルアプリで利用可能にするためのものであり、ページのスタイリングには影響しません。",
            "これは不正解です。Salesforce Lightning Design System (SLDS)を使用することで、Lightning Experienceの外観を模倣することは可能ですが、この方法はAの方法よりも時間がかかり、より複雑です。",
            "これは不正解です。すべてのVisualforceページをLightningコンポーネントとして書き直すことは、非常に時間がかかる作業であり、ビジネス要求を最も迅速に満たす方法とは言えません。"
        ]
    },
    {
        "number": "115",
        "question": "開発者は、ごみ箱に送られたレコードの監査証跡を作成する必要があります。 どのタイプのトリガーを作成するのが最も適切ですか。",
        "choices": ["after delete", "after undelete", "before undelete", "before delete"],
        "correct": ["after delete"],
        "explanations":["after delete", "after undelete", "before undelete", "before delete"],
        "descriptions":[
            "これは正解です。このトリガーはレコードが実際に削除された後に実行されます。監査証跡を作成する際には、削除の事実が確定した後に情報を記録する必要があります。このため、after deleteトリガーはレコードがごみ箱に移動された時点での詳細な情報を捕捉し、監査ログに記録するのに最適です。",
            "これは不正解です。after undeleteトリガーは、レコードがごみ箱から復元された後に実行されるため、削除時の監査証跡作成には不適切です。このシナリオでは、レコードの削除時点に焦点を当てる必要があり、復元プロセスは関連性がありません。",
            "これは不正解です。before undeleteトリガーは、レコードがごみ箱から復元される前に実行されます。削除時の監査証跡作成には関係がないため、このトリガーはこの場合には適切ではありません。",
            "これは不正解です。before deleteトリガーは、レコードが削除される前に実行されるため、削除が実際に完了したかどうかを監査するためには不適切です。削除の完了後に情報を記録するためには、after deleteトリガーの使用が適しています。"
        ]
    },
    {
        "number": "116",
        "question": "開発者は、ごみ箱から復元されるレコードの監査証跡を作成する必要があります。どのタイプのトリガーを作成するのが最も適切ですか。",
        "choices": ["before delete", "after delete", "before undelete", "after undelete"],
        "correct": ["after undelete"],
        "explanations":["before delete", "after delete", "before undelete", "after undelete"],
        "descriptions":[
            "これは不正解です。このトリガーはレコードが削除される前に実行されるので、この場合には関係ありません。",
            "これは不正解です。このトリガーはレコードが削除された後に実行されるので、ごみ箱からの復元プロセスには関与しません。",
            "これは不正解です。このトリガーはレコードがごみ箱から復元される前に実行されるため、監査証跡を作成するには、復元が完了した後の状態を捉える必要があるため適していません。",
            "これは正解です。このトリガーはレコードがごみ箱から復元された後に実行されるため、監査証跡を正確に記録するには最適です。このトリガー内で、復元されたレコードの情報を監査ログに記録することができます。"
        ]
    },
    {
        "number": "117",
        "question": "SalesforceのISVパートナーであるCloudKicks Fitnessは、管理パッケージアプリケーションを開発しています。ユーザーはアプリケーションモジュールの1つであるBodyfatというApexクラスとcalculateBodyfat()メソッドを使用して体脂肪を計算できます。製品の所有者は、ISVのパッケージ名前空間の外部でカスタマイザーを開発するときに、アプリケーション利用者がこのメソッドにアクセスできるようにしたいと考えています。パッケージ名前空間の外部でcalculateBodyFatメソッドにアクセスできるようにするには、開発者はどの手段を取る必要がありますか。",
        "choices": ["publicアクセス修飾子を使用してクラスとメソッドを宣言します。", "globalアクセス修飾子を使用してクラスとメソッドを宣言します。", "クラスをpublicとして宣言し、メソッドでglobalアクセス修飾子を使用します。", "クラスをpublicとして宣言し、メソッドでpublicアクセス修飾子を使用します。"],
        "correct": ["globalアクセス修飾子を使用してクラスとメソッドを宣言します。"],
        "explanations":["publicアクセス修飾子を使用してクラスとメソッドを宣言します。", "globalアクセス修飾子を使用してクラスとメソッドを宣言します。", "クラスをpublicとして宣言し、メソッドでglobalアクセス修飾子を使用します。", "クラスをpublicとして宣言し、メソッドでpublicアクセス修飾子を使用します。"],
        "descriptions":[
            "これは不正解です。public アクセス修飾子は、そのメソッドやクラスがパッケージの外部からアクセス可能であることを意味しません。同じ名前空間内、または無名名前空間内でのみアクセス可能です。",
            "これは正解です。global アクセス修飾子をクラスとメソッドに使用すると、それらは名前空間に関係なく、パッケージ外部からでもアクセス可能になります。これは他のSalesforce組織でメソッドを利用するための適切なアクセスレベルです。",
            "これは不正解です。クラスがpublicである場合、そのクラスのglobalメソッドは、パッケージの外部からアクセスできません。クラス自体もglobalである必要があります。",
            "これは不正解です。この宣言では、クラスもメソッドもパッケージの外部からはアクセスできません。パッケージの外部からアクセスするためには、クラスまたはメソッドにglobal 修飾子を使用する必要があります。"
        ]
    },
    {
        "number": "118",
        "question": "開発者が組織内でテストを実行するための方法は何ですか。3つ選びなさい。",
        "choices": ["Bulk API", "Tooling API", "設定メニュー", "Salesforce DX", "メタデータ API"],
        "correct": ["Tooling API", "設定メニュー", "Salesforce DX"],
        "explanations":["Bulk API", "Tooling API", "設定メニュー", "Salesforce DX", "メタデータ API"],
        "descriptions":[
            "これは不正解です。Bulk APIは、大量のレコードをSalesforceに挿入、更新、削除、またはエクスポートするために使用されます。このAPIはテスト実行とは無関係で、データ処理に特化しています。",
            "これは正解です。Tooling APIは、開発者がSalesforceのカスタマイズをプログラムで管理するためのAPIです。これには、Apexテストの実行などの開発タスクも含まれます。",
            "これは正解です。Salesforceの設定メニューから[Apex クラス]や[Apex テスト実行]にアクセスすることで、開発者はApexクラスのテストを実行できます。これはSalesforceのユーザーインタフェースを介して直接テストを行い、テスト結果を確認する方法です。",
            "これは正解です。Salesforce DXは、ソース駆動型の開発、バージョン管理、連続インテグレーションといったモダンな開発プラクティスをサポートするツールです。開発者はSalesforce DXを使用してテストを実行し、テスト結果を管理することができます。",
            "これは不正解です。メタデータ APIは、Salesforceのメタデータ(例えばレイアウト、オブジェクト、フィールドなど)をプログラムで管理するために使用されます。テスト実行には関連がなく、主にメタデータの設定や更新に使われます。"
        ]
    },
    {
        "number": "119",
        "question": "開発者は、新しいApexクラスをテストするために、特定の項目値を持つレコードを用意する必要があります。開発者は、データがテストで利用可能であることを確認するために何をすべきですか。",
        "choices": ["匿名Apexを使用して、必要なデータを作成する。", "SOQLを使用して、必要なデータを組織にクエリする。", "Test.loadData()を使用し、静的リソースでCSVファイルを参照する。", "Test.loadData()を使用し、ドキュメント内のJSONファイルを参照する。"],
        "correct": ["Test.loadData()を使用し、静的リソースでCSVファイルを参照する。"],
        "explanations":["匿名Apexを使用して、必要なデータを作成する。", "SOQLを使用して、必要なデータを組織にクエリする。", "Test.loadData()を使用し、静的リソースでCSVファイルを参照する。", "Test.loadData()を使用し、ドキュメント内のJSONファイルを参照する。"],
        "descriptions":[
            "これは不正解です。匿名Apexは、本番環境やサンドボックス環境で直接スクリプトを実行するために使われます。テストクラス内でテストデータを準備する際には、テストメソッド内でデータを作成することが一般的です。匿名Apexは、テストの実行中にデータを作成するための適切な手段ではありません。",
            "これは不正解です。Apexテストメソッドは、デフォルトでテスト実行の際に本番環境のデータにアクセスできないため、SOQLを使用して既存のデータをクエリすることはできません。テストメソッドは隔離された環境で実行されるため、テスト用のデータはテストメソッド内で作成する必要があります。",
            "これは正解です。Test.loadData() メソッドは、静的リソースに格納されたCSVファイルからテストデータをロードするために使用されます。これにより、複雑なテストデータを簡単に準備することができ、テストの再現性と保守性が向上します。",
            "これは不正解です。Test.loadData() メソッドはCSVファイルのデータをロードするために使用されますが、JSONファイルを直接ロードする機能はありません。静的リソースからデータをロードする場合、データはCSV形式である必要があります。"
        ]
    },
    {
        "number": "120",
        "question": "有効なApexの代入はどれですか。",
        "choices": ["Integer x = 5*1.0;", "Integer x = 5.0;", "Double x = 5;", "Float x = 5.0;"],
        "correct": ["Double x = 5;"],
        "explanations":["Integer x = 5*1.0;", "Integer x = 5.0;", "Double x = 5;", "Float x = 5.0;"],
        "descriptions":[
            "これは不正解です。5*1.0の結果は5.0という浮動小数点数になります。Apexでは、浮動小数点数を整数型(Integer)に直接代入することは許可されていません。これは、データの精度の損失を防ぐためのものです。例えば、5.9という値を整数型に代入しようとすると、小数点以下の値が切り捨てられ、データの精度が失われる可能性があります。",
            "これは不正解です。5.0は浮動小数点数です。上記と同様の理由で、浮動小数点数を整数型に直接代入することは許可されていません。",
            "これは正解です。整数値5をDouble型の変数に代入することは許可されています。Apexでは、整数を浮動小数点数型に代入する際の暗黙的な型変換が許可されています。",
            "これは不正解です。ApexにはFloatというデータ型は存在しないためです。Apexで浮動小数点数を扱う場合は、Double型を使用します。"
        ]
    },
    {
        "number": "121",
        "question": "ApexとVisualforceページを使用する場合、MVCアーキテクチャのモデルを表すコードのタイプはどれですか。",
        "choices": ["SOQLを使用して取引先レコードのリストをクエリするコントローラ拡張メソッド", "取引先レコードのリストを保存するコントローラ拡張メソッド", "コントローラ拡張メソッドから返された取引先レコードのリスト", "取引先レコードのリストを処理するカスタムJavaScript"],
        "correct": ["コントローラ拡張メソッドから返された取引先レコードのリスト"],
        "explanations":["SOQLを使用して取引先レコードのリストをクエリするコントローラ拡張メソッド", "取引先レコードのリストを保存するコントローラ拡張メソッド", "コントローラ拡張メソッドから返された取引先レコードのリスト", "取引先レコードのリストを処理するカスタムJavaScript"],
        "descriptions":[
            "これは不正解です。このメソッドはデータを取得するロジックを含むため、MVCのコントローラの部分に該当します。",
            "これは不正解です。このメソッドはデータを保存するロジックを含むため、MVCのコントローラの部分に該当します。",
            "これは正解です。このリストはデータそのものを表しているため、MVCのモデルの部分に該当します。",
            "これは不正解です。このJavaScriptはデータの処理や表示のロジックを含むため、MVCのコントローラやビューの部分に該当する可能性がありますが、モデルの部分には該当しません。"
        ]
    },
    {
        "number": "122",
        "question": "開発者がトリガーでApexヒープ制限のエラーに遭遇した場合、このエラーを回避する方法はどれですか。 2つ選びなさい。",
        "choices": ["変数を宣言するときにtransientキーワードを使用する。", "関連するオブジェクトを更新するときに、関連するオブジェクトの項目をクエリしてコレクションに保存する。", "使用後にコレクションを削除するか、nullに設定する。", "大きなクエリ結果を単一のコレクションに割り当ててコレクションをループする代わりに、SOQLのループを使用する。"],
        "correct": ["使用後にコレクションを削除するか、nullに設定する。", "大きなクエリ結果を単一のコレクションに割り当ててコレクションをループする代わりに、SOQLのループを使用する。"],
        "explanations":["変数を宣言するときにtransientキーワードを使用する。", "関連するオブジェクトを更新するときに、関連するオブジェクトの項目をクエリしてコレクションに保存する。", "使用後にコレクションを削除するか、nullに設定する。", "大きなクエリ結果を単一のコレクションに割り当ててコレクションをループする代わりに、SOQLのループを使用する。"],
        "descriptions":[
            "これは不正解です。transient キーワードはVisualforceページのビューステートサイズを削減するため使用されますが、Apexのヒープ制限には直接関係ありません。",
            "これは不正解です。関連するオブジェクトの項目をクエリしてコレクションに保存するだけでは、ヒープ制限の問題を解決するわけではありません。",
            "これは正解です。コレクションからアイテムを削除することで、ランタイム中のヒープサイズを削減することができます。",
            "これは正解です。SOQL for ループは、クエリの結果を直接ループするための特別な構文です。この方法では、クエリの結果は一度にすべてメモリにロードされず、必要に応じて少しずつロードされます。これにより、大量のレコードを返すクエリでもヒープ制限を超えるリスクが低くなります。一方、通常の方法では、クエリが非常に多くのレコードを返す場合、すべてのレコードがメモリに格納されるため、ヒープ制限を超える可能性があります。"
        ]
    },
    {
        "number": "123",
        "question": "プラットフォーム開発者は、レコードが特定のレコードタイプに割り当てられている場合にのみ実行するApexメソッドを作成する必要があります。開発者が必要なレコードタイプIDをレコードタイプ名で動的に決定できる方法はどれですか。2つ選びなさい。",
        "choices": ["SOAP APIへのアウトバウンドWebサービス呼び出しを行う", "DescribeSObjectResultクラスでgetRecordTypeInfosByDeveloperNameメソッドを使用する", "Apexクラスの定数としてIDをハードコードする", "RecordTypeオブジェクトでSOQLクエリを実行する"],
        "correct": ["DescribeSObjectResultクラスでgetRecordTypeInfosByDeveloperNameメソッドを使用する", "RecordTypeオブジェクトでSOQLクエリを実行する"],
        "explanations":["SOAP APIへのアウトバウンドWebサービス呼び出しを行う", "DescribeSObjectResultクラスでgetRecordTypeInfosByDeveloperNameメソッドを使用する", "Apexクラスの定数としてIDをハードコードする", "RecordTypeオブジェクトでSOQLクエリを実行する"],
        "descriptions":[
            "これは不正解です。SOAP APIは外部システムとSalesforceとの間でデータを交換するために使いますが、Salesforce内で動的にレコードタイプIDを取得するのには適していません。",
            "これは正解です。DescribeSObjectResultクラスのgetRecordTypeInfosByDeveloperNameメソッドを使用することで、開発者名を基にレコードタイプの情報を動的に取得することができます。",
            "これは不正解です。IDをハードコードすると、異なる環境や組織間での移行時に問題が発生する可能性があります。また、レコードタイプが変更された場合や削除された場合に、コードの修正が必要になる可能性があります。",
            "これは正解です。RecordType オブジェクトを使用してSOQLクエリを実行することで、特定のオブジェクトのレコードタイプのIDを動的に取得することができます。"
        ]
    },
    {
        "number": "124",
        "question": "Visualforceページで外部CSSからのスタイリングが必要な場合、開発者はどのタグを含める必要がありますか。",
        "choices": ["apex:includeStyles", "apex:includeScript", "apex:require", "apex:stylesheet"],
        "correct": ["apex:stylesheet"],
        "explanations":["apex:includeStyles", "apex:includeScript", "apex:require", "apex:stylesheet"],
        "descriptions":[
            "これは不正解です。apex:includeStyles というタグはSalesforceのVisualforceには存在しません。",
            "これは不正解です。apex:includeScript タグは、Visualforce ページで使用できる JavaScript ライブラリへのリンクを提供します。このタグを使用すると、指定されたJavaScriptファイルをVisualforceページに含めることができます。しかし、このタグはCSSのスタイリングには使用されません。",
            "これは不正解です。apex:require というタグはSalesforceのVisualforceには存在しません。",
            "これは正解です。apex:stylesheet タグを使用すると、Visualforce ページでコンポーネントにスタイルを適用するためのスタイルシートへのリンクを提供します。このタグのvalue属性には、スタイルシートファイルのURLを指定します。この方法を使用すると、外部のCSSファイルをVisualforceページにリンクすることができます。"
        ]
    },
    {
        "number": "125",
        "question": "Apexクラスのプライベートメソッドの単体テストをどのように作成する必要がありますか。",
        "choices": ["SeeAllDataアノテーションを使用します", "Apexクラスにテストメソッドを追加します", "TestVisibleアノテーションを使用します", "Apexクラスをグローバルにします"],
        "correct": ["TestVisibleアノテーションを使用します"],
        "explanations":["SeeAllDataアノテーションを使用します", "Apexクラスにテストメソッドを追加します", "TestVisibleアノテーションを使用します", "Apexクラスをグローバルにします"],
        "descriptions":[
            "これは不正解です。@SeeAllDataは、テストメソッドが実際の組織データにアクセスできるかどうかを制御するためのものです。privateメソッドのテストとは関係ありません。",
            "これは不正解です。テストメソッドは、通常、別のテストクラスに含まれています。また、テストメソッド内からprivateメソッドを直接呼び出すことはできません。",
            "これは正解です。@TestVisibleをprivateメソッドの前に配置することで、そのメソッドはテストクラスからアクセス可能になります。これにより、privateメソッドの単体テストを書くことができます。",
            "これは不正解です。Apexクラスをグローバルにすることは、privateメソッドのテストのための適切な方法ではありません。グローバルなクラスは、任意のApexコードからアクセスできるようになりますが、これは通常、APIや他のパッケージからのアクセスが必要な場合にのみ行われます。"
        ]
    },
    {
        "number": "126",
        "previous-code": [
            "public class InsuranceRates{",
            "    public static final Decimal smokerCharge = 0.01;",
            "}\n",
            "trigger ContactTrigger on Contact(before insert){",
            "    InsuranceRates rates = new InsuranceRates();",
            "    Decimal baseCost = XXX;",
            "}"
        ],
        "question": "以上のクラスとトリガーのコードがあります。\nbaseCost変数にクラス変数smokerChargeの値を設定するために、開発者はXXXにどのコードを挿入する必要がありますか。",
        "choices": ["rates.smokerCharge", "InsuranceRates.smokerCharge", "ContactTrigger.InsuranceRates.smokerCharge", "rates.getSmokerCharge()"],
        "correct": ["InsuranceRates.smokerCharge"],
        "explanations":["rates.smokerCharge", "InsuranceRates.smokerCharge", "ContactTrigger.InsuranceRates.smokerCharge", "rates.getSmokerCharge()"],
        "descriptions":[
            "これは不正解です。smokerChargeはstatic変数であるため、クラスのインスタンスを使用してアクセスすることはできません。",
            "これは正解です。smokerChargeはstatic変数であるため、クラス名を使用して直接アクセスできます。",
            "これは不正解です。このようなネストされたクラスの参照は正しくありません。また、ContactTriggerトリガー内でInsuranceRatesクラスをネストしているわけではありません。",
            "これは不正解です。示されたコードにはgetSmokerCharge()というメソッドは存在しないため、この方法でsmokerChargeにアクセスすることはできません。"
        ]
    },
    {
        "number": "127",
        "question": "Universal Containers社には、特定のアカウントによってレンタルされているすべてのContainer__cのテーブルを表示するVisualforceページがあります。一部の顧客が100,000を超えるコンテナをレンタルしているため、ビューステートの最大制限エラーとなります。ページの読み込みエラーを解決するために、開発者はVisualforceページについて何を変更する必要がありますか。",
        "choices": ["SOQLのOFFSETでJavaScript Remotingを使用します", "StandardSetControllerを使用してページネーションを実装します", "遅延読み込みと一時的なリスト変数を使用します", "OffsetControllerを使用してページネーションを実装します"],
        "correct": ["StandardSetControllerを使用してページネーションを実装します"],
        "explanations":["SOQLのOFFSETでJavaScript Remotingを使用します", "StandardSetControllerを使用してページネーションを実装します", "遅延読み込みと一時的なリスト変数を使用します", "OffsetControllerを使用してページネーションを実装します"],
        "descriptions":[
            "これは不正解です。JavaScript Remotingはクライアント側での非同期データ取得に使用され、ビューステートのサイズを減らすのに役立ちますが、SOQLのOFFSET句には2000レコードまでの制限があり、100,000を超えるような大規模なデータセットでは使えません。",
            "これは正解です。StandardSetControllerは、大量のデータを扱うVisualforceページでページネーションを実装するためのものです。これにより、一度に表示されるレコードの数を制限し、ビューステートの制限を超えることなくページを表示することができます。",
            "これは不正解です。遅延読み込みはデータを必要に応じてロードする技術で、ビューステートのサイズを減らすことができます。しかし、これだけではビューステートの最大制限エラーを根本から解決するには不十分です。",
            "これは不正解です。OffsetControllerというものは、Salesforceの標準のクラスやコンポーネントとして存在しません。"
        ]
    },
    {
        "number": "128",
        "question": "Universal Containers社は、新しいSalesforceアプリケーションを構築するために、宣言型開発のみを使用することを決定しました。アプリケーションのデータベースレイヤーを構築するために使用すべきオプションはどれですか。3つ選びなさい。",
        "choices": ["フロー", "積み上げ集計項目", "トリガー", "リレーションシップ", "カスタムオブジェクトとカスタム項目"],
        "correct": ["積み上げ集計項目", "リレーションシップ", "カスタムオブジェクトとカスタム項目"],
        "explanations":["フロー", "積み上げ集計項目", "トリガー", "リレーションシップ", "カスタムオブジェクトとカスタム項目"],
        "descriptions":[
            "これは不正解です。フローはSalesforceの強力な自動化ツールであり、複雑なビジネスロジックやユーザーインタラクションを視覚的に設計するのに使用されます。しかし、フローは主にプロセス自動化やユーザー操作のガイドに焦点を当てているため、データベースレイヤーの構築そのものとは直接関連していません。フローはユーザーのアクションに応じて特定の操作を実行するために使用され、データベースの構造やデータの格納方法を定義するものではありません。",
            "これは正解です。積み上げ集計項目は宣言型機能で、関連オブジェクトのデータを集計して親オブジェクトに表示します。これにより、コードを書かずに関連データの集計を実現できます。",
            "これは不正解です。トリガーはApexコードを使用して特定の条件で自動的にアクションを実行するために使用され、宣言型開発ではなく、プログラマティックな開発手法に分類されます。",
            "これは正解です。主従関係や参照関係などのリレーションシップは、異なるオブジェクト間の関連を定義し、複雑なデータ構造を宣言型の方法で構築するのに役立ちます。",
            "これは正解です。カスタムオブジェクトとカスタム項目は、特定のビジネス要件に合わせて新しいデータ構造を宣言型で作成する基本的な方法です。"
        ]
    },
    {
        "number": "129",
        "question": "開発者は、Lightningコンポーネントが取引先責任者のレコードを検索するために使用できるApexクラス「ContactController」を作成する必要があります。Lightningコンポーネントのユーザーは、自分がアクセス権を持つ取引先責任者のレコードのみを検索できるようにするべきです。正しくレコードを制限するための方法は何ですか。2つ選びなさい。",
        "choices": ["public class ContactController", "public with sharing class ContactController", "public without sharing class ContactController", "public inherited sharing class ContactController"],
        "correct": ["public with sharing class ContactController", "public inherited sharing class ContactController"],
        "explanations":["public class ContactController", "public with sharing class ContactController", "public without sharing class ContactController", "public inherited sharing class ContactController"],
        "descriptions":[
            "これは不正解です。この宣言だけではレコードへのアクセス制限は明示的には行われません。このクラスは、呼び出し元のクラスやトリガーの共有設定に依存します。",
            "これは正解です。「with sharing」キーワードを使用すると、このクラスは実行ユーザーの共有設定を尊重します。つまり、ユーザーがアクセスできるレコードのみを検索や操作できるようになります。",
            "これは不正解です。「without sharing」キーワードを使用すると、このクラスは実行ユーザーの共有設定を無視します。これは、ユーザーがアクセスできないレコードにもアクセスできる可能性があるため、この要件には適していません。",
            "これは正解です。inherited sharingキーワードを使用すると、クラスは親クラスまたは呼び出し元の共有設定を継承します。これにより、クラスが他の「with sharing」クラスから呼び出される場合、ユーザーの共有設定を尊重することができます。このキーワードは、クラスが共有設定を持たない場合や、他のクラスから呼び出される場合に特に有用です。"
        ]
    },
    {
        "number": "130",
        "question": "匿名ブロックで実行されるApexコードに関して正しい答えはどれですか。2つ選びなさい。",
        "choices": ["コードは、runAs()ステートメントで指定されたユーザーの権限で実行されます", "コードは、ログインしているユーザーの権限で実行されます", "コードは、すべてのオブジェクトとフィールドにアクセスできるシステムモードで実行されます", "すべてのDML操作は自動的にロールバックされます", "成功したDML操作は自動的にコミットされます"],
        "correct": ["コードは、ログインしているユーザーの権限で実行されます", "成功したDML操作は自動的にコミットされます"],
        "explanations":["コードは、runAs()ステートメントで指定されたユーザーの権限で実行されます", "コードは、ログインしているユーザーの権限で実行されます", "コードは、すべてのオブジェクトとフィールドにアクセスできるシステムモードで実行されます", "すべてのDML操作は自動的にロールバックされます", "成功したDML操作は自動的にコミットされます"],
        "descriptions":[
            "これは不正解です。runAs()はテストメソッド内でのみ使用され、匿名ブロックでは使用されません。",
            "これは正解です。匿名ブロックは現在ログインしているユーザーの権限で実行されます。",
            "これは不正解です。匿名ブロックは現在のユーザーの権限で実行されるため、ユーザーのアクセス権限に違反するコードはコンパイルできない場合があります。",
            "これは不正解です。DML操作は、匿名ブロックの実行が失敗した場合のみロールバックされます。",
            "これは正解です。匿名ブロック内でのDML操作が成功した場合、その変更は自動的にデータベースにコミットされます。"
        ]
    },
    {
        "number": "131",
        "question": "開発者は、maxAttempts と呼ばれる整数変数を持っています。開発者は、一度maxAttemptsが初期化されると、トリガー実行の間で変数の状態を共有しながら、Apex処理の間、その値を確実に保持する必要があります。これらの要求を満たすために、開発者はどのようにmaxAttemptsを宣言する必要がありますか。",
        "choices": ["staticキーワードとfinalキーワードを使用して、maxattemptsを定数として宣言する。", "maxattempts をヘルパークラスの変数として宣言する。", "maxattempts をヘルパークラスの private static 変数として宣言する。", "maxattempts をトリガー定義のメンバ変数として宣言する。"],
        "correct": ["staticキーワードとfinalキーワードを使用して、maxattemptsを定数として宣言する。"],
        "explanations":["staticキーワードとfinalキーワードを使用して、maxattemptsを定数として宣言する。", "maxattempts をヘルパークラスの変数として宣言する。", "maxattempts をヘルパークラスの private static 変数として宣言する。", "maxattempts をトリガー定義のメンバ変数として宣言する。"],
        "descriptions":[
            "これは正解です。static finalを使用することで、変数を定数として宣言し、一度初期化されるとその後変更することができなくなります。",
            "これは不正解です。この方法だけでは変数の値が変更されないことを保証できません。",
            "これは不正解です。private staticだけでは、変数の値が変更されないことを保証できません。",
            "これは不正解です。トリガーのメンバ変数として宣言しても、変数の値が変更されないことを保証できません。"
        ]
    },
    {
        "number": "132",
        "question": "次のSOSL検索によって返されるデータ型は何ですか。",
        "choices": ["List<List<Account>, List<Opportunity>>", "Map<sObject, sObject>", "List<List<sObject>>", "Map<Id, sObject>"],
        "correct": ["List<List<sObject>>"],
        "explanations":["List<List<Account>, List<Opportunity>>", "Map<sObject, sObject>", "List<List<sObject>>", "Map<Id, sObject>"],
        "descriptions":[
            "これは不正解です。SOSL検索の結果は、異なるsObjectタイプごとにリストのリストとして返されますが、この具体的なデータ型は正確ではありません。",
            "これは不正解です。SOSLの結果はマップ型では返されません。",
            "これは正解です。SOSLクエリは複数のオブジェクトタイプにわたる検索を行うことができ、結果はList<List<sObject>>の形式で返されます。外側のListは異なるオブジェクトタイプごとの検索結果を含み、内側のListは特定のオブジェクトタイプに対する検索結果です。",
            "これは不正解です。SOSLの結果はマップ型では返されません。"
        ]
    },
    {
        "number": "133",
        "question": "ApexクラスをRESTfulWebサービスとして公開するアノテーションはどれですか。",
        "choices": ["@RemoteAction", "@HttpInvocable", "@AuraEnabled", "@RestResource"],
        "correct": ["@RestResource"],
        "explanations":["@RemoteAction", "@HttpInvocable", "@AuraEnabled", "@RestResource"],
        "descriptions":[
            "これは不正解です。@RemoteActionはVisualforceページからJavaScriptを介してApexメソッドを非同期で呼び出すためのアノテーションです。RESTful Webサービスとは関係ありません。",
            "これは不正解です。@Httplnvocableは存在しないアノテーションです。",
            "これは不正解です。@AuraEnabledは、Lightningコンポーネント(Lightning Web コンポーネントとAura コンポーネントの両方)からApexメソッドをアクセスするためのアノテーションです。RESTful Webサービスとしての公開には使用されません。",
            "これは正解です。@RestResourceはApexクラスをRESTful Webサービスとして公開するためのクラスレベルのアノテーションです。このアノテーションを使用することで、特定のURL経由でApexメソッドにアクセスできるようになります。"
        ]
    },
    {
        "number": "134",
        "question": "クロスオブジェクト数式項目に関する記述のうち、正しいものは どれですか。3つ選びなさい。",
        "choices": ["クロスオブジェクト数式項目は、最大10リレーション離れているオブジェクトの項目を参照できます", "クロスオブジェクト数式項目は、主従関係または参照関係の項目を参照できます", "クロスオブジェクト数式項目は、子項目を参照して平均を実行できます", "クロスオブジェクト数式項目は、ユーザーがアクセスできないデータをレコードに公開する可能性があります", "クロスオブジェクト数式項目は積み上げ集計項目を参照できます"],
        "correct": ["クロスオブジェクト数式項目は、最大10リレーション離れているオブジェクトの項目を参照できます", "クロスオブジェクト数式項目は、主従関係または参照関係の項目を参照できます", "クロスオブジェクト数式項目は、ユーザーがアクセスできないデータをレコードに公開する可能性があります"],
        "explanations":["クロスオブジェクト数式項目は、最大10リレーション離れているオブジェクトの項目を参照できます", "クロスオブジェクト数式項目は、主従関係または参照関係の項目を参照できます", "クロスオブジェクト数式項目は、子項目を参照して平均を実行できます", "クロスオブジェクト数式項目は、ユーザーがアクセスできないデータをレコードに公開する可能性があります", "クロスオブジェクト数式項目は積み上げ集計項目を参照できます"],
        "descriptions":[
            "これは正解です。クロスオブジェクト数式項目は最大10リレーション離れたオブジェクトの項目を参照します。",
            "これは正解です。クロスオブジェクト数式項目は主従関係の従側や参照関係の項目を参照します。",
            "これは不正解です。クロスオブジェクト数式項目は子項目を直接参照しての平均計算を行えません。",
            "これは正解です。ユーザーがアクセス権限を持たないオブジェクトレコードの項目も、クロスオブジェクト数式項目を通じて表示されます。",
            "これは不正解です。クロスオブジェクト数式項目は積み上げ集計項目を参照できません。"
        ]
    },
    {
        "number": "135",
        "question": "開発者はループ処理で、リスト内の各取引先責任者をチェックします。”Boss”というタイトルの取引先責任者が見つかった場合、Apexのメソッドはforループの外側のコードの最初の行にジャンプする必要があります。要件を実装するためのコーディングはどれですか。",
        "choices": ["break;", "continue;", "next;", "exit;"],
        "correct": ["break;"],
        "explanations":["break;", "continue;", "next;", "exit;"],
        "descriptions":[
            "これは正解です。Apexにおいてbreak;はループを完全に終了し、ループの後の次の行にジャンプします。今回の場合、”Boss”というタイトルの取引先責任者が見つかったときにループを終了します。",
            "これは不正解です。Apexにおいてcontinue;は現在のループのイテレーションをスキップし、次のイテレーションにジャンプします。今回の場合、”Boss”というタイトルの取引先責任者が見つかったときに、そのイテレーションをスキップして次のイテレーションに進みます。",
            "これは不正解です。Apexにはnextというキーワードは存在しません。",
            "これは不正解です。Apexにはexitというキーワードは存在しません。"
        ]
    },
    {
        "number": "136",
        "previous-code": [
            "Account myAccount = [SELECT Id, Name FROM Account];"
        ],
        "question": "以上のApexステートメントがあります。\nSOQLクエリによって複数のAccountが返された場合、何が発生しますか。",
        "choices": ["変数myAccountは自動的にListデータ型にキャストされます。", "最初に返された Account が myAccount に代入されます。", "クエリは失敗し、エラーがデバッグログに書き込まれます。", "未処理の例外がスローされ、コードが終了します。"],
        "correct": ["未処理の例外がスローされ、コードが終了します。"],
        "explanations":["変数myAccountは自動的にListデータ型にキャストされます。", "最初に返された Account が myAccount に代入されます。", "クエリは失敗し、エラーがデバッグログに書き込まれます。", "未処理の例外がスローされ、コードが終了します。"],
        "descriptions":[
            "これは不正解です。Apexでは自動的に変数のデータ型を変更することはできません。",
            "これは不正解です。単一のsObject変数に複数のレコードを代入することはできません。",
            "これは不正解です。Apexでは、SOQLクエリが複数のレコードを返す場合、単一のsObject変数に代入しようとすると「List has more than 1 row for assignment to SObject」という未処理の例外がスローされます。この例外はコードの実行を中断させると同時に、デバッグログに例外情報として記録されます。",
            "これは正解です。SOQLクエリが複数のレコードを返す場合、単一のsObject変数に代入しようとすると、「List has more than 1 row for assignment to SObject」という未処理の例外がスローされ、コードの実行が中断されます。"
        ]
    },
    {
        "number": "137",
        "question": "開発者は、Apexテストメソッドがサンドボックスで失敗することに気づきました。問題を特定するために、開発者はテストメソッド内のコードをコピーし、開発者コンソールの匿名実行ツールを使用してコードを実行したところ、コードは例外やエラーなしで実行されます。テストメソッドがサンドボックスで失敗し、開発者コンソールで合格したのはなぜですか。",
        "choices": ["テストメソッドは @future メソッドを呼び出しているため", "テストメソッドのコードに構文エラーがあるため", "テストメソッドは、特定のユーザーとして実行するためにSystem.runAsを使用しないため", "テストメソッドはサンドボックス内の既存のデータに依存しているため"],
        "correct": ["テストメソッドはサンドボックス内の既存のデータに依存しているため"],
        "explanations":["テストメソッドは @future メソッドを呼び出しているため", "テストメソッドのコードに構文エラーがあるため", "テストメソッドは、特定のユーザーとして実行するためにSystem.runAsを使用しないため", "テストメソッドはサンドボックス内の既存のデータに依存しているため"],
        "descriptions":[
            "これは不正解です。@future メソッドは非同期で実行されるため、テストメソッドの実行とは独立して動作します。しかし、今回の問題の直接的な原因とは考えられません。",
            "これは不正解です。構文エラーが存在する場合、開発者コンソールの匿名実行ツールでもエラーが発生するはずです。",
            "これは不正解です。System.runAsを使用しなかった場合、特定のユーザーコンテキストでの実行が問題になることがありますが、開発者コンソールでの匿名実行は実行ユーザーの権限で行われるため、この点が原因でテストがサンドボックスで失敗するとは限りません。",
            "これは正解です。Apexテストメソッドはデフォルトで隔離されたテスト環境で実行され、既存のデータにアクセスすることはありません(@isTest(SeeAllData=true)が設定されていない限り)。もしテストメソッドが既存のデータに依存している場合、サンドボックス内でそのデータが欠如しているか異なっている可能性があり、そのために失敗することがあります。しかし、開発者コンソールで匿名実行を行う場合は、実際の環境データを用いて実行されるため、問題が発生しなかった可能性があります。"
        ]
    },
    {
        "number": "138",
        "question": "ある開発者は、自分の組織でカスタムページがロードされたときにパフォーマンスの問題の原因を突き止めるためにトラブルシューティングを行う必要があります。開発者がトラブルシューティングに使用すべきツールはどれか。",
        "choices": ["Salesforce CLI", "AppExchange", "開発者コンソール", "Visual Studio Code IDE"],
        "correct": ["開発者コンソール"],
        "explanations":["Salesforce CLI", "AppExchange", "開発者コンソール", "Visual Studio Code IDE"],
        "descriptions":[
            "これは不正解です。Salesforce CLIは、Salesforce DXの一部として提供されるコマンドラインツールであり、主にメタデータの操作やスクリプトの実行などのタスクに使用されます。ページロードのパフォーマンス問題のトラブルシューティングには直接的には関係ありません。",
            "これは不正解です。AppExchangeはSalesforceのマーケットプレイスであり、アプリケーションやコンポーネントの公開や取得を行う場所です。パフォーマンスの問題のトラブルシューティングには使用されません。",
            "これは正解です。開発者コンソールは、Apexコードの実行、SOQLクエリの実行、ログの確認、パフォーマンスの問題の診断など、Salesforce開発者が使用する多くのツールを提供しています。特に、ログの詳細な分析や実行時間の計測など、パフォーマンスの問題を特定するための機能が含まれています。",
            "これは不正解です。Visual Studio Code IDEは、Salesforce開発のための強力なエディターであり、Salesforce Extensionsを使用してSalesforce DXと統合できます。しかし、直接的なパフォーマンスのトラブルシューティングのツールとしては使用されません。"
        ]
    },
    {
        "number": "139",
        "question": "スキーマビルダーを使用して開発者が実行できるアクションはどれですか。2つ選びなさい。",
        "choices": ["カスタムオブジェクトを作成し、そのオブジェクトに参照関係を定義する", "標準オブジェクトとシステムオブジェクトのみを含むビューを表示する", "カスタム項目を作成し、既存のページレイアウトに自動的に追加する", "項目のないオブジェクトとリレーションのビューを作成する"],
        "correct": ["カスタムオブジェクトを作成し、そのオブジェクトに参照関係を定義する", "標準オブジェクトとシステムオブジェクトのみを含むビューを表示する"],
        "explanations":["カスタムオブジェクトを作成し、そのオブジェクトに参照関係を定義する", "標準オブジェクトとシステムオブジェクトのみを含むビューを表示する", "カスタム項目を作成し、既存のページレイアウトに自動的に追加する", "項目のないオブジェクトとリレーションのビューを作成する"],
        "descriptions":[
            "これは正解です。スキーマビルダーを使用して、カスタムオブジェクトを作成し、そのオブジェクトに対して参照関係や主従関係を定義することができます。",
            "これは正解です。スキーマビルダーはオブジェクトとその関係を視覚的に表示するツールであり、標準オブジェクトやシステムオブジェクトを含むビューを表示することができます。",
            "これは不正解です。スキーマビルダーを使用してカスタム項目を作成することはできますが、それを既存のページレイアウトに自動的に追加する機能は提供していません。",
            "これは不正解です。項目のないオブジェクトは実際には存在しないため、そのようなオブジェクトを作成することはできません。スキーマビルダーはオブジェクトとその関係を視覚的に表示するツールであり、特定の「ビュー」を作成する機能は提供していません。"
        ]
    },
    {
        "number": "140",
        "question": "開発者は、リードオブジェクトにbefore insertトリガーを使用して、Territory__c.PostalCode__cがLead.PostalCodeと一致するTerritory__cオブジェクトを取得します。しかし、開発者がデータローダーを使用して10,000のリードレコードを挿入すると、コードが失敗します。\nどのコード行がコードブロックの失敗の原因となっていますか。",
        "following-code": [
            "for (Lead l : Trigger.new) {",
            "    if (l.PostalCode != null) {",
            "        List<Territory__c> terrList = [SELECT Id FROM Territory__c WHERE PostalCode__c = :l.PostalCode];",
            "        if(terrList.size() > 0) {",
            "            l.Territory__c = terrList[0].Id;",
            "        }",
            "    }",
            "}"
        ],
        "choices": ["3行目：SOQLクエリがforループコードの内部に配置されてるため", "1行目：before insertトリガーではTrigger:newは無効なため", "2行目：PostalCodeがnullの場合、NullPointer例外がスローされるため", "5行目：before insertトリガー内のLeadは更新できないため"],
        "correct": ["3行目：SOQLクエリがforループコードの内部に配置されてるため"],
        "explanations":["3行目：SOQLクエリがforループコードの内部に配置されてるため", "1行目：before insertトリガーではTrigger:newは無効なため", "2行目：PostalCodeがnullの場合、NullPointer例外がスローされるため", "5行目：before insertトリガー内のLeadは更新できないため"],
        "descriptions":[
            "これは正解です。大量のレコードを処理する際、ループの中でSOQLクエリを実行すると、すぐにSOQLクエリの制限に達してしまいます。このような設計は、大量のデータを処理する際に効率的ではありません。",
            "これは不正解です。Trigger.newはbefore insertトリガーで有効です。これは新しく挿入されるレコードのリストを参照します。",
            "これは不正解です。コードはl.PostalCodeがnullでない場合のみSOQLクエリを実行するようになっているため、NullPointer例外は発生しません。",
            "これは不正解です。before insertトリガー内では、Trigger.newのレコードの項目を変更することができます。そのため、この行は問題を引き起こすものではありません。"
        ]
    },
    {
        "number": "141",
        "question": "デバッグログフィルター設定はどこから設定できますか。2つ選びなさい。",
        "choices": ["ウェブUI内の監視ユーザー名の[Filters]リンク", "監視対象ユーザーの名前", "デバッグログのレコードの[詳細を表示]リンク", "クラスまたはトリガーの詳細ページの[追跡フラグ]タブ"],
        "correct": ["ウェブUI内の監視ユーザー名の[Filters]リンク", "クラスまたはトリガーの詳細ページの[追跡フラグ]タブ"],
        "explanations":["ウェブUI内の監視ユーザー名の[Filters]リンク", "監視対象ユーザーの名前", "デバッグログのレコードの[詳細を表示]リンク", "クラスまたはトリガーの詳細ページの[追跡フラグ]タブ"],
        "descriptions":[
            "これは正解です。デバッグログのフィルタ設定は、設定⇒デバッグログ⇒ユーザー追跡フラグのユーザー名の隣にある[Filters]リンクをクリックすることでアクセスできます。ここで、特定のユーザーのデバッグログの詳細レベルを設定することができます。",
            "これは不正解です。設定⇒デバッグログ⇒ユーザー追跡フラグのユーザー名をクリックしても、デバッグログのフィルタ設定にはアクセスできません。",
            "これは不正解です。[詳細を表示]というリンクは存在しないため、デバッグログのフィルタ設定にはアクセスできません。ただし、設定⇒デバッグログ⇒ユーザー追跡フラグ⇒デバッグレベル名をクリックすることで、そのデバッグレベル名のデバッグレベルの詳細が出てきます。",
            "これは正解です。クラスやトリガーの詳細ページには[追跡フラグ]タブがあり、このタブを使用してデバッグログのフィルター設定を行うことができます。"
        ]
    },
    {
        "number": "142",
        "previous-code": [
            "Opportunity opp = [select id, stagename from Opportunity Limit 1];"
        ],
        "question": "上記のコードがある場合、開発者はどのようにstagename項目のラベルを取得できますか。",
        "choices": ["“opp.stagename.label”を呼び出す", "“opp.stagename.getdescribe().getlabel()”を呼び出す", "“opportunity.stagename.label”を呼び出す", "“opportunity.stagename.getdescribe().getlabel()”を呼び出す"],
        "correct": ["“opp.stagename.getdescribe().getlabel()”を呼び出す"],
        "explanations":["“opp.stagename.label”を呼び出す", "“opp.stagename.getdescribe().getlabel()”を呼び出す", "“opportunity.stagename.label”を呼び出す", "“opportunity.stagename.getdescribe().getlabel()”を呼び出す"],
        "descriptions":[
            "これは不正解です。Apexでは、項目のラベルに直接アクセスする方法としてこのような構文はサポートされていません。",
            "これは正解です。opp.stagename.getDescribe().getLabel()は、ApexのDescribeメソッドを使用して項目のメタデータ情報を取得するための正しい方法です。これにより、stagename項目のラベルを取得できます。",
            "これは不正解です。opportunityはクラス名として使用されるものであり、インスタンス変数としてこの方法では使用できません。また、項目ラベルに直接アクセスする方法はサポートされていません。",
            "これは不正解です。opportunityはApexクラスの名前として使用されるため、インスタンス変数としてこの方法では使用できません。項目のラベルを取得するためには、インスタンス変数に対してDescribeメソッドを呼び出す必要があります。"
        ]
    },
    {
        "number": "143",
        "question": "テキストエリア (リッチ)項目が自動的に割り当てられるプリミティブデータ型はどれですか。",
        "choices": ["Blob", "Text", "Object", "String"],
        "correct": ["String"],
        "explanations":["Blob", "Text", "Object", "String"],
        "descriptions":[
            "これは不正解です。Blobはバイナリデータを格納するためのデータ型です。テキストエリア (リッチ)項目は文字列データを格納するため、Blobは適切なデータ型ではありません。",
            "これは不正解です。TextはApexにおける正式なプリミティブデータ型ではありません。テキスト項目は String データ型として扱われます。",
            "これは不正解です。Objectは特定のデータ型ではなく、全てのデータ型のスーパークラスです。特定の項目のデータ型としてObjectを使うことはありません。",
            "これは正解です。Salesforceのテキストエリア(リッチ)項目は、Apexコード内でStringデータ型として扱われます。String型はテキスト情報を保存するのに使われるので、リッチテキストを含む項目のデータ型としても使用されます。"
        ]
    },
    {
        "number": "144",
        "question": "開発者が、カスタムコントローラでカスタム例外が正しく機能することを確認するために単体テストを書きましたが、例外がスローされたためにテストが失敗しました。\nこの問題を解決し、例外を適切にテストするために、開発者が取るべき手順はどれでしょうか。",
        "choices": ["単体テスト内でtry/catchを使用して例外をキャッチする", "単体テスト内でfinallyブロックを使用して、例外を投入する", "データベースメソッドを、allまたはnoneをFALSEに設定して使用する", "カスタムコントローラ内でTest.isRunningTest()を使用する"],
        "correct": ["単体テスト内でtry/catchを使用して例外をキャッチする"],
        "explanations":["単体テスト内でtry/catchを使用して例外をキャッチする", "単体テスト内でfinallyブロックを使用して、例外を投入する", "データベースメソッドを、allまたはnoneをFALSEに設定して使用する", "カスタムコントローラ内でTest.isRunningTest()を使用する"],
        "descriptions":[
            "これは正解です。単体テスト中に例外がスローされることを期待する場合、try/catchブロックを使用してその例外をキャッチすることで、テストが失敗するのを防ぐことができます。例外が正しくスローされることを確認するためには、catchブロック内でアサーションを使用することが一般的です。",
            "これは不正解です。finallyブロックは、tryまたはcatchブロックの後に実行されるブロックで、例外が発生したかどうかに関係なく実行されます。例外を投入するためにfinallyブロックを使用することは、一般的な使用法ではありません。",
            "これは不正解です。allOrNoneパラメータは、データベース操作が部分的に成功した場合に、全体をコミットするかロールバックするかを制御します。このパラメータは例外のテストとは直接関係がありません。",
            "これは不正解です。Test.isRunningTest()メソッドは、現在のコードがテスト実行中かどうかを判断するために使用されます。これを使用して例外の動作を変更することは、実際の動作とテスト動作の間に差異を生じさせる可能性があり、推奨されません。"
        ]
    },
    {
        "number": "145",
        "question": "データの一意なキーと値のペアを提供するコレクション型はどれですか。",
        "choices": ["List", "Set", "Array", "Map"],
        "correct": ["Map"],
        "explanations":["List", "Set", "Array", "Map"],
        "descriptions":[
            "これは不正解です。Listは順序付けられたコレクションであり、要素にインデックスを使用してアクセスします。一意なキーと値のペアを提供するものではありません。",
            "これは不正解です。Setは一意の要素のコレクションであり、重複する要素を含むことはできません。キーと値のペアを持つわけではありません。",
            "これは不正解です。Arrayは他のプログラミング言語での一般的なデータ構造ですが、Apexには「Array」という型は存在しません。Apexでは、Listが配列の役割を果たします。",
            "これは正解です。Mapは一意なキーとそれに関連付けられた値のペアを格納するコレクションです。キーは一意であるため、同じキーに対する複数の値を持つことはできません。"
        ]
    },
    {
        "number": "146",
        "question": "Apex処理が100件のAccountレコードと2,000件のContactレコードを挿入した後、500件のOpportunityレコードを挿入しようとしてDML例外が発生しました。Accountレコードは、allOrNone引数をfalseに設定してdatabase.insert()メソッドを呼び出すことで挿入されます。ContactおよびOpportunityレコードは、スタンドアロンinsert文(通常のInsert 変数名;)を使用して挿入されます。この処理でデータベースにコミットされるレコードの総数はいくつですか。",
        "choices": ["2,000", "2,100", "0", "100"],
        "correct": ["100"],
        "explanations":["2,000", "2,100", "0", "100"],
        "descriptions":[
            "これは不正解です。2,000件のContactレコードの挿入時にDML例外が発生するため、これらのレコードはデータベースにコミットされません。",
            "これは不正解です。2,000件のContactレコードはDML例外のためコミットされません。したがって、100件のAccountレコードと2,000件のContactレコードの合計2,100件がコミットされることはありません。",
            "これは不正解です。100件のAccountレコードはDatabase.insert(obj, false)を使用して正常にデータベースにコミットされます。",
            "これは正解です。Database.insert(obj, false)を使用して100件のAccountレコードがデータベースに正常にコミットされます。しかし、2,000件のContactレコードの挿入時にDML例外が発生するため、これらのレコードはデータベースにコミットされません。したがって、データベースにコミットされるレコードの総数は100件のAccountレコードのみとなります。"
        ]
    },
    {
        "number": "147",
        "question": "開発者は、従来のオンプレミスのSQLデータベースと統合しています。統合されるデータが Salesforce内の適切なレコードと一致するようにするには、開発者は何を使用すればよいでしょうか。",
        "choices": ["外部オブジェクト", "外部ID項目", "参照関係", "数式項目"],
        "correct": ["外部ID項目"],
        "explanations":["外部オブジェクト", "外部ID項目", "参照関係", "数式項目"],
        "descriptions":[
            "これは不正解です。外部オブジェクトは、Salesforce Connectを使用して外部システムのデータにリアルタイムでアクセスするためのものです。オンプレミスのSQLデータベースと統合する場合には使用できますが、Salesforce内の適切なレコードと一致させるための直接的な方法ではありません。",
            "これは正解です。外部IDは、外部システムの一意の識別子をSalesforce内に保存し、データの整合性を保つために使用されます。これにより、オンプレミスのSQLデータベースからのデータがSalesforceのレコードと正確に一致するようになります。カスタム項目を外部IDとして使用することで、データの重複を防ぎ、一貫性を保つことができます。",
            "これは不正解です。参照関係は、Salesforce内のオブジェクト間の関係を作成するためのもので、外部システムのデータを一致させるためには使用されません。参照関係を使用することで、関連レコード間のナビゲーションが可能になりますが、外部データとの統合には適していません。",
            "これは不正解です。数式項目は、他の項目の値を基に自動的に計算される項目です。数式項目を使用して外部データと統合することはできませんし、Salesforce内のレコードと外部データベースのレコードを一致させるためのツールではありません。"
        ]
    },
    {
        "number": "148",
        "question": "ある開発者が、WithSharingキーワードを使用するVisualforceページとApexコントローラを作成しました。このページは営業マネージャーが使用し、実行中の営業マネージャーに報告する営業担当者が所有する取引先のみを表示する必要があります。取引先に対する組織全体の共有は非公開に設定されています。開発者が取るべき追加の手順はどれですか。",
        "choices": ["1つのプロファイル、1つの権限セット、1つのロールを作成する", "2つのプロファイル、1つの権限セット、1つのロールを作成する", "1つのプロファイル、1つの権限セット、2つのロールを作成する", "1つのプロファイル、2つの権限セット、1つのロールを作成する"],
        "correct": ["1つのプロファイル、1つの権限セット、2つのロールを作成する"],
        "explanations":["1つのプロファイル、1つの権限セット、1つのロールを作成する", "2つのプロファイル、1つの権限セット、1つのロールを作成する", "1つのプロファイル、1つの権限セット、2つのロールを作成する", "1つのプロファイル、2つの権限セット、1つのロールを作成する"],
        "descriptions":[
            "これは不正解です。この設定では、営業マネージャーと営業担当者間の階層的な関係を表現できません。営業マネージャーが自分に報告する営業担当者のデータのみを見るためには、ロール階層が必要です。",
            "これは不正解です。この設定では、ロール階層が適切に設定されていないため、営業マネージャーが自分に報告する営業担当者の取引先データにアクセスすることができません。プロファイルはオブジェクトや項目など基本的なアクセス権を定義しますが、ロール階層がないと、階層内でのデータ共有とアクセスは実現不可能です。",
            "これは正解です。この方法では、1つのプロファイルと権限セットで基本的なアクセス権を定義し、2つのロール(営業マネージャー用と営業担当者用)を作成して階層的なアクセス制御を実現します。営業マネージャーのロールは営業担当者のロールよりも上位に設定し、営業マネージャーが営業担当者が所有する取引先のデータにアクセスできるようにします。",
            "これは不正解です。この設定ではロール階層が不足しているため、営業マネージャーが直属の営業担当者が所有する取引先データにアクセスすることができません。営業マネージャーと営業担当者間のデータの可視性を確保するためには、異なるロールを持つ階層的な関係が必要ですが、この設定ではそれが実現されていません。"
        ]
    },
    {
        "number": "149",
        "previous-code": [
            "List<Contact> performSearch(String lastName) {",
            "    return Database.query('Select Id, FirstName, LastName FROM Contact WHERE LastName Like%' + lastName +'%');",
            "}"
        ],
        "question": "開発者は、システムに存在する ContactSearchApexクラスのセキュリティレビューを実行するよう命じられました。このクラスの中で、開発者は以上のメソッドがセキュリティ上の脅威であることを特定しました。\nSOQL インジェクション攻撃を防ぐために、開発者がメソッドを改善できる方法は何ですか。2つ選びなさい。",
        "choices": ["クラスに@ReadOnlyアノテーションとwith sharingキーワードを使用する。", "escapeSingleQuotes メソッドを使用して、使用前にパラメータをサニタイズする。", "パラメータに正規表現式を使用して特殊文字を削除する。", "変数バインディングを使用し、動的クエリを静的SOQLに置き換える。"],
        "correct": ["escapeSingleQuotes メソッドを使用して、使用前にパラメータをサニタイズする。", "変数バインディングを使用し、動的クエリを静的SOQLに置き換える。"],
        "explanations":["クラスに@ReadOnlyアノテーションとwith sharingキーワードを使用する。", "escapeSingleQuotes メソッドを使用して、使用前にパラメータをサニタイズする。", "パラメータに正規表現式を使用して特殊文字を削除する。", "変数バインディングを使用し、動的クエリを静的SOQLに置き換える。"],
        "descriptions":[
            "これは不正解です。 @ReadOnly アノテーションはトランザクションが読み取り専用であることを指示し、リソースの制限を緩和するために使用されますが、SOQLインジェクション攻撃を防ぐものではありません。with sharing キーワードはレコードの可視性に基づいて実行を制御するもので、セキュリティを強化する可能性はありますが、SOQLインジェクションそのものを防ぐものではないため、ここでは不適切です。",
            "これは正解です。escapeSingleQuotes() メソッドは、文字列内のシングルクォートをエスケープしてSOQLインジェクション攻撃を防ぐために使用されます。このメソッドを使用することで、攻撃者が有害なSOQLを注入するリスクを軽減できます。",
            "これは不正解です。 正規表現を使用して特殊文字を削除することは一種のサニタイズと見なすことができますが、攻撃者がSOQLインジェクションを実行するために使う可能性のある特定の文字列パターンを除去するためには、非常に複雑で確実な正規表現が必要になります。これは一般的な解決策として推奨されず、エスケープ処理に比べて安全ではありません。",
            "これは正解です。変数バインディングを使用して静的なSOQLクエリに変換することで、SOQLインジェクションのリスクを取り除くことができます。これにより、Apexが提供するクエリの文字列を適切に処理し、ユーザーが提供した値を安全に使うことができるようになります。"
        ]
    },
    {
        "number": "150",
        "question": "Apex テストクラスで @testSetup アノテーションを使用することについて、正しい記述はどれですか。3つ選びなさい。",
        "choices": ["isTest(SeeAllData=True) アノテーションが使用されている場合、@testSetup アノテーションは使用できません。", "テストデータは、クラス内のすべてのテストメソッドに対して 1 回挿入されます。", "testSetup メソッドで作成されたレコードを、個々のテストメソッドで更新することはできません。", "テストクラスの各テストメソッドが実行される前に、@testSetup メソッドが自動的に実行されます。"],
        "correct": ["isTest(SeeAllData=True) アノテーションが使用されている場合、@testSetup アノテーションは使用できません。", "テストデータは、クラス内のすべてのテストメソッドに対して 1 回挿入されます。", "テストクラスの各テストメソッドが実行される前に、@testSetup メソッドが自動的に実行されます。"],
        "explanations":["isTest(SeeAllData=True) アノテーションが使用されている場合、@testSetup アノテーションは使用できません。", "テストデータは、クラス内のすべてのテストメソッドに対して 1 回挿入されます。", "testSetup メソッドで作成されたレコードを、個々のテストメソッドで更新することはできません。", "テストクラスの各テストメソッドが実行される前に、@testSetup メソッドが自動的に実行されます。"],
        "descriptions":[
            "これは正解です。isTest(SeeAllData=True) を使用すると、実際の組織データにアクセスすることになりますが、@testSetup はテスト実行の際に独自のテストデータを設定するために使用されるため、両者は同時には使用できません。",
            "これは正解です。@testSetup で定義されたメソッドは、テストクラス内の各テストメソッドが実行される前に一度だけ実行され、生成されたテストデータは各テストメソッドで使用されます。",
            "これは不正解です。@testSetup メソッドで作成されたレコードは、各テストメソッド内で更新することができます。ただし、各テストメソッドは独立しているため、あるテストメソッドでの変更は他のテストメソッドには影響しません。",
            "これは正解です。これは@testSetup アノテーションの基本的な動作であり、このメソッドは各テストメソッドが実行される前に自動的に一度だけ実行されます。これにより、すべてのテストメソッドに対して共通のテストデータを準備することができます。"
        ]
    },
    {
        "number": "151",
        "question": "以下のブロックコードがあるとします。SOQLクエリの後、retrieveRecordsリストが空の場合、コードの実行が中断されるようにするために、開発者は何をする必要がありますか。",
        "following-code": [
            "try {",
            "  List <Accounts> retrieveRecords = [SELECT Id FROM Account WHERE Website = null];",
            "} catch(Exception e){",
            "  //例外ロジック",
            "}"
        ],
        "choices": ["retrieveRecords変数の状態をチェックし、変数が空の場合はカスタム例外をスローする。", "retrieveRecords変数の状態をチェックし、変数が空の場合はSystem.assert(false)を使用する。", "retrieveRecords変数の状態をチェックし、変数が空の場合はリストの最初の要素にアクセスする。", "retrieveRecords変数の宣言を、リストのAccountから単一のAccountに置き換える。"],
        "correct": ["retrieveRecords変数の状態をチェックし、変数が空の場合はSystem.assert(false)を使用する。"],
        "explanations":["retrieveRecords変数の状態をチェックし、変数が空の場合はカスタム例外をスローする。", "retrieveRecords変数の状態をチェックし、変数が空の場合はSystem.assert(false)を使用する。", "retrieveRecords変数の状態をチェックし、変数が空の場合はリストの最初の要素にアクセスする。", "retrieveRecords変数の宣言を、リストのAccountから単一のAccountに置き換える。"],
        "descriptions":[
            "これは不正解です。カスタム例外をスローすると、catch(Exception e)ブロックでキャッチされ、コードの実行が中断されません。しかし、通常の開発プラクティスでは、このような方法で例外を適切にハンドルし、エラー情報を明確にするためにカスタム例外を使用することが推奨されます。",
            "これは正解です。System.assert(false)は、条件がfalseの場合にエラーをスローし、コードの実行を中断します。ただし、通常の開発ではアサーションはテストクラス内でのみ使用され、途中で処理を中断する目的で使われることはありません。",
            "これは不正解です。リストが空の場合、最初の要素にアクセスしようとするとNullPointerExceptionがスローされますが、catch(Exception e)ブロックでキャッチされ、コードの実行は中断されません。通常の開発プラクティスでは、リストにアクセスする前にそのリストが空でないことを確認することが推奨されます。",
            "これは不正解です。変数の宣言を単一のAccountに変更しても、コードの実行が中断されるわけではありません。通常の開発プラクティスでは、変数の目的や使用方法に応じて適切なデータ型を選択し、変数を宣言することが重要です。リストを期待している場面で単一のオブジェクトを使用すると、予期しないエラーや問題が発生する可能性があります。"
        ]
    },
    {
        "number": "152",
        "previous-code": [
            "List<Contact> theContacts = new List<Contact>();\n",
            "for (Account a : Trigger.new) {",
            "    for (Contact c : [SELECT Id, Account_Date__c FROM Contact WHERE AccountId = :a.Id]) {",
            "        c.Account_Date__c = Date.today();",
            "        theContacts.add(c);",
            "    }",
            "}",
            "update theContacts;"
        ],
        "question": "開発者は、取引先オブジェクトの’after update’トリガーを使用して、取引先に関連するすべての取引先責任者を更新します。以上に示すトリガーコードは、ランダムに失敗します。\nこのコードブロックが失敗する原因は次のうちどれですか。",
        "choices": ["theContactsが空の場合は例外がスローされます。", "Account_Date__cがnullの場合、例外がスローされます。", "トリガーは、forループで200 以上のレコードを処理します。", "SOQLクエリがforループ内にあります。"],
        "correct": ["SOQLクエリがforループ内にあります。"],
        "explanations":["theContactsが空の場合は例外がスローされます。", "Account_Date__cがnullの場合、例外がスローされます。", "トリガーは、forループで200 以上のレコードを処理します。", "SOQLクエリがforループ内にあります。"],
        "descriptions":[
            "これは不正解です。theContactsリストが空の場合でも、updateステートメントを使用してそのリストを更新しようとしても、例外はスローされません。更新するレコードがない場合、単に何も実行されないだけです。",
            "これは不正解です。Account_Date__cがnullであっても、Date.today()メソッドで現在の日付を代入しているため、null値による例外は発生しません。この代入は問題なく機能します。",
            "これは不正解です。問題の主な原因は「forループ内でのSOQLクエリの発行」にあります。もしTrigger.newが200のレコードを持っている場合、このコードは200回のSOQLクエリを発行することになり、これがガバナ制限の「発行される SOQL クエリの合計数」の制限を超える可能性があります。ただし、単純にforループで200以上のレコードを処理すること自体は問題ではありません。",
            "これは正解です。forループ内でSOQLクエリを実行すると、多数の取引先レコードが更新される場合にSOQLクエリのガバナ制限に達するリスクが高まります。このような設計は、ガバナ制限を超える可能性があるため、ランダムに失敗する原因となります。通常の開発プラクティスでは、ループ内でのSOQLクエリの発行は避けることが推奨されます。"
        ]
    },
    {
        "number": "153",
        "question": "ある開発者がVisualforceページと、ページ上で発生するさまざまなボタンやイベントを処理するメソッドを持つカスタムコントローラを作成しました。本番環境にデプロイするために、開発者は何をすべきですか。",
        "choices": ["Visualforceページをカバーするテストクラスを作成する", "Visualforceページをカバーするテストページを作成する", "カスタムコントローラをカバーするテストページを作成する", "カスタムコントローラをカバーするテストクラスを作成する"],
        "correct": ["カスタムコントローラをカバーするテストクラスを作成する"],
        "explanations":["Visualforceページをカバーするテストクラスを作成する", "Visualforceページをカバーするテストページを作成する", "カスタムコントローラをカバーするテストページを作成する", "カスタムコントローラをカバーするテストクラスを作成する"],
        "descriptions":[
            "これは不正解です。Visualforceページ自体をカバーするテストクラスを作成することはできません。テストクラスは、Apexコードのロジックをテストするためのものであり、Visualforceページのマークアップやレイアウトをテストするためのものではありません。",
            "これは不正解です。テストページという概念はSalesforce開発には存在しないため、Visualforceページをカバーするテストページを作成することはできません。",
            "これは不正解です。同様に、テストページという概念はSalesforce開発には存在しないため、カスタムコントローラをカバーするテストページを作成することはできません。",
            "これは正解です。Salesforceの本番環境にデプロイする前に、カスタムコントローラのロジックをテストするためのテストクラスを作成する必要があります。このテストクラスは、カスタムコントローラ内のメソッドやロジックが正しく動作することを確認するためのものであり、デプロイ時に必要なコードカバレッジを提供します。"
        ]
    },
    {
        "number": "154",
        "question": "開発者はオブジェクトのVisualforceを使用してボタンをオーバーライドしたいと考えています。\nどんな要件を満たしている必要がありますか。",
        "choices": ["コントローラまたは拡張機能にPageReferenceメソッドを設定する。", "オブジェクトにstandardController属性を設定する。", "action属性をコントローラのメソッドに設定する。", "オブジェクトレコードは、コントローラまたは拡張機能でインスタンス化する必要があります。"],
        "correct": ["オブジェクトにstandardController属性を設定する。"],
        "explanations":["コントローラまたは拡張機能にPageReferenceメソッドを設定する。", "オブジェクトにstandardController属性を設定する。", "action属性をコントローラのメソッドに設定する。", "オブジェクトレコードは、コントローラまたは拡張機能でインスタンス化する必要があります。"],
        "descriptions":[
            "これは不正解です。ボタンをオーバーライドするためには、PageReferenceメソッドの設定は必須ではありません。PageReferenceは、ページのリダイレクトやURLの取得・設定、クエリ文字列パラメータの取得・設定など、ページの参照やナビゲーションに関連する操作を行うためのクラスです。",
            "これは正解です。ボタンをオーバーライドするためのVisualforceページを作成する際、関連するオブジェクトの標準コントローラを指定するために、standardController属性を使用します。この属性により、ページは特定のオブジェクトのデータと動作にアクセスできるようになります。",
            "これは不正解です。action属性は、Visualforceページが読み込まれる際や、特定のVisualforceコンポーネントがクリックされたときに実行されるコントローラのメソッドを指定するためのものです。ただし、この属性だけでボタンをオーバーライドするわけではありません。",
            "これは不正解です。ボタンをオーバーライドする際、その背後にあるロジックを実行するためのコントローラや拡張機能が必要となることがあります。しかし、オーバーライドの動作自体がオブジェクトレコードのインスタンス化を必要とするわけではありません。オブジェクトレコードのインスタンス化は、特定のデータ操作やビジネスロジックの実行時に必要となる場合がありますが、それはボタンのオーバーライドとは直接関連していません。"
        ]
    },
    {
        "number": "155",
        "question": "すべての値が一意であることを保証するために使用されるApexコレクションはどれですか。",
        "choices": ["List", "Enum", "Set", "sObject"],
        "correct": ["Set"],
        "explanations":["List", "Enum", "Set", "sObject"],
        "descriptions":[
            "これは不正解です。ListはApexの順序付きコレクションで、重複した値を持つことができます。",
            "これは不正解です。Enumは列挙型を定義するためのもので、コレクションとは異なります。",
            "これは正解です。SetはApexのコレクションで、すべての要素が一意であることを保証します。重複した値を追加しようとすると、それは無視されます。",
            "これは不正解です。sObjectはSalesforceのオブジェクトデータを表すもので、コレクションとは異なります。"
        ]
    },
    {
        "number": "156",
        "question": "MVCパラダイムの観点から、VisualforceよりもLightning Webコンポーネントベースの開発を使用してSalesforceアプリケーションのビューレイヤーを実装することの利点は何ですか。2つ選びなさい。",
        "choices": ["アプリケーションが自己完結型で再利用可能である", "豊富なコンポーネントエコシステム", "サーバー側のランタイムデバッグ", "自動コード生成"],
        "correct": ["アプリケーションが自己完結型で再利用可能である", "豊富なコンポーネントエコシステム"],
        "explanations":["アプリケーションが自己完結型で再利用可能である", "豊富なコンポーネントエコシステム", "サーバー側のランタイムデバッグ", "自動コード生成"],
        "descriptions":[
            "これは正解です。Lightning Webコンポーネントは再利用可能なコンポーネントを作成することを強化しており、これにより開発者は一度作成したコンポーネントを異なる場面やアプリケーションで再利用することができます。これはMVCの観点からビューレイヤーの再利用性を高める利点となります。",
            "これは正解です。Lightning WebコンポーネントはSalesforce Lightningプラットフォーム上でのモダンなコンポーネントベースの開発をサポートしており、豊富なコンポーネントエコシステムを持っています。これにより、開発者は既存のコンポーネントを利用して迅速にアプリケーションを構築することができます。",
            "これは不正解です。サーバー側のランタイムデバッグは、ビューレイヤーの実装に関連する特定の利点ではありません。また、MVCパラダイムの観点からの利点とは言えません。",
            "これは不正解です。自動コード生成は、特定の開発ツールやフレームワークに関連する機能であり、MVCパラダイムの観点からのビューレイヤーの実装に関する直接的な利点とは言えません。"
        ]
    },
    {
        "number": "157",
        "question": "ある開発者が、メールアドレス’dev@uc.com’を持つ取引先責任者とユーザーを取得したいと考えています。開発者が使用すべきSOSL文はどれですか。",
        "choices": ["FIND {dev@uc.com} IN Email Fields RETURNING Contact (Email), User (Email)", "FIND {Email = ‘dev@uc.com’} RETURNING Contact (Email), User (Email)", "FIND {Email = ‘dev@uc.com’} IN Contact, User", "FIND Email IN Contact, User FOR {dev2uc.com}"],
        "correct": ["FIND {dev@uc.com} IN Email Fields RETURNING Contact (Email), User (Email)"],
        "explanations":["FIND {dev@uc.com} IN Email Fields RETURNING Contact (Email), User (Email)", "FIND {Email = ‘dev@uc.com’} RETURNING Contact (Email), User (Email)", "FIND {Email = ‘dev@uc.com’} IN Contact, User", "FIND Email IN Contact, User FOR {dev2uc.com}"],
        "descriptions":[
            "これは正解です。このSOSL文は、Emailフィールド内で’dev@uc.com’を検索し、該当する取引先責任者(Contact)とユーザー(User)のEmailフィールドの値を返します。この文は正しく、要件を満たしています。",
            "これは不正解です。 このクエリは「IN [フィールド名]」の部分を欠いています。SOSLでは、どのフィールドを検索対象とするかを明示する必要があります。FIND {dev@uc.com} IN Email Fields RETURNING Contact (Email), User (Email) のように「IN Email Fields」を追加することで、メールフィールド内での検索を指定します。",
            "これは不正解です。 このクエリは「IN [フィールド名]」の形式が間違っています。また、検索値が正しく指定されていません。FIND {dev@uc.com} IN Email Fields RETURNING Contact, User のように、正しい「IN [フィールド名]」の形式を使用し、検索値を適切に指定する必要があります。",
            "これは不正解です。 このクエリは全体的に文法が間違っており、SOSLの構文に従っていません。また、検索値が誤っています。FIND {dev@uc.com} IN Email Fields RETURNING Contact (Email), User (Email) のように、正しいSOSL構文を使用し、正しい検索値を指定する必要があります。"
        ]
    },
    {
        "number": "158",
        "question": "ユーザーが取引先の「Postal Code」を更新する際、取引先のカスタムテキスト項目「Timezone」は、カスタムオブジェクト「PostalCodeToTimezone__c」の情報を基に自動的に更新される必要があります。この機能を実装するため、開発者はどの手法を採用すべきでしょうか",
        "choices": ["取引先オブジェクトのワークフロールールを作成する。", "取引先オブジェクトの割り当てルールを作成する。", "取引先オブジェクトのカスタムトリガーを作成する。", "取引先オブジェクトの承認プロセスを作成する。"],
        "correct": ["取引先オブジェクトのカスタムトリガーを作成する。"],
        "explanations":["取引先オブジェクトのワークフロールールを作成する。", "取引先オブジェクトの割り当てルールを作成する。", "取引先オブジェクトのカスタムトリガーを作成する。", "取引先オブジェクトの承認プロセスを作成する。"],
        "descriptions":[
            "これは不正解です。ワークフロールールは、レコードが特定の条件を満たすときにアクションを自動化するために使用されますが、複雑なロジックや他のオブジェクトからデータを取得して項目を更新する機能はありません。したがって、PostalCodeToTimezone__cからデータを基に取引先のTimezone項目を更新するためには適していません。",
            "これは不正解です。割り当てルールはレコードの所有者を自動的に設定するためのものです。リードやケースに使用され、項目の自動更新や他のオブジェクトのデータを参照する機能はありません。このケースでは、割り当てルールは要件を満たしません。",
            "これは正解です。 Apexトリガーを使用することで、取引先のPostal Codeが更新された際に、カスタムオブジェクトPostalCodeToTimezone__cの情報を基にTimezone項目を自動的に更新することができます。トリガーは複雑なビジネスロジックを実装するための柔軟性を提供し、このような要件を満たすためのベストプラクティスです。",
            "これは不正解です。承認プロセスは、レコードが特定の基準を満たすときに承認を求めるためのフローを定義するために使用されます。項目の自動更新や他のオブジェクトからのデータ取得には適していません。"
        ]
    },
    {
        "number": "159",
        "question": "カスタムVisualforceコントローラとして使用するクラスの要件は何ですか。",
        "choices": ["PageReferenceを返すコンストラクタを持つ最上位のApexクラス", "PageReferenceを拡張する最上位のApexクラス", "デフォルトの引数なしコンストラクタを持つ最上位のApexクラス", "コントローラインターフェースを実装した最上位のApexクラス"],
        "correct": ["デフォルトの引数なしコンストラクタを持つ最上位のApexクラス"],
        "explanations":["PageReferenceを返すコンストラクタを持つ最上位のApexクラス", "PageReferenceを拡張する最上位のApexクラス", "デフォルトの引数なしコンストラクタを持つ最上位のApexクラス", "コントローラインターフェースを実装した最上位のApexクラス"],
        "descriptions":[
            "これは不正解です。Visualforceコントローラの主要な要件は、PageReferenceを返すコンストラクタを持つことではありません。コントローラは、VisualforceページとApexコードの間のロジックを処理するためのものであり、特定の型のコンストラクタを持つ必要はありません。",
            "これは不正解です。一般的に、PageReferenceを直接拡張することはカスタムVisualforceコントローラの作成には不適切です。PageReferenceはVisualforceページや外部URLへのリダイレクトを表すクラスであり、コントローラの主要なロジックを実装するためのものではありません。",
            "これは正解です。カスタムVisualforceコントローラとして使用するApexクラスは、デフォルトの引数なしのコンストラクタを持つ必要があります。このコンストラクタは、Visualforceページがロードされるときに自動的に呼び出されます。",
            "これは不正解です。Visualforceコントローラとして使用するApexクラスが特定のインターフェースを実装する必要はありません。ただし、特定の機能を持つコントローラを作成する場合、インターフェースの実装が役立つ場合がありますが、これは必須の要件ではありません。"
        ]
    },
    {
        "number": "160",
        "question": "ある企業は、顧客に教育ビデオを視聴してもらうための推進計画を実施しました。顧客は数日間にわたりビデオを視聴することができ、その進捗は記録されます。動画をすべて視聴完了すると、顧客に報奨ポイントが付与されます。動画がSalesforceで完了としてマークされた際、外部のWebサービスを呼び出して、ユーザーにポイントを付与する必要があります。\n開発者は、この要件をSalesforceのafter updateトリガー内で外部Webサービスへの呼び出しとして実装しました。しかし、実装後にSystem.CalloutExceptionが発生しています。このエラーを解消するために、開発者はどのような対応をすべきでしょうか。",
        "choices": ["after update トリガーを before insert トリガーに置き換える。", "外部 Web サービスと統合する REST サービスを作成する。", "外部呼び出しを try-catch ブロックで囲み、例外を処理する。", "@future(callout=true)を使用して、コールアウトを非同期メソッドに移動する。"],
        "correct": ["@future(callout=true)を使用して、コールアウトを非同期メソッドに移動する。"],
        "explanations":["after update トリガーを before insert トリガーに置き換える。", "外部 Web サービスと統合する REST サービスを作成する。", "外部呼び出しを try-catch ブロックで囲み、例外を処理する。", "@future(callout=true)を使用して、コールアウトを非同期メソッドに移動する。"],
        "descriptions":[
            "これは不正解です。このエラーはトリガーのタイミング(after update または before insert)に関連しているわけではありません。また、動画が完了としてマークされるときにポイントを付与するため、before insert トリガーはこのシナリオには適していません。",
            "これは不正解です。このエラーは、REST サービスの存在やその作成方法に関連しているわけではありません。エラーの原因はトリガー内での同期的なコールアウトに関連しています。",
            "これは不正解です。例外をキャッチすることは良い実践ですが、それだけではSystem.CalloutExceptionの根本的な原因を解決しません。トリガー内での同期的なコールアウトが許可されていないため、このエラーが発生します。",
            "これは正解です。Salesforceでは、トリガー内での同期的なコールアウトは許可されていません。そのため、非同期メソッドを使用してコールアウトを行う必要があります。@future(callout=true) アノテーションを使用することで、非同期的に外部サービスを呼び出すことができます。"
        ]
    },
    {
        "number": "161",
        "question": "セールスフォースには、Developer Sandbox、Developer Pro Sandbox、Partial Copy Sandbox、Full Sandboxの4つのサンドボックスタイプが存在します。その中で、Partial Copy SandboxとFull Sandboxの特徴は何ですか。2つ選びなさい。",
        "choices": ["メタデータの一部分のみを含みます", "サンドボックスのテンプレートが利用できます", "より頻繁な更新をサポートします", "より多くのデータレコードを保存できます"],
        "correct": ["サンドボックスのテンプレートが利用できます", "より多くのデータレコードを保存できます"],
        "explanations":["メタデータの一部分のみを含みます", "サンドボックスのテンプレートが利用できます", "より頻繁な更新をサポートします", "より多くのデータレコードを保存できます"],
        "descriptions":[
            "これは不正解です。すべてのサンドボックスタイプでメタデータはサポートされています。Partial Copy Sandboxはメタデータとサンプルデータを含み、Full Sandboxはメタデータとすべてのデータを含みます。",
            "これは正解です。Partial Copy Sandboxではサンドボックスのテンプレートが必須であり、Full Sandboxでもテンプレートを利用することができます。一方、Developer SandboxやDeveloper Pro Sandboxではテンプレートの利用はできません。",
            "これは不正解です。Partial Copy Sandboxは5日ごと、Full Sandboxは29日ごとに更新が可能です。一方、Developer SandboxやDeveloper Pro Sandboxは1日ごとに更新が可能です。より頻繁な更新をサポートしているのはDeveloper SandboxやDeveloper Pro Sandboxです。",
            "これは正解です。Full Sandboxは本番組織と同じストレージ制限を持ち、最も多くのデータレコードを保存する能力があります。Partial Copy Sandboxは5GBのデータストレージを提供します。これは、Developer SandboxやDeveloper Pro Sandboxと比べて、より多くのデータレコードを保存できることを意味します。"
        ]
    },
    {
        "number": "162",
        "question": "Before InsertトリガーのTrigger.oldコンテキスト変数の値は何ですか。",
        "choices": ["sObjectの空のリスト", "null", "Idなしで新しく作成されたsObjectのリスト", "Undefined"],
        "correct": ["null"],
        "explanations":["sObjectの空のリスト", "null", "Idなしで新しく作成されたsObjectのリスト", "Undefined"],
        "descriptions":[
            "これは不正解です。Trigger.oldは、Before Insertトリガーのコンテキストで使用される場合、利用できません。その理由は、Trigger.oldが元のレコードのリストを参照するものであるのに対し、Before Insertの際には新しいレコードがまだデータベースに挿入されていないため、”古い” バージョンのレコードが存在しないからです。",
            "これは正解です。Before Insertトリガーのコンテキストでは、Trigger.oldはnullとして返されます。これは、新しく挿入されるレコードはまだ保存されていないため、”古い” バージョンのレコードが存在しないからです。",
            "これは不正解です。この説明はTrigger.newのコンテキスト変数に関するもので、新しく挿入されるレコードのリストを参照します。Before Insertのコンテキストでは、これらのレコードはまだ保存されていないため、Idはまだ割り当てられていません。",
            "これは不正解です。Trigger.old は Before Insert トリガーのコンテキストではnullとなります。”Undefined” という状態はSalesforceのApex言語には存在しません。"
        ]
    },
    {
        "number": "163",
        "question": "Visualforce ページで標準アクションをオーバーライドするには、<apex:page>タグでどの属性を定義する必要がありますか。",
        "choices": ["pageReference", "override", "controller", "standardController"],
        "correct": ["standardController"],
        "explanations":["pageReference", "override", "controller", "standardController"],
        "descriptions":[
            "これは不正解です。pageReference は <apex:page>タグの属性として存在しません。",
            "これは不正解です。override は <apex:page>タグの属性として存在しません。",
            "これは不正解です。controller 属性は、カスタムApexコントローラを指定するために使用されます。標準アクションをオーバーライドするためには、この属性を使用するのではなく、標準コントローラを使用する必要があります。",
            "これは正解です。standardController 属性は、Visualforce ページが標準オブジェクトのレコードにアクセスするための標準コントローラを使用することを指定します。この属性を使用することで、標準アクションをオーバーライドすることができます。"
        ]
    },
    {
        "number": "164",
        "question": "本番環境にデプロイする際に必要なプロセスはどれですか。2つ選びなさい。",
        "choices": ["すべてのトリガーのテストカバレッジは75%以上である必要があります。", "すべてのトリガーのテストカバレッジは少なくとも1%以上である必要があります。", "すべてのApexコードのテストカバレッジは、少なくとも75%以上である必要があります。", "すべてのテストとトリガーのテストカバレッジを合わせて75%以上である必要があります。"],
        "correct": ["すべてのトリガーのテストカバレッジは少なくとも1%以上である必要があります。", "すべてのApexコードのテストカバレッジは、少なくとも75%以上である必要があります。"],
        "explanations":["すべてのトリガーのテストカバレッジは75%以上である必要があります。", "すべてのトリガーのテストカバレッジは少なくとも1%以上である必要があります。", "すべてのApexコードのテストカバレッジは、少なくとも75%以上である必要があります。", "すべてのテストとトリガーのテストカバレッジを合わせて75%以上である必要があります。"],
        "descriptions":[
            "これは不正解です。各Apexトリガーには最低1%のテストカバレッジが必要ですが、75%以上のカバレッジが各トリガーに必要というわけではありません。",
            "これは正解です。Apexトリガーについては、最低でも1%のカバレッジがないと、どんな場合でもデプロイに失敗します。",
            "これは正解です。運用環境にデプロイするためには、全てのApexコード(クラスやトリガーを含む)のテストカバレッジの合計が75%以上である必要があります。例えば、4つのApexクラスがあり、3つのクラスがそれぞれ100%のカバレッジを持ち、残りの1つのクラスがカバレッジ0%であっても、全体のカバレッジが75%となり、75%の要件を満たしているためデプロイはできます。",
            "これは不正解です。この選択肢は誤解を招く表現です。「すべてのテスト」と「トリガー」合わせて75%以上ではなく、「クラス」と「トリガー」を含むすべてのApexコードのテストの合計テストカバレッジが75%以上でなければなりません。"
        ]
    },
    {
        "number": "165",
        "question": "本番環境にデプロイする際に必要なプロセスはどれですか。2つ選びなさい。",
        "choices": ["すべてのプロセスビルダーのテストカバレッジは、少なくとも1%以上である必要があります。", "すべてのApexコードのテストカバレッジが75%以上である必要があります。", "すべてのトリガーのテストカバレッジは、少なくとも1%以上である必要があります。", "すべてのフローのテストカバレッジは、少なくとも1%以上である必要があります。"],
        "correct": ["すべてのApexコードのテストカバレッジが75%以上である必要があります。", "すべてのトリガーのテストカバレッジは、少なくとも1%以上である必要があります。"],
        "explanations":["すべてのプロセスビルダーのテストカバレッジは、少なくとも1%以上である必要があります。", "すべてのApexコードのテストカバレッジが75%以上である必要があります。", "すべてのトリガーのテストカバレッジは、少なくとも1%以上である必要があります。", "すべてのフローのテストカバレッジは、少なくとも1%以上である必要があります。"],
        "descriptions":[
            "これは不正解です。Salesforceのプロセスビルダーにはテストカバレッジの要件はありません。",
            "これは正解です。SalesforceでのApexコードの本番環境へのデプロイには、全体のテストカバレッジが75%以上であることが必要です。このカバレッジは、Apexクラスやトリガーを含む全てのApexコードのテスト結果を合計して評価されます。例えば、複数のApexクラスやトリガーが存在しても、それらのテスト結果の合計が75%以上であれば、デプロイの要件を満たします。",
            "これは正解です。各Apexトリガーには、最低でも1%のテストカバレッジが必要です。この要件は、トリガーごとに評価されます。たとえ全体のカバレッジが75%以上でも、1つのトリガーのカバレッジが1%未満の場合、そのトリガーの存在によりデプロイは許可されません。",
            "これは不正解です。Salesforceのフローにはテストカバレッジの要件は設定されていません。"
        ]
    },
    {
        "number": "166",
        "previous-code": [
            "trigger test on Lead (before update) {",
            "    List<Lead> leadsToUpdate = new List<Lead>();\n",
            "    for(Lead leadRecord : trigger.new){",
            "        if(leadRecord.Email != trigger.oldMap.get(leadRecord.Id).Email){",
            "            leadRecord.Prior_Email__c = trigger.oldMap.get(leadRecord.Id).Email;",
            "            leadsToUpdate.add(leadRecord);",
            "        }",
            "    }\n",
            "    if(leadsToUpdate.size() > 0) {",
            "        update leadsToUpdate;",
            "    }",
            "}"
        ],
        "question": "リードオブジェクトには、カスタム項目の優先メール(Prior_Email__c)があります。以上のトリガーは、メール項目(Email)が変更されるたびに、現在のメール(Email)を優先メール項目(Prior_Email__c)にコピーするものです。\nこのトリガーはどのタイプの組み込み例外を発生させますか。",
        "choices": ["NullPointerException", "CompileTimeException", "DmlException", "LimitException"],
        "correct": ["DmlException"],
        "explanations":["NullPointerException", "CompileTimeException", "DmlException", "LimitException"],
        "descriptions":[
            "これは不正解です。このトリガーでは、trigger.oldMap.get(leadRecord.Id).Emailを使用していますが、before updateトリガーのコンテキストでは、trigger.oldMapは更新前のレコードのマップを持っているため、この例外は発生しないと考えられます。",
            "これは不正解です。Apexの組み込み例外に「CompileTimeException」というものは存在しません。また、このトリガーのコードは正しくコンパイルされるため、コンパイル時の例外は発生しません。",
            "これは正解です。このトリガーは「before update」のタイミングで動作します。このタイミングでは、データベースに保存される前のレコードの状態を変更することができます。しかし、trigger.newのレコードに対して直接update操作を試みると、Salesforceはそれを許可しません。なぜなら、それは再帰的なトリガーの実行や無限ループを引き起こす可能性があるからです。このトリガーの中で、if(leadsToUpdate.size() > 0) { update leadsToUpdate; }という部分があります。ここでleadsToUpdateリストを更新しようとすると、このリストはtrigger.newの一部として扱われるため、DmlExceptionが発生します。簡単に言えば、before updateの中で既に更新中のレコードを再度更新しようとすると、エラーが発生するのです。",
            "これは不正解です。このトリガーでは、DML操作はif(leadsToUpdate.size() > 0)の条件の下で行われています。しかし、このトリガーのコード自体は、DML操作やSOQLクエリの制限を超えるような処理を行っていないため、LimitExceptionは発生しないと考えられます。"
        ]
    },
    {
        "number": "167",
        "question": "サポートされていない言語を使用できるプラットフォーム機能はどれですか。2つ選びなさい。",
        "choices": ["Heroku Acm", "Docker", "Buildpacks", "App.json"],
        "correct": ["Docker", "Buildpacks"],
        "explanations":["Heroku Acm", "Docker", "Buildpacks", "App.json"],
        "descriptions":[
            "これは不正解です。Heroku ACMは、HerokuアプリケーションのSSL/TLS証明書を自動的に管理する機能です。これは言語のサポートとは関係ありません。",
            "これは正解です。Dockerはコンテナ技術を使用してアプリケーションとその依存関係をパッケージ化するツールです。Dockerを使用すると、サポートされていない言語や特定のバージョンのランタイムも含め、任意の環境を構築して実行できます。",
            "これは正解です。BuildpacksはHerokuや他のクラウドプラットフォームで使用されるもので、アプリケーションのソースコードを実行可能なアプリケーションに変換するためのスクリプトのセットです。カスタムBuildpacksを使用することで、Herokuなどのプラットフォームでデフォルトでサポートされていない言語やフレームワークをサポートすることができます。",
            "これは不正解です。App.jsonはHerokuアプリケーションの設定を定義するためのマニフェストファイルです。これはアプリケーションのデプロイや設定に関連しており、言語のサポートとは直接関係ありません。"
        ]
    },
    {
        "number": "168",
        "question": "開発者は、テストメソッドのガバナ制限をどのように回避すべきでしょうか。",
        "choices": ["レコードを作成するメソッドで@TestVisibleを使用する。", "Test.loadData()を使用して、静的リソースからデータをロードする。", "既存のデータを使用するために、@IsTest(SeeAllData=true)を使用する。", "Test.startTest()を使用して、ガバナ制限をリセットする。"],
        "correct": ["Test.startTest()を使用して、ガバナ制限をリセットする。"],
        "explanations":["レコードを作成するメソッドで@TestVisibleを使用する。", "Test.loadData()を使用して、静的リソースからデータをロードする。", "既存のデータを使用するために、@IsTest(SeeAllData=true)を使用する。", "Test.startTest()を使用して、ガバナ制限をリセットする。"],
        "descriptions":[
            "これは不正解です。@TestVisibleアノテーションは、テストクラス内でのみアクセス可能なプライベートメンバーにアクセスするために使用されます。しかし、これはガバナ制限を回避するためのメカニズムではありません。",
            "これは不正解です。この選択肢は誤解を招く可能性があります。確かにTest.loadData()メソッドは、静的リソースからテストデータをロードし、DML操作に関連するデータベースのオーバーヘッドを軽減するのに役立ちます。これにより、テストメソッドの実行中のDMLステートメントやSOQLクエリの制限に対する影響を減らすことができ、テストのパフォーマンスが向上します。しかし、この方法はガバナ制限を完全に「回避」する手段ではなく、特にCPU時間などの他の種類のガバナ制限に対しては直接的な解決策にはなりません。",
            "これは不正解です。@IsTest(SeeAllData=true)は、テストクラスが本番環境のデータにアクセスすることを許可しますが、これは一般的には推奨されません。このアプローチはテストの信頼性を低下させ、意図しないデータ変更やガバナ制限の問題を引き起こす可能性があります。",
            "これは正解です。Test.startTest()とTest.stopTest()は、テストメソッド内でガバナ制限をリセットするために使用されます。これにより、テストメソッド内で行われる特定の操作のために新しいガバナ制限のコンテキストを提供し、これらの制限を適切に管理するのに役立ちます。"
        ]
    },
    {
        "number": "169",
        "question": "searchTermを指定してAccountsのリストを返すApexメソッドgetAccountsは、Lightning Webコンポーネントで使用できます。getAccountsメソッドを使用するLightning Webコンポーネントのプロパティの正しい定義は何ですか。",
        "choices": ["@wire(getAccounts, {searchTerm: ‘$searchTerm’})\naccountList;", "@wire(getAccounts, ‘$searchTerm’)\naccountList;", "@AuraEnabled(getAccounts, {searchTerm: ‘$searchTerm’})\naccountList;", "@AuraEnabled(getAccounts, ‘$searchTerm’)\naccountList;"],
        "correct": ["@wire(getAccounts, {searchTerm: ‘$searchTerm’})\naccountList;"],
        "explanations":["@wire(getAccounts, {searchTerm: ‘$searchTerm’})\naccountList;", "@wire(getAccounts, ‘$searchTerm’)\naccountList;", "@AuraEnabled(getAccounts, {searchTerm: ‘$searchTerm’})\naccountList;", "@AuraEnabled(getAccounts, ‘$searchTerm’)\naccountList;"],
        "descriptions":[
            "これは正解です。@wireアノテーションを使用して、getAccountsというApexメソッドからデータを取得しています。searchTermという名前のパラメータに動的にコンポーネントのsearchTermプロパティの値を渡しています。そして、取得したデータはaccoutListというプロパティに格納されます。",
            "これは不正解です。@wireアノテーションでパラメータを渡す際には、オブジェクト形式で指定する必要があります。",
            "これは不正解です。@AuraEnabledはApexクラスのメソッドをAuraコンポーネントやLWCで使用可能にするためのアノテーションです。しかし、LWC内でこのように直接使用することはできません。",
            "これは不正解です。@AuraEnabledアノテーションは、ApexメソッドをAuraコンポーネントやLWCで使用するためのものであり、LWC内でこのような形式で使用することはできません。"
        ]
    },
    {
        "number": "170",
        "question": "デバッグログに関する3つの記述のうち、正しいものはどれですか。3つ選びなさい。",
        "choices": ["デバッグログレベルは累積され、FINEログレベルにはDEBUG、INFO、WARN、ERRORレベルで記録されたすべてのイベントが含まれます。", "デバッグログの最大サイズは5MBです。", "最新の20件のデバッグログのみが保存されます。", "デバッグログは、特定のユーザー、クラス、およびトリガーに設定できます。", "システムデバッグログは24時間保存されます。"],
        "correct": ["デバッグログレベルは累積され、FINEログレベルにはDEBUG、INFO、WARN、ERRORレベルで記録されたすべてのイベントが含まれます。", "デバッグログは、特定のユーザー、クラス、およびトリガーに設定できます。", "システムデバッグログは24時間保存されます。"],
        "explanations":["デバッグログレベルは累積され、FINEログレベルにはDEBUG、INFO、WARN、ERRORレベルで記録されたすべてのイベントが含まれます。", "デバッグログの最大サイズは5MBです。", "最新の20件のデバッグログのみが保存されます。", "デバッグログは、特定のユーザー、クラス、およびトリガーに設定できます。", "システムデバッグログは24時間保存されます。"],
        "descriptions":[
            "これは正解です。デバッグログレベルは累積され、FINEレベルを選択すると、DEBUG、INFO、WARN、ERRORレベルでログ記録されたすべてのイベントが含まれます。",
            "これは不正解です。デバッグログの最大サイズは20MBです。",
            "これは不正解です。保存されるデバッグログのサイズと保存期間に制限はありますが、件数に制限は設定されていません。",
            "これは正解です。デバッグログは特定のユーザー、クラス、トリガーに対して設定できます。",
            "これは正解です。システムデバッグログは24時間保存され、監視デバッグログは7日間保持されます。"
        ]
    },
    {
        "number": "171",
        "question": "AccountListという名前のList<Account>コレクション内の各Accountを反復処理するための有効な選択肢はどれですか。2つ選びなさい。",
        "choices": ["for (Integer i=0; i < AccountList.Size(); i++) {…}", "for (Account theAccount : AccountList) {…}", "for (AccountList) {…}", "for (List L : AccountList) {…}"],
        "correct": ["for (Integer i=0; i < AccountList.Size(); i++) {…}", "for (Account theAccount : AccountList) {…}"],
        "explanations":["for (Integer i=0; i < AccountList.Size(); i++) {…}", "for (Account theAccount : AccountList) {…}", "for (AccountList) {…}", "for (List L : AccountList) {…}"],
        "descriptions":[
            "これは正解です。これは従来のforループのバリエーションに該当します。このループは、初期化ステートメント、終了条件、および増分ステートメントを使用して、指定された回数だけコードブロックを実行します。",
            "これは正解です。これはリストやセットの反復処理を行うforループのバリエーションに該当します。このループは、リストやセットの各要素を反復処理します。変数は、リストやセットの各要素のデータ型と一致する必要があります。",
            "これは不正解です。この構文は正しくありません。反復処理するための変数や条件が指定されていません。",
            "これは不正解です。AccountListはList型で、その中の要素は取引先オブジェクトです。したがって、List Lという型の変数でAccountListを反復処理することは構文的に正しくありません。"
        ]
    },
    {
        "number": "172",
        "question": "次のコードの実行時間を短縮するために、開発者が取るべき行動はどれですか。",
        "following-code": [
            "List<Account> allAccounts = [SELECT Id FROM Account];",
            "List<Contact> allContacts = [SELECT Id, AccountId FROM Contact];\n",
            "for (Account a : allAccounts) {",
            "    for (Contact c : allContacts) {",
            "        if (c.AccountId == a.Id) {",
            "            // do work",
            "        }",
            "    }",
            "}"
        ],
        "choices": ["取引先責任者のSOQLにGROUP BYオプションを追加する", "allaccountsに対してMap<Id,Account>を使用する", "SOQL用のApexヘルパークラスを作成する", "Contactループの中にAccountループを入れる"],
        "correct": ["allaccountsに対してMap<Id,Account>を使用する"],
        "explanations":["取引先責任者のSOQLにGROUP BYオプションを追加する", "allaccountsに対してMap<Id,Account>を使用する", "SOQL用のApexヘルパークラスを作成する", "Contactループの中にAccountループを入れる"],
        "descriptions":[
            "これは不正解です。このコードの問題は、ネストされたループの中での比較にあります。GROUP BYオプションを追加することは、この問題を解決するものではありません。",
            "これは正解です。Map<Id, Account>を使用することで、各ContactのAccountIdをキーとして関連するAccountを効率的に検索できます。これにより、ネストされたループを使用する必要がなくなり、実行時間が大幅に短縮されます。",
            "これは不正解です。ヘルパークラスの作成は、コードの整理や再利用を容易にするためのものであり、実行時間の短縮には直接的には寄与しません。",
            "これは不正解です。ループの順序を変更するだけでは、実行時間の問題は解決されません。ネストされたループの問題は、ループの順序に関係なく発生します。"
        ]
    },
    {
        "number": "173",
        "question": "開発者は、AccountレコードまたはContactレコードを処理できるApexメソッドが必要です。開発者はどのメソッドを使用する必要がありますか。",
        "choices": ["Public void doWork(Account || Contact)", "Public void doWork(Record theRecord)", "Public void doWork(sObject theRecord)", "Public void doWork(Account Contact)"],
        "correct": ["Public void doWork(sObject theRecord)"],
        "explanations":["Public void doWork(Account || Contact)", "Public void doWork(Record theRecord)", "Public void doWork(sObject theRecord)", "Public void doWork(Account Contact)"],
        "descriptions":[
            "これは不正解です。Apexのメソッドのパラメータとして、||を使用して複数のデータ型を指定することはできません。この構文はApexでは無効です。",
            "これは不正解です。ApexにはRecordというデータ型は存在しません。",
            "これは正解です。sObjectはSalesforceのすべてのオブジェクト(標準オブジェクト、カスタムオブジェクト)の基本データ型です。このメソッドは、AccountやContactなどの任意のsObject型のレコードを引数として受け取ることができます。",
            "これは不正解です。この構文はApexでは無効です。メソッドのパラメータとして複数のデータ型を同時に指定することはできません。"
        ]
    },
    {
        "number": "174",
        "question": "開発者は、複数のLightningウェブコンポーネントを含む天気アプリを作成しました。コンポーネントの１つはToggleと呼ばれ、華氏または摂氏の単位を切り替えます。Toggleコンポーネントでユーザーが華氏から摂氏、またはその逆に切り替えると、その情報はTemperatureコンポーネントに送信され、温度が変換されて表示されます。これを実現するには、どのような方法が推奨されますか。",
        "choices": ["コンポーネント間の通信を処理するカスタムイベントを作成する。", "ToggleコンポーネントでTemperatureコンポーネントのメソッドを呼び出す。", "コンポーネント間の通信にアプリケーションイベントを使用する。", "コンポーネント間の通信にはLightning Message Serviceを使用する。"],
        "correct": ["コンポーネント間の通信を処理するカスタムイベントを作成する。"],
        "explanations":["コンポーネント間の通信を処理するカスタムイベントを作成する。", "ToggleコンポーネントでTemperatureコンポーネントのメソッドを呼び出す。", "コンポーネント間の通信にアプリケーションイベントを使用する。", "コンポーネント間の通信にはLightning Message Serviceを使用する。"],
        "descriptions":[
            "これは正解です。カスタムイベントは、Lightning Web Components (LWC) 内のコンポーネント間の通信に特に適しています。特に、親子関係や同じ階層にあるコンポーネント間でのデータの受け渡しに非常に効果的です。今回のシナリオでは、Toggle コンポーネントと Temperature コンポーネントという2つのLWCコンポーネント間での通信が必要なため、この方法が最も推奨されます。",
            "これは不正解です。LWCでは、他のコンポーネントのメソッドを直接呼び出すことは推奨されません。コンポーネント間の疎結合を保つため、イベントベースの通信が好ましいです。",
            "これは不正解です。アプリケーションイベントはAuraコンポーネントで使用され、LWCではサポートされていません。LWCでは、カスタムイベントやLightning Message Serviceが推奨されます。",
            "これは不正解です。Lightning Message Serviceは、LWC、Auraコンポーネント、Visualforceページ間での通信を可能にするサービスですが、同じLWC内のコンポーネント間の通信には、カスタムイベントがより適しています。このオプションは、異なる技術間での通信やページ全体にわたる広範な通信が必要な場合に特に役立ちますが、今回のシナリオでは不適切です。"
        ]
    },
    {
        "number": "175",
        "question": "開発者が組織内でテストを実行するための方法は何ですか。2つ選びなさい。",
        "choices": ["Tooling API", "開発者コンソール", "メタデータ API", "Bulk API"],
        "correct": ["Tooling API", "開発者コンソール"],
        "explanations":["Tooling API", "開発者コンソール", "メタデータ API", "Bulk API"],
        "descriptions":[
            "これは正解です。Tooling APIは、開発者がSalesforceのカスタマイズをプログラムで管理するためのAPIです。これには、Apexテストの実行などの開発タスクも含まれます。",
            "これは正解です。開発者コンソールは、Apexコードの記述、実行、デバッグ、およびテストを行うための統合開発環境(IDE)です。開発者はここでApexテストを実行することができます。",
            "これは不正解です。メタデータ APIは、組織のメタデータを操作するためのAPIです。これは主に組織のカスタマイズや設定をデプロイまたは取得するために使用されますが、テストの実行には使用されません。",
            "これは不正解です。Bulk APIは、大量のレコードをSalesforceにインポートまたはエクスポートするためのAPIです。これはテストの実行とは関係ありません。"
        ]
    },
    {
        "number": "176",
        "question": "ある開発者が2つのカスタムコントローラ拡張を持っており、それぞれにsave()メソッドがあります。次のVisualforceページでは、どのsave()メソッドが呼び出されますか。",
        "following-code": [
            "<apex:page standardController=”Account” extensions=”ExtensionA, ExtensionB”>",
            "    <apex:commandButton action=”{!save}” value=”Save” />",
            "</apex:page>"
        ],
        "choices": ["ExtensionB save()", "Standard controller save()", "ExtensionA save()", "ランタイムエラーが発生する"],
        "correct": ["ExtensionA save()"],
        "explanations":["ExtensionB save()", "Standard controller save()", "ExtensionA save()", "ランタイムエラーが発生する"],
        "descriptions":[
            "これは不正解です。ExtensionBのsave()メソッドは、ExtensionAにsave()メソッドが存在しない場合にのみ呼び出されます。しかし、この問題の文脈では、両方の拡張にsave()メソッドが存在すると明記されているため、ExtensionBのsave()メソッドは呼び出されません。",
            "これは不正解です。標準コントローラのsave()メソッドは、拡張にsave()メソッドが存在しない場合にのみ呼び出されます。この問題では、両方の拡張にsave()メソッドが存在するため、標準コントローラのメソッドは呼び出されません。",
            "これは正解です。Visualforceページで複数のコントローラ拡張を指定する場合、最初にリストされた拡張のメソッドが優先されます。したがって、この場合はExtensionAのsave()メソッドが呼び出されます。",
            "これは不正解です。この設定ではランタイムエラーは発生しません。正しくExtensionAのsave()メソッドが呼び出されます。"
        ]
    },
    {
        "number": "177",
        "question": "以下のコードから、コントローラ変数を作成するために使用できるステートメントはどれですか。3つ選びなさい。",
        "following-code": [
            "public class AccountListController {",
            "    public List<Account> getAccounts() {",
            "        return controller.getRecords();",
            "    }",
            "}"
        ],
        "choices": ["Apexpages.standardsetcontroller controller = new apexpages.standardsetcontroller(database.query(‘select id from account’));", "Apexpages.standardsetcontroller controller = new apexpages.standardsetcontroller(database.getquerylocator(‘select id from account’));", "Apexpages.standardcontroller controller = new apexpages.standardcontroller(database.getquerylocator(‘select id from account’));", "Apexpages.standardcontroller controller = new apexpages.standardcontroller([select id from account]);", "Apexpages.standardsetcontroller controller = new apexpages.standardsetcontroller(database.getquerylocator([select id from account]));"],
        "correct": ["Apexpages.standardsetcontroller controller = new apexpages.standardsetcontroller(database.query(‘select id from account’));", "Apexpages.standardsetcontroller controller = new apexpages.standardsetcontroller(database.getquerylocator(‘select id from account’));", "Apexpages.standardsetcontroller controller = new apexpages.standardsetcontroller(database.getquerylocator([select id from account]));"],
        "explanations":["Apexpages.standardsetcontroller controller = new apexpages.standardsetcontroller(database.query(‘select id from account’));", "Apexpages.standardsetcontroller controller = new apexpages.standardsetcontroller(database.getquerylocator(‘select id from account’));", "Apexpages.standardcontroller controller = new apexpages.standardcontroller(database.getquerylocator(‘select id from account’));", "Apexpages.standardcontroller controller = new apexpages.standardcontroller([select id from account]);", "Apexpages.standardsetcontroller controller = new apexpages.standardsetcontroller(database.getquerylocator([select id from account]));"],
        "descriptions":[
            "これは正解です。StandardSetControllerは、sObjectのリストを引数として受け取ることができます。このステートメントでは、database.queryを使用してAccountのIDを取得し、それをStandardSetControllerのコンストラクタに渡しています。",
            "これは正解です。StandardSetControllerは、Database.QueryLocatorオブジェクトを引数として受け取ることもできます。このステートメントでは、database.getquerylocatorを使用してクエリロケータを取得し、それをStandardSetControllerのコンストラクタに渡しています。",
            "これは不正解です。StandardControllerは、単一のsObjectレコードを引数として受け取る必要があります。Database.QueryLocatorオブジェクトは受け取れません。さらに、Database.QueryLocatorは複数のレコードを返す可能性がありますが、StandardControllerは単一のレコードのみを期待しています。",
            "これは不正解です。このステートメントは、SOQLクエリを使用して取引先オブジェクトのすべてのレコードのIDを取得しようとします。もし取引先オブジェクトに2つ以上のレコードが存在する場合、”List has more than 1 row for assignment to SObject”というエラーが発生します。StandardControllerのコンストラクタは、単一のsObjectレコードのみを受け取ることを期待しています。",
            "これは正解です。Database.getQueryLocatorメソッドは、SOQLクエリ文字列または直接のSOQLクエリを引数として受け取ることができます。このステートメントでは、直接のSOQLクエリを使用してDatabase.getQueryLocatorを呼び出し、その結果をStandardSetControllerのコンストラクタに渡しています。"
        ]
    },
    {
        "number": "178",
        "question": "ある開発者が、StatusComponentというLightning Webコンポーネントを作成し、Accountレコードページに挿入しました。このコンポーネントを利用できるようにするために、開発者が行うべきことはどれですか。2つ選びなさい。",
        "choices": ["<target>Lightning_RecordPage</target>をstatusComponent.js-meta.xmlファイルに追加する。", "<target>Lightning_RecordPage</target>をstatusComponent.jsファイルに追加する。", "<masterLabel>Account</masterLabel>をstatusComponent.js-meta.xmlファイルに追加する。", "<isExposed>true</isExposed>をstatusComponent.js-meta.xmlファイルに追加する。"],
        "correct": ["<target>Lightning_RecordPage</target>をstatusComponent.js-meta.xmlファイルに追加する。", "<isExposed>true</isExposed>をstatusComponent.js-meta.xmlファイルに追加する。"],
        "explanations":["<target>Lightning_RecordPage</target>をstatusComponent.js-meta.xmlファイルに追加する。", "<target>Lightning_RecordPage</target>をstatusComponent.jsファイルに追加する。", "<masterLabel>Account</masterLabel>をstatusComponent.js-meta.xmlファイルに追加する。", "<isExposed>true</isExposed>をstatusComponent.js-meta.xmlファイルに追加する。"],
        "descriptions":[
            "これは正解です。手順3に該当します。",
            "これは不正解です。.jsファイルはコンポーネントのロジックを記述する場所であり、ページのタイプや利用可能なオブジェクトを指定するための場所ではありません。このような設定は.js-meta.xmlファイルに追加する必要があります。",
            "これは不正解です。<masterLabel>タグはコンポーネントの表示名を指定するためのもので、特定のオブジェクトにコンポーネントを関連付けるためのものではありません。",
            "これは正解です。手順2に該当します。"
        ]
    },
    {
        "number": "179",
        "question": "以下のコードを実行した場合、xの値は何になりますか。",
        "following-code": [
            "Boolean isOK;",
            "Integer x;",
            "String theString = 'Hello';\n",
            "if (isOK == false && theString == 'Hello') {",
            "    x = 1;",
            "} else if (isOK == true && theString =='Hello') {",
            "    x = 2;",
            "} else if (isOK != null && theString == 'Hello') {",
            "    x = 3;",
            "} else {",
            "    x = 4;",
            "}"
        ],
        "choices": ["1", "2", "3", "4"],
        "correct": ["4"],
        "explanations":["1", "2", "3", "4"],
        "descriptions":[
            "",
            "",
            "",
            "デバッグログには 4 が表示されます。\n以下がコードの実行フローです。\n\n１．isOKの初期値は設定されていないため、nullです。\n２．theStringの初期値は'Hello'です。\n３．最初のif条件isOK == false && theString == 'Hello'を評価します。isOKはnullなので、この条件はfalseとなります。\n４．次にelse if条件isOK == true && theString =='Hello'を評価します。isOKはnullなので、この条件もfalseとなります。\n５．さらに次のelse if条件isOK != null && theString == 'Hello'を評価します。isOKはnullなので、この条件もfalseとなります。\n６．3つの条件がすべてfalseなので、最後のelseブロックが実行されます。\n７．xに4が代入されます。"
        ]
    },
    {
        "number": "180",
        "question": "アプリケーションイベントは従来のpublish-subscribeモデルに従っています。イベントを発生させるには、どのメソッドを使用しますか。",
        "choices": ["emit()", "fireEvent()", "fire()", "registerEvent()"],
        "correct": ["fire()"],
        "explanations":["emit()", "fireEvent()", "fire()", "registerEvent()"],
        "descriptions":[
            "これは不正解です。Aura コンポーネントには emit() メソッドは存在しません。",
            "これは不正解です。Aura コンポーネントには fireEvent() メソッドは存在しません。",
            "これは正解です。コンポーネントイベントを起動するためにはfire()メソッドを使用します。具体的には、cmp.getEvent(”evtName”).fire();のように使用されます。",
            "これは不正解です。Aura コンポーネントにはregisterEvent()メソッドは存在しません。"
        ]
    },
    {
        "number": "181",
        "question": "開発者は、取引先オブジェクトにトリガーを作成し、そのトリガーが正常に一度に多数のレコードを処理できるかテストしたいと考えています。開発者チームは、一意の名前を持つ200個の取引先レコードでトリガーをテストする必要があると判断しました。\n最小限のコード量で単体テスト内のテストデータを作成するためには、どのような作業を行う必要がありますか。2つ選びなさい。",
        "choices": ["テストデータを含む静的リソースを作成します。", "テストクラスで@isTest(isParallel=true)を使用します。", "テストクラスで@isTest(seeAllData=true)を使用します。", "Test.loadDataを使用して、テストメソッドにデータを入力します。"],
        "correct": ["テストデータを含む静的リソースを作成します。", "Test.loadDataを使用して、テストメソッドにデータを入力します。"],
        "explanations":["テストデータを含む静的リソースを作成します。", "テストクラスで@isTest(isParallel=true)を使用します。", "テストクラスで@isTest(seeAllData=true)を使用します。", "Test.loadDataを使用して、テストメソッドにデータを入力します。"],
        "descriptions":[
            "これは正解です。静的リソースを使用してテストデータを保存し、Test.loadData メソッドを利用してそれらのデータをテストクラスでロードすることは、大量のテストデータを効率的に作成する有効な方法です。",
            "これは不正解です。@isTest(isParallel=true) アノテーションは、テストクラスの並列実行を許可するものであり、テストデータの作成とは関係ありません。",
            "これは不正解です。@isTest(seeAllData=true) は、テストメソッドが本番環境のデータにアクセスすることを許可するものです。テストデータの作成には関係なく、通常は避けるべき実施方法です。",
            "これは正解です。Test.loadData メソッドは、静的リソースからのデータをロードして、テスト環境内で使用するための効率的な方法です。これは、大量のテストデータを迅速かつ効率的に作成するのに適しています。"
        ]
    },
    {
        "number": "182",
        "question": "開発者が非同期メソッドまたはfutureメソッドに関する情報を確認できる場所はどこですか。2つ選びなさい。",
        "choices": ["Apex ジョブ", "一時停止中の失敗したフローインタビュー", "[時間ベースのワークフロー]モニター", "Apex Flex キュー"],
        "correct": ["Apex ジョブ", "Apex Flex キュー"],
        "explanations":["Apex ジョブ", "一時停止中の失敗したフローインタビュー", "[時間ベースのワークフロー]モニター", "Apex Flex キュー"],
        "descriptions":[
            "これは正解です。Apexジョブページは、非同期Apexの実行に関する情報を提供します。これには、@futureメソッドやバッチApex、スケジュールされたApexの実行情報が含まれます。",
            "これは不正解です。一時停止中の失敗したフローインタビューは、一時停止されたフローのインスタンスに関する情報を提供します。非同期メソッドやfutureメソッドの実行情報とは関係ありません。",
            "これは不正解です。[時間ベースのワークフロー]モニターは、時間ベースのワークフローアクションの実行を監視するためのものです。非同期メソッドやfutureメソッドの実行情報とは関係ありません。",
            "これは正解です。Apex Flexキューは、バッチApexジョブの待機行列を表示するためのものです。非同期処理の一部として、バッチApexジョブの実行順序を管理するために使用されます。"
        ]
    },
    {
        "number": "183",
        "question": "開発者は、Salesforce の様々な種類のケースを独立した要件でテストできるようにするために、一連のテスト全体の基本データセット (取引先、取引先責任者、商品、納入商品) を作成する必要があります。\n各単体テストに必要なデータを効率的に生成できるのはどの方法でしょうか。",
        "choices": ["viodメソッドで@TestSetupを使用する", "単体テストクラスの先頭に@isTest(seeAllData = true)を追加する", "単体テストのTest.startTest()の前にテストデータを作成する", "スタブAPIを使ってモックを作成する"],
        "correct": ["viodメソッドで@TestSetupを使用する"],
        "explanations":["viodメソッドで@TestSetupを使用する", "単体テストクラスの先頭に@isTest(seeAllData = true)を追加する", "単体テストのTest.startTest()の前にテストデータを作成する", "スタブAPIを使ってモックを作成する"],
        "descriptions":[
            "これは正解です。@TestSetupを使用すると、単体テストの前に一度だけ実行されるセットアップメソッドを作成できます。このメソッド内で作成されたデータは、その後のすべてのテストメソッドで利用できるため、基本データセットを効率的に生成するのに適しています。",
            "これは不正解です。@isTest(seeAllData = true)は、テストメソッドが実際の組織データにアクセスできるようにするものですが、通常は使用を避けるべきです。テストデータの分離と組織データへの依存を避けるため、テスト内で独自のデータを生成することが推奨されます。",
            "これは不正解です。Test.startTest()とTest.stopTest()は、テストのガバナ制限を分離するために使用されますが、テストデータの生成を効率化するためのものではありません。",
            "これは不正解です。スタブAPIは、外部システムへの呼び出しを模倣するために使用されるもので、テストデータの生成には関係ありません。"
        ]
    },
    {
        "number": "184",
        "question": "メタデータAPIを使用してデプロイできるコンポーネントはどれですか。2つ選びなさい。",
        "choices": ["ケースのレイアウト", "ケースフィードのレイアウト", "コンソールレイアウト", "取引先のレイアウト"],
        "correct": ["ケースのレイアウト", "取引先のレイアウト"],
        "explanations":["ケースのレイアウト", "ケースフィードのレイアウト", "コンソールレイアウト", "取引先のレイアウト"],
        "descriptions":[
            "これは正解です。メタデータAPIを使用して、ケースのレイアウトをデプロイすることができます。ケースレイアウトは、ケースオブジェクトのページレイアウトを定義するためのもので、メタデータAPIを通じて操作が可能です。",
            "これは不正解です。メタデータAPIを使用してケースフィードのレイアウトを直接デプロイすることはできません。変更を適用するためには手動で行う必要があります。",
            "これは不正解です。メタデータAPIを使用してコンソールレイアウトを直接デプロイすることはできません。変更を適用するためには手動で行う必要があります。",
            "これは正解です。メタデータAPIを使用して、取引先のレイアウトをデプロイすることができます。取引先レイアウトは、取引先オブジェクトのページレイアウトを定義するためのもので、メタデータAPIを通じて操作が可能です。"
        ]
    },
    {
        "number": "185",
        "question": "多くの開発者からなるチームが、本番組織と同じ構成を持つ個々の組織で作業しています。このシナリオに最も適しているのはどのタイプの組織ですか。",
        "choices": ["Developer Sandbox", "Developer Edition", "Full Sandbox", "Partner Developer Edition"],
        "correct": ["Developer Sandbox"],
        "explanations":["Developer Sandbox", "Developer Edition", "Full Sandbox", "Partner Developer Edition"],
        "descriptions":[
            "これは正解です。Developer Sandboxは隔離された環境での開発とテストを目的としており、本番組織の設定(メタデータ)のコピーが含まれます。多くの開発者がそれぞれの組織で作業する際に、本番組織と同じ構成を持つ環境が必要な場合に適しています。",
            "これは不正解です。Developer Editionは、Salesforceの機能を試すための独立した組織ですが、本番組織のコピーではありません。",
            "これは不正解です。Full Sandboxは本番組織の完全なコピーを提供しますが、1つの組織に対して1つしか作成できない制限があるため、多数の開発者がそれぞれ持つことはできません。",
            "これは不正解です。Partner Developer Editionは、Dev Hub パートナービジネス組織から作成できるスクラッチ組織の一つです。これは、パートナーがSalesforceの機能を試すための独立した組織として提供されます。しかし、このシナリオにおいて、本番組織と同じ構成を持つ個々の組織での作業には適していません。"
        ]
    },
    {
        "number": "186",
        "question": "Universal Containers社は、Salesforce組織内のすべてのデータと添付ファイルを月に1回バックアップしたいと考えています。この要件を満たすために、開発者はどのアプローチを使用すべきでしょうか。",
        "choices": ["データローダーのコマンドラインを使用します。", "データエクスポートのスケジュールされたジョブを定義します。", "スケジュール可能なApexクラスを作成します。", "レポートをスケジュールします。"],
        "correct": ["データエクスポートのスケジュールされたジョブを定義します。"],
        "explanations":["データローダーのコマンドラインを使用します。", "データエクスポートのスケジュールされたジョブを定義します。", "スケジュール可能なApexクラスを作成します。", "レポートをスケジュールします。"],
        "descriptions":[
            "これは不正解です。データローダーのコマンドラインは、特定のオブジェクトのデータをエクスポート、インポート、更新、削除するためのものですが、Salesforce組織内のすべてのデータと添付ファイルを自動的にエクスポートするためのものではありません。",
            "これは正解です。Salesforceの[設定] > [データのエクスポート] > [マンスリーエクスポートサービス] > [エクスポートをスケジュール]から、月に1回などの頻度指定や添付ファイルを含めるなどのオプション設定を行い、全オブジェクトのバックアップデータをエクスポートさせることができます。",
            "これは不正解です。Apexを使用してデータを直接エクスポートすることはできません。Apexは主にビジネスロジックの実行やデータの操作に使用されますが、大量のデータのバックアップには適していません。",
            "これは不正解です。レポートのスケジュールと登録は、特定のレポートの結果を定期的に取得するためのもので、手動でレポートを実行せずに、最も関心のある総計値について常に情報を把握するための通知を受信することができます。しかし、組織内のすべてのデータと添付ファイルをバックアップするためには、この方法は適していません。"
        ]
    },
    {
        "number": "187",
        "question": "トリガーが同じオブジェクトとイベントに関連付けられている場合の実行順序に関して正しい説明はどれですか。",
        "choices": ["トリガーはトリガー名のアルファベット順に実行されます。", "トリガーの実行順序は保証されません。", "変更された順序で実行されます。", "トリガーは作成された順序で実行されます。"],
        "correct": ["トリガーの実行順序は保証されません。"],
        "explanations":["トリガーはトリガー名のアルファベット順に実行されます。", "トリガーの実行順序は保証されません。", "変更された順序で実行されます。", "トリガーは作成された順序で実行されます。"],
        "descriptions":[
            "これは不正解です。Salesforceでは、トリガーの実行順序はトリガー名のアルファベット順に基づいているわけではありません。",
            "これは正解です。Salesforceでは、同じオブジェクトとイベントに関連付けられている複数のトリガーの実行順序は保証されていません。そのため、特定の順序でトリガーを実行する必要がある場合は、複数のトリガーを1つのトリガーに統合し、その中で明示的な順序でロジックを実行する必要があります。",
            "これは不正解です。トリガーの実行順序は、変更された順序に基づいているわけではありません。",
            "これは不正解です。トリガーの実行順序は、作成された順序に基づいているわけではありません。"
        ]
    },
    {
        "number": "188",
        "question": "開発者は、インスタンス化できないShippingCalculatorクラスを作成する必要があり、サブクラスがオーバーライドできるcalculateメソッドの実用的なデフォルト実装を含める必要があります。 ShippingCalculatorクラスの正しい実装はどれですか。",
        "choices": ["Public abstract class ShippingCalculator {\n    public override calculate() { /*implementation*/ }\n}", "Public abstract class ShippingCalculator {\n    public virtual void calculate() { /*implementation*/ }\n}", "Public abstract class ShippingCalculator {\n    public abstract calculate() { /*implementation*/ }\n}", "Public abstract class ShippingCalculator {\n    public void calculate() { /*implementation*/ }\n}"],
        "correct": ["Public abstract class ShippingCalculator {\n    public virtual void calculate() { /*implementation*/ }\n}"],
        "explanations":["Public abstract class ShippingCalculator {\n    public override calculate() { /*implementation*/ }\n}", "Public abstract class ShippingCalculator {\n    public virtual void calculate() { /*implementation*/ }\n}", "Public abstract class ShippingCalculator {\n    public abstract calculate() { /*implementation*/ }\n}", "Public abstract class ShippingCalculator {\n    public void calculate() { /*implementation*/ }\n}"],
        "descriptions":[
            "これは不正解です。overrideキーワードは、サブクラスで既存のvirtualまたはabstractメソッドをオーバーライドするために使用されます。しかし、このクラスにはオーバーライドする元となるvirtualまたはabstractメソッドが存在しません。また、calculateメソッドの戻り値の型が指定されていません。",
            "これは正解です。virtualキーワードは、メソッドがサブクラスでオーバーライドされることを許可するために使用されます。この選択肢では、calculateメソッドはデフォルトの実装を持ち、サブクラスでオーバーライドすることができます。",
            "これは不正解です。abstractメソッドは実装(コードブロック)を持つことができません。この選択肢では、abstractメソッドに具体的な実装が含まれているため、不正確です。また、calculateメソッドの戻り値の型が指定されていません。",
            "これは不正解です。この選択肢のcalculateメソッドは、サブクラスでオーバーライドすることができない普通のメソッドとして定義されています。オーバーライドを許可するためには、calculateメソッドにvirtualキーワードが必要です。"
        ]
    },
    {
        "number": "189",
        "question": "継続的インテグレーションの一環として、デプロイと単体テストの実行をスクリプト化するために、開発者は何を使用する必要がありますか。",
        "choices": ["開発者コンソール", "VS Code", "Salesforce CLI", "匿名実行"],
        "correct": ["Salesforce CLI"],
        "explanations":["開発者コンソール", "VS Code", "Salesforce CLI", "匿名実行"],
        "descriptions":[
            "これは不正解です。開発者コンソールは、コードの編集やデバッグ、SOQLクエリの実行など、Salesforceの開発作業をサポートするツールです。しかし、継続的インテグレーションの一環としてのデプロイや単体テストの実行を自動化するためのスクリプト化には適していません。",
            "これは不正解です。VS Codeは、Salesforceの開発作業をサポートするコードエディターの一つです。Salesforceの拡張機能を使用することで、VS Codeからもデプロイやテストの実行は可能ですが、継続的インテグレーションの一環としてのスクリプト化には、Salesforce CLIの使用が必要です。",
            "これは正解です。Salesforce CLIは、コマンドラインからSalesforceの各種操作を行うためのツールです。デプロイやテストの実行、結果の取得など、継続的インテグレーションの一環として必要な操作をスクリプト化して自動化するためには、Salesforce CLIを使用するのが適しています。",
            "これは不正解です。匿名実行は、Salesforceの開発者コンソール内で即座にApexコードを実行する機能です。これは主にコードの小さな断片をテストするためや、短いスクリプトを一時的に実行するために使用されます。しかし、継続的インテグレーションの一環としてのデプロイや単体テストの実行を自動化・スクリプト化する主要なツールとしては適していません。"
        ]
    },
    {
        "number": "190",
        "question": "Lightning Experienceで取引先の既存の編集ボタンを押下するときに、ユーザーにカスタムユーザーインターフェースを提供したいと考えています。どのように提供すべきですか。",
        "choices": ["取引先の[編集]ボタンをLightningアクションで上書きします", "取引先の[編集]ボタンをLightningコンポーネントで上書きします", "取引先の[編集]ボタンをLightningページで上書きします", "取引先の[編集]ボタンをSalesforce フローで上書きします"],
        "correct": ["取引先の[編集]ボタンをLightningコンポーネントで上書きします"],
        "explanations":["取引先の[編集]ボタンをLightningアクションで上書きします", "取引先の[編集]ボタンをLightningコンポーネントで上書きします", "取引先の[編集]ボタンをLightningページで上書きします", "取引先の[編集]ボタンをSalesforce フローで上書きします"],
        "descriptions":[
            "これは不正解です。Lightningアクションを使用して新たなアクションを作成し、それをレコードページに追加することは可能ですが、既存の[編集]ボタンの動作を直接上書きすることはできません。",
            "これは正解です。Lightningコンポーネントを使用して、取引先の[編集]ボタンの動作を完全にカスタマイズすることができます。具体的には、新しいLightningコンポーネントを作成し、そのコンポーネントを[編集]ボタンの動作として指定することで、ボタンをクリックしたときの動作を上書きすることができます。",
            "これは不正解です。Lightningページは、Salesforceのレコードページやホームページ、アプリページなどのUIをカスタマイズするためのものであり、特定のボタンの動作を上書きするためのものではありません。",
            "これは不正解です。Salesforce フローは、ユーザーのインタラクションに基づいて一連のステップやロジックを実行するためのツールです。ボタンの動作自体を上書きするためのものではありませんが、ボタンやアクションをクリックしたときにフローを起動することは可能です。"
        ]
    },
    {
        "number": "191",
        "question": "開発者は、Salary__cカスタム項目を含むContactレコードを作成するために、ユーザーがContactレコード情報を入力できるLightningコンポーネントを作成する必要があります。\nSalary__c 項目が通貨入力として機能し、Salary__c の正しい項目レベル権限を持っているユーザーのみが表示および編集できるようにするには、Lightning-record-edit-form とともに何を使用する必要がありますか。",
        "choices": ["<lightning-input-field field-name = “Salary__c”></ lightning-input-field>", "<lightning-input-currency value = “Salary__c”></ lightning-input-currency>", "<lightning-input type = “number” value = “Salary__c” formatter = “currency”></ lightning-input>", "<lightning-formatted-number value = “Salary__c” format-style = “currency”></ lightning-formatted-number>"],
        "correct": ["<lightning-input-field field-name = “Salary__c”></ lightning-input-field>"],
        "explanations":["<lightning-input-field field-name = “Salary__c”></ lightning-input-field>", "<lightning-input-currency value = “Salary__c”></ lightning-input-currency>", "<lightning-input type = “number” value = “Salary__c” formatter = “currency”></ lightning-input>", "<lightning-formatted-number value = “Salary__c” format-style = “currency”></ lightning-formatted-number>"],
        "descriptions":[
            "これは正解です。<lightning-input-field>は、Salesforceのオブジェクトの項目を表示および編集するためのLightning Web Componentです。<lightning-record-edit-form>と組み合わせることで、項目レベルの権限を考慮してフィールドを表示・編集することができます。このコンポーネントを使用すると、Salary__c項目の権限に基づいて、適切なユーザーにのみ入力フィールドが表示されます。",
            "これは不正解です。<lightning-input-currency>は存在しないコンポーネントです。",
            "これは不正解です。<lightning-input>は一般的な入力フィールドを提供するコンポーネントですが、Salesforceの項目レベルの権限を考慮する機能はありません。したがって、このコンポーネントを使用してもSalary__cの項目レベルの権限は適用されません。",
            "これは不正解です。<lightning-formatted-number>は数値を特定の形式で表示するためのコンポーネントです。このコンポーネントは入力フィールドを提供するものではなく、また項目レベルの権限を考慮する機能もありません。"
        ]
    },
    {
        "number": "192",
        "question": "開発者は、Apexクラスのメソッドを特定する必要があります。このメソッドは、Account上のSOQL文の結果セットを繰り返し処理することで、メモリ内でリソース負荷が高い処理を実行します。また、このメソッドは変更をデータベースに保存するためにDMLステートメントを実行します。トランザクション制御を確実にし、ガバナー制限の超過を回避するための最善の方法として、開発者が実装すべき１つの技法はどれですか。",
        "choices": ["Database.Savepointメソッドを使用して、データベースの整合性を強制します。", "部分的なDML文を使用して、有効なデータのみがコミットされるようにします。", "@ReadOnlyアノテーションを使用して、SOQLによって返される行数を回避します。", "System.Limitクラスを使用して、現在のCPUガバナー制限の消費量を監視します。"],
        "correct": ["System.Limitクラスを使用して、現在のCPUガバナー制限の消費量を監視します。"],
        "explanations":["Database.Savepointメソッドを使用して、データベースの整合性を強制します。", "部分的なDML文を使用して、有効なデータのみがコミットされるようにします。", "@ReadOnlyアノテーションを使用して、SOQLによって返される行数を回避します。", "System.Limitクラスを使用して、現在のCPUガバナー制限の消費量を監視します。"],
        "descriptions":[
            "これは不正解です。Apexには「Database.Savepointメソッド」という名前のメソッドは存在しません。しかし、SalesforceにはDatabase.setSavepoint()というメソッドが存在し、これを使用するとトランザクションの特定の時点をマークすることができます。その後、Database.rollback(databaseSavepoint)メソッドを利用して、指定したセーブポイントまでのDML操作を取り消すことができます。このrollbackメソッドを使うことで、エラーが発生した場合や予期せぬ問題が生じた時に、データベースの状態を元の状態に戻すことができるのです。したがって、「データベースの整合性を強制する」という文脈での使用は正しいと言えますが、問題文のメソッド名が不正確であるため、この選択肢は不正解となります。",
            "これは不正解です。Database.insert(records, false)やその他の部分的なDML操作はエラーを起こすレコードだけを失敗させ、他のレコードは正常に操作します。しかし、レコード数が多い場合やすべてのレコードが有効である場合、ガバナー制限を超える可能性があります。",
            "これは不正解です。@ReadOnlyアノテーションは、SOQLの行数制限を増やすことができますが、DML操作は許可されていません。このシナリオでは、メソッドがDMLステートメントを実行するため、このアノテーションは適切ではありません。",
            "これは正解です。System.Limitsクラスを使用することで、ガバナ制限の消費量をリアルタイムで監視することができます。これにより、リソースを大量に消費しているメソッドや処理を特定し、ガバナ制限の超過を回避するための最適化を行うことができます。"
        ]
    },
    {
        "number": "193",
        "question": "組織には商談を作成するフローがあります。開発者はこのフローを変更し、取引先責任者を新しく作成し、その取引先責任者のIDを商談に関連付ける必要があります。フローにどのような要素を追加する必要がありますか。",
        "choices": ["新しい[レコードを取得]要素を追加します。", "新しい[レコードを更新]要素を追加します。", "新しい[アクション要素] (※作成タイプ) を追加します。", "新しい[レコードを作成]要素を追加します。"],
        "correct": ["新しい[レコードを作成]要素を追加します。"],
        "explanations":["新しい[レコードを取得]要素を追加します。", "新しい[レコードを更新]要素を追加します。", "新しい[アクション]要素 (※作成タイプ) を追加します。", "新しい[レコードを作成]要素を追加します。"],
        "descriptions":[
            "これは不正解です。このシナリオでは新しい取引先責任者を作成する必要がありますが、[レコードを取得]要素は既存のレコードを取得するためのものであり、新しいレコードを作成するためのものではありません。",
            "これは不正解です。この要素は既存のレコードを更新するためのもので、新しいレコードを作成するためのものではありません。",
            "これは不正解です。この要素は特定のアクションを実行するためのもので、新しいレコードを直接作成するためのものではありません。",
            "これは正解です。取引先責任者を新しく作成するためには、[レコードを作成]要素を使用するのが最も適切です。この要素を使用して取引先責任者を作成した後、そのIDを取得し、次に[レコードを更新]要素を使用して商談に保存することができます。"
        ]
    },
    {
        "number": "194",
        "question": "値’High’、’Medium’、’Low’は、異なるオブジェクト間で複数の選択リストに共通する値として識別されています。値を上記のものに制限しつつ、選択リストとその値のメンテナンスを合理化するために、開発者が取ることのできる方法は何でしょうか。",
        "choices": ["各オブジェクトに選択リストを作成し、値を含むグローバル選択リスト値セットを使用します。", "各オブジェクトに必須項目として選択リストを作成し、”値を入力順ではなく文字コード順に表示”を選択します。", "各オブジェクトに選択リストを作成し、データの整合性を確保するための入力規則を追加します。", "各オブジェクトに選択リストを作成し、”値セットで定義された値に選択リストを制限します”を選択します。"],
        "correct": ["各オブジェクトに選択リストを作成し、値を含むグローバル選択リスト値セットを使用します。"],
        "explanations":["各オブジェクトに選択リストを作成し、値を含むグローバル選択リスト値セットを使用します。", "各オブジェクトに必須項目として選択リストを作成し、”値を入力順ではなく文字コード順に表示”を選択します。", "各オブジェクトに選択リストを作成し、データの整合性を確保するための入力規則を追加します。", "各オブジェクトに選択リストを作成し、”値セットで定義された値に選択リストを制限します”を選択します。"],
        "descriptions":[
            "これは正解です。グローバル選択リスト値セットを使用することで、複数のオブジェクト間で共通の選択リスト値を一元管理することができます。これにより、選択リストの値のメンテナンスを合理化することができます。",
            "これは不正解です。この選択肢は選択リストの表示順に関するものであり、選択リストの値のメンテナンスを合理化するための方法とは関係ありません。",
            "これは不正解です。入力規則を使用してデータの整合性を確保することは可能ですが、選択リストの値のメンテナンスを合理化するための最も効率的な方法ではありません。",
            "これは不正解です。この選択肢は選択リストの値を制限するためのものですが、複数のオブジェクト間で共通の選択リスト値を一元管理するための方法としては不適切です。"
        ]
    },
    {
        "number": "195",
        "question": "Batchableインターフェースを実装しているApexクラスのexecute()メソッドの内部でApexコードが実行される場合、ガバナ制限に関して正しい記述を2つ選びなさい。",
        "choices": ["Apexのガバナ制限は、execute()メソッドの繰り返しごとにリセットされます。", "トランザクションが非同期であるため、Apexガバナの制限を超えることはありません。", "トランザクションが非同期であるため、Apexガバナの制限値が高くなる可能性があります。", "Apexクラスのコンストラクタを呼び出している間、Apexガバナ制限は緩和されます。"],
        "correct": ["Apexのガバナ制限は、execute()メソッドの繰り返しごとにリセットされます。", "トランザクションが非同期であるため、Apexガバナの制限値が高くなる可能性があります。"],
        "explanations":["Apexのガバナ制限は、execute()メソッドの繰り返しごとにリセットされます。", "トランザクションが非同期であるため、Apexガバナの制限を超えることはありません。", "トランザクションが非同期であるため、Apexガバナの制限値が高くなる可能性があります。", "Apexクラスのコンストラクタを呼び出している間、Apexガバナ制限は緩和されます。"],
        "descriptions":[
            "これは正解です。Batchableインターフェースのexecute()メソッドは、各バッチの処理ごとに新しいトランザクションとして実行されるため、ガバナ制限は各バッチの処理ごとにリセットされます。",
            "これは不正解です。トランザクションが非同期であるからといって、Apexガバナの制限を超えないわけではありません。非同期処理でもガバナ制限は適用され、その制限を超えるとエラーが発生します。",
            "これは正解です。非同期処理、特にBatch ApexやFutureメソッドなどでは、同期処理と比べてガバナ制限が緩和される場合があります。",
            "これは不正解です。コンストラクタの呼び出し時にApexガバナ制限が緩和されるわけではありません。コンストラクタは通常のApexコードと同じガバナ制限の下で実行されます。"
        ]
    },
    {
        "number": "196",
        "question": "すべてのテストを実行した後、開発者はクラスのコードカバレッジをチェックするために何をすべきですか。",
        "choices": ["[Apex クラス]ページのビューの[コードカバレッジ]列を表示します。", "開発者コンソールの[Tests]タブの[Overall Code Coverage]を使用して、クラスのコードカバー率を表示します。", "[Apex クラス]ページのビューの[Class test Coverage]タブを表示します。", "[Apex テスト実行]ページでクラスを選択して実行します。"],
        "correct": ["開発者コンソールの[Tests]タブの[Overall Code Coverage]を使用して、クラスのコードカバー率を表示します。"],
        "explanations":["[Apex クラス]ページのビューの[コードカバレッジ]列を表示します。", "開発者コンソールの[Tests]タブの[Overall Code Coverage]を使用して、クラスのコードカバー率を表示します。", "[Apex クラス]ページのビューの[Class test Coverage]タブを表示します。", "[Apex テスト実行]ページでクラスを選択して実行します。"],
        "descriptions":[
            "これは不正解です。Salesforceのセットアップメニューの[Apex クラス]ページには直接「コードカバレッジ」列は存在しません。しかし、[組織のコードカバー率を見積る]リンクを使用して、組織全体のコードカバー率を確認することは可能です。",
            "これは正解です。開発者コンソールの[Tests]タブには、全体のコードカバレッジを表示する[Overall Code Coverage]セクションがあります。また、各クラスやトリガーのカバレッジも確認することができます。",
            "これは不正解です。Salesforceの[Apex クラス]ページには[Class test Coverage]というタブは存在しません。",
            "これは不正解です。[Apex テスト実行]ページはテストの実行を行うためのものであり、コードカバレッジを直接確認するためのものではありません。"
        ]
    },
    {
        "number": "197",
        "question": "スクラッチ組織を作成するために何を使用すべきですか。",
        "choices": ["Salesforce CLI", "Workbench", "Developer Console", "Sandbox の更新"],
        "correct": ["Salesforce CLI"],
        "explanations":["Salesforce CLI", "Workbench", "Developer Console", "Sandbox の更新"],
        "descriptions":[
            "これは正解です。Salesforce CLI (Command Line Interface) は、スクラッチ組織の作成、管理、削除など、多くの開発者タスクを行うためのツールです。しかし、スクラッチ組織を作成する前に、設定画面からDev Hubを有効化する必要があります。Dev Hubを有効化した後、sfdx force:org:create コマンドを使用してスクラッチ組織を作成することができます。",
            "これは不正解です。WorkbenchはSalesforceのデータやメタデータを操作するためのツールですが、スクラッチ組織の作成には使用されません。",
            "これは不正解です。Developer ConsoleはApexコードの編集やデバッグ、SOQLクエリの実行などを行うためのツールですが、スクラッチ組織の作成には使用されません。",
            "これは不正解です。Sandboxの更新は、本番環境のデータや設定をSandboxに反映するためのものです。スクラッチ組織の作成とは関係ありません。"
        ]
    },
    {
        "number": "198",
        "question": "単体テストで実行可能なシナリオはどれですか。",
        "choices": ["別のユーザーとして匿名Apexを実行する。", "コールアウトを使用してリモートサイトからデータを読み込む。", "システムメソッドを使用してレコードの作成日を設定する。", "geccontentAsPDF()を使用してVisualforcePDFを生成する。"],
        "correct": ["システムメソッドを使用してレコードの作成日を設定する。"],
        "explanations":["別のユーザーとして匿名Apexを実行する。", "コールアウトを使用してリモートサイトからデータを読み込む。", "システムメソッドを使用してレコードの作成日を設定する。", "geccontentAsPDF()を使用してVisualforcePDFを生成する。"],
        "descriptions":[
            "これは不正解です。テストメソッド内で特定のユーザーとしてコードを実行することはSystem.runAs()を使用することで可能ですが、匿名Apexとして実行することはできません。",
            "これは不正解です。単体テスト中にリアルタイムの外部コールアウトを行うことはできません。しかし、テストメソッドでコールアウトの動作をシミュレートするためのTest.setMock()メソッドが提供されています。",
            "これは正解です。 System.Test.setCreatedDate() メソッドを使用して、単体テスト内でレコードの作成日を設定することができます。",
            "これは不正解です。getContentAsPDF()メソッドはテストメソッド内での使用がサポートされていません。テストメソッド内でこのメソッドを使用すると、テストは失敗します。"
        ]
    },
    {
        "number": "199",
        "question": "開発者が、@remoteActionデコレータを使用してグローバルなサーバー側メソッドを呼び出そうとするとエラーが発生します。このエラーを解決するにはどうすればよいですか。",
        "choices": ["サーバー側のメソッドを (static=false) でデコレートする。", "サーバー側のメソッドのシグネチャにstaticを追加する。", "サーバー側のメソッドを(static=true)でデコレートする。", "関数のシグネチャをprivate staticに変更する。"],
        "correct": ["サーバー側のメソッドのシグネチャにstaticを追加する。"],
        "explanations":["サーバー側のメソッドを (static=false) でデコレートする。", "サーバー側のメソッドのシグネチャにstaticを追加する。", "サーバー側のメソッドを(static=true)でデコレートする。", "関数のシグネチャをprivate staticに変更する。"],
        "descriptions":[
            "これは不正解です。static=false というデコレーションはApexに存在しません。また、@remoteActionで呼び出されるメソッドはstaticである必要があります。",
            "これは正解です。@remoteActionで呼び出されるメソッドはstaticである必要があります。したがって、メソッドのシグネチャにstaticキーワードを追加することでエラーを解決できます。",
            "これは不正解です。Apexにはstatic=trueというデコレーションは存在しません。正しくは、メソッドのシグネチャにstaticキーワードを追加するだけです。",
            "これは不正解です。@remoteActionで呼び出されるメソッドはpublicまたはglobalなアクセス修飾子を持つ必要があります。したがって、private staticにすると、Visualforceページからアクセスできなくなります。"
        ]
    },
    {
        "number": "200",
        "question": "ある開発チームは、デプロイスクリプトを使用して、開発サイクル中にサンドボックスに自動的にデプロイしたいと考えています。サンドボックスにデプロイするスクリプトを実行するために使用できるツールはどれですか。2つ選びなさい。",
        "choices": ["開発者コンソール", "Salesforce CLI", "Ant 移行ツール", "変更セット"],
        "correct": ["Salesforce CLI", "Ant 移行ツール"],
        "explanations":["開発者コンソール", "Salesforce CLI", "Ant 移行ツール", "変更セット"],
        "descriptions":[
            "これは不正解です。開発者コンソールはコードの編集やデバッグ、SOQLクエリの実行などのタスクを行うためのツールですが、自動的なデプロイのスクリプト実行には使用されません。",
            "これは正解です。Salesforce CLI (Command Line Interface) は、メタデータのデプロイや取得、スクラッチ組織の管理など、多くの開発者タスクを行うためのツールです。CLIを使用して、スクリプトを通じて自動的にサンドボックスにデプロイすることができます。",
            "これは正解です。Ant 移行ツールは、SalesforceのメタデータAPIを使用して、メタデータのデプロイや取得を行うためのJava/Antベースのコマンドラインツールです。ビルドファイルを使用して、自動的にサンドボックスにデプロイするスクリプトを実行することができます。",
            "これは不正解です。変更セットは、組織間でメタデータの変更を移行するためのツールです。変更セットは、ユーザーが手動で作成し、送信する必要があります。自動的なデプロイのスクリプト実行には使用されません。"
        ]
    },
    {
        "number": "201",
        "question": "Accountオブジェクトのafterトリガーは、Accountのすべての子OpportunityでDML更新操作を実行します。 Opportunityオブジェクトにアクティブなトリガーはありませんが、特定の状況で「最大トリガー深度を超えました」エラーが発生します。Accountトリガーの再帰的な起動を説明する理由はどれですか。 2つ選びなさい",
        "choices": ["Opportunityを変更すると、Accountの積み上げ集計項目が更新されます。", "Opportunityの変更により、Accountの項目が自動的に更新されるクロスオブジェクトのワークフローが実行されています。", "無関係な並列保存操作中にAccountに変更が加えられています。", "条件に基づく共有ルールの評価中にAccountに変更が加えられています。"],
        "correct": ["Opportunityを変更すると、Accountの積み上げ集計項目が更新されます。", "Opportunityの変更により、Accountの項目が自動的に更新されるクロスオブジェクトのワークフローが実行されています。"],
        "explanations":["Opportunityを変更すると、Accountの積み上げ集計項目が更新されます。", "Opportunityの変更により、Accountの項目が自動的に更新されるクロスオブジェクトのワークフローが実行されています。", "無関係な並列保存操作中にAccountに変更が加えられています。", "条件に基づく共有ルールの評価中にAccountに変更が加えられています。"],
        "descriptions":[
            "これは正解です。Opportunityの変更がAccountの積み上げ集計項目の再計算を引き起こす可能性があります。この再計算はAccountの更新を引き起こし、その結果としてAccountのトリガーが再度実行される可能性があります。",
            "これは正解です。Opportunityの変更がクロスオブジェクトのワークフローを引き起こすことで、Accountの項目が自動的に更新される可能性があります。このような更新はAccountのトリガーの再実行を引き起こす可能性があります。",
            "これは不正解です。無関係な並列保存操作は、特定の状況でのトリガーの再帰的な起動を引き起こすものではありません。",
            "これは不正解です。条件に基づく共有ルールの評価は、レコードの可視性を変更するためのものであり、トリガーの再帰的な起動を直接引き起こすものではありません。"
        ]
    },
    {
        "number": "202",
        "question": "Salesforce管理者は、レコードによってトリガーされるフローを作成しています。特定の基準が満たされた場合、フローはApexメソッドを呼び出して、いくつかのタイプのオブジェクトを含む複雑な検証を実行する必要があります。Apexメソッドを作成する場合、メソッドをフロー内で使用できるようにするために、開発者はどのアノテーションを使用する必要がありますか。",
        "choices": ["@future", "@InvocableMethod", "@AuraEnaled", "@RemoteAction"],
        "correct": ["@InvocableMethod"],
        "explanations":["@future", "@InvocableMethod", "@AuraEnabled", "@RemoteAction"],
        "descriptions":[
            "これは不正解です。@future アノテーションは、メソッドを非同期で実行するために使用されます。これは、フローからApexメソッドを直接呼び出すためのアノテーションではありません。",
            "これは正解です。@InvocableMethod アノテーションは、フローやプロセスビルダーからApexメソッドを呼び出すために使用されます。このアノテーションが付けられたメソッドは、フロー内で直接呼び出すことができます。",
            "これは不正解です。@AuraEnabled アノテーションは、LightningコンポーネントやAuraコンポーネントからApexメソッドを呼び出すために使用されます。フローからの呼び出しには関連していません。",
            "これは不正解です。@RemoteAction アノテーションは、VisualforceページからJavaScriptを使用してApexメソッドを呼び出すために使用されます。フローからの呼び出しには関連していません。"
        ]
    },
    {
        "number": "203",
        "question": "ワークフローで、既存のAccountのカスタム項目の値を更新します。開発者は、トリガーによって更新する予定のカスタム項目の値にどのようにアクセスしますか。",
        "choices": ["before updateトリガーを記述し、Trigger.newから項目値にアクセスする。", "before insertトリガーを記述し、Trigger.newから項目値にアクセスする。", "after insertトリガーを記述し、Trigger.oldから項目値にアクセスする。", "after updateトリガーを記述し、Trigger.oldから項目値にアクセスする。"],
        "correct": ["before updateトリガーを記述し、Trigger.newから項目値にアクセスする。"],
        "explanations":["before updateトリガーを記述し、Trigger.newから項目値にアクセスする。", "before insertトリガーを記述し、Trigger.newから項目値にアクセスする。", "after insertトリガーを記述し、Trigger.oldから項目値にアクセスする。", "after updateトリガーを記述し、Trigger.oldから項目値にアクセスする。"],
        "descriptions":[
            "これは正解です。before updateトリガーは、レコードが保存される前に実行されます。Trigger.newを使用すると、更新される予定の値にアクセスできます。",
            "これは不正解です。before insertトリガーは新規レコードの作成時に使用されるため、既存のレコードの更新には関係ありません。",
            "これは不正解です。after insertトリガーは新規レコードの作成後に実行されるため、既存のレコードの更新には関係ありません。また、Trigger.oldはbefore updateとafter updateトリガーでのみアクセス可能です。",
            "これは不正解です。after updateトリガーは、レコードが保存された後に実行されます。Trigger.oldを使用すると、更新前の古い値にアクセスできますが、更新された新しい値にはアクセスできません。新しい値にアクセスするには、Trigger.newを使用する必要があります。"
        ]
    },
    {
        "number": "204",
        "question": "Apexのカスタム例外に関して正しいものはどれですか。3つ選びなさい。",
        "choices": ["カスタム例外クラスは、例外クラス以外のクラスを拡張できます。", "カスタム例外クラスは、1つまたは複数のインターフェースを実装できます。", "カスタム例外クラスにメンバ変数またはメソッドを含めることはできません。", "カスタム例外クラスは、組み込み例外クラスを拡張する必要があります。", "カスタム例外クラス名は「Exception」で終わる必要があります。"],
        "correct": ["カスタム例外クラスは、1つまたは複数のインターフェースを実装できます。", "カスタム例外クラスは、組み込み例外クラスを拡張する必要があります。", "カスタム例外クラス名は「Exception」で終わる必要があります。"],
        "explanations":["カスタム例外クラスは、例外クラス以外のクラスを拡張できます。", "カスタム例外クラスは、1つまたは複数のインターフェースを実装できます。", "カスタム例外クラスにメンバ変数またはメソッドを含めることはできません。", "カスタム例外クラスは、組み込み例外クラスを拡張する必要があります。", "カスタム例外クラス名は「Exception」で終わる必要があります。"],
        "descriptions":[
            "これは不正解です。 カスタム例外クラスは、必ずExceptionクラスを拡張する必要があります。他のクラスを拡張することはできません。",
            "これは正解です。 Apexのカスタム例外クラスは、他のクラスと同様にインターフェースを実装することができます。",
            "これは不正解です。 カスタム例外クラスはメンバ変数やメソッドを含めることができます。これにより、例外に関連する追加情報を保持したり、特定の機能を提供することが可能です。",
            "これは正解です。Apexのカスタム例外は、必ず組み込み例外クラス(Exceptionクラス)を拡張しなければなりません。",
            "これは正解です。 カスタム例外の命名規則として、クラス名は「Exception」で終わる必要があります。"
        ]
    },
    {
        "number": "205",
        "question": "開発者は、親LightningWebコンポーネント内にネストされた子LightningWebコンポーネントを作成しました。親コンポーネントは、文字列値を子コンポーネントに渡す必要があります。これを達成できる方法はどれですか。2つ選びなさい。",
        "choices": ["親コンポーネントは、カスタムイベントを使用して、データを子コンポーネントに渡すことができます。", "親コンポーネントはApexコントローラークラスを使用して、子コンポーネントにデータを送信できます。", "親コンポーネントは子コンポーネントのメソッドを呼び出すことができます。", "親コンポーネントは、パブリックプロパティを使用して、データを子コンポーネントに渡すことができます。"],
        "correct": ["親コンポーネントは子コンポーネントのメソッドを呼び出すことができます。", "親コンポーネントは、パブリックプロパティを使用して、データを子コンポーネントに渡すことができます。"],
        "explanations":["親コンポーネントは、カスタムイベントを使用して、データを子コンポーネントに渡すことができます。", "親コンポーネントはApexコントローラークラスを使用して、子コンポーネントにデータを送信できます。", "親コンポーネントは子コンポーネントのメソッドを呼び出すことができます。", "親コンポーネントは、パブリックプロパティを使用して、データを子コンポーネントに渡すことができます。"],
        "descriptions":[
            "これは不正解です。カスタムイベントは、子コンポーネントから親コンポーネントにデータを送信するために使用されます。逆の方向(親から子へ)には使用されません。",
            "これは不正解です。Apexコントローラーは、サーバーサイドのデータをフロントエンドのコンポーネントに提供するために使用されますが、親コンポーネントから子コンポーネントへのデータの直接的な送信には使用されません。",
            "これは正解です。親コンポーネントは、子コンポーネントの公開メソッドを呼び出して、データを渡すことができます。",
            "これは正解です。親コンポーネントは、子コンポーネントの公開プロパティを使用して、データを直接渡すことができます。"
        ]
    },
    {
        "number": "206",
        "question": "コンポーネントとアプリケーションのイベント処理に関するベストプラクティスはどれですか。2つ選びなさい。",
        "choices": ["イベントハンドラで低レベルのイベントを処理し、高レベルのイベントとして再起動する。", "コンポーネントイベントではなく、アプリケーションイベントを使用する。", "ロジックをヘルパーに配置して、コンポーネントバンドルでイベントロジックを再利用する。", "アプリケーションレベルで処理されるべきアクションを伝達するためにコンポーネントイベントを使用する。"],
        "correct": ["イベントハンドラで低レベルのイベントを処理し、高レベルのイベントとして再起動する。", "ロジックをヘルパーに配置して、コンポーネントバンドルでイベントロジックを再利用する。"],
        "explanations":["イベントハンドラで低レベルのイベントを処理し、高レベルのイベントとして再起動する。", "コンポーネントイベントではなく、アプリケーションイベントを使用する。", "ロジックをヘルパーに配置して、コンポーネントバンドルでイベントロジックを再利用する。", "アプリケーションレベルで処理されるべきアクションを伝達するためにコンポーネントイベントを使用する。"],
        "descriptions":[
            "これは正解です。低レベルのイベントをイベントハンドラで処理し、ビジネスロジックイベントなどの高レベルのイベントとして再起動することが推奨されています。",
            "これは不正解です。ベストプラクティスとして、可能な場合は常にコンポーネントイベントを使用することが推奨されています。アプリケーションイベントは、アプリケーションレベルでの処理が必要な場合に適しています。",
            "これは正解です。コンポーネントのバンドルでロジックを再利用する必要がある場合、そのロジックをヘルパーに配置することが推奨されています。",
            "これは不正解です。アプリケーションレベルでの処理には、アプリケーションイベントを使用することが推奨されています。"
        ]
    },
    {
        "number": "207",
        "question": "Apexクラスとインターフェースに関して、次のうち正しいステートメントはどれでしょうか。２つ選択してください。",
        "choices": ["クラスは複数のレベルの内部クラスを持つことができます。", "インターフェースのデフォルトの修飾子はprivateです。", "クラスのデフォルトの修飾子はprivateです。", "例外クラスはExceptionというワードで終わる必要があります。"],
        "correct": ["クラスのデフォルトの修飾子はprivateです。", "例外クラスはExceptionというワードで終わる必要があります。"],
        "explanations":["クラスは複数のレベルの内部クラスを持つことができます。", "インターフェースのデフォルトの修飾子はprivateです。", "クラスのデフォルトの修飾子はprivateです。", "例外クラスはExceptionというワードで終わる必要があります。"],
        "descriptions":[
            "これは不正解です。Apexでは、最上位クラスの中に内部クラスを持つことはできますが、内部クラスは1つ下のレベルのみです。",
            "これは不正解です。Apexのインターフェース内のメソッドはアクセス修飾子を指定せずに定義されると、自動的にグローバルとなります。",
            "これは正解です。Apexのトップレベルのクラスはデフォルトでprivateです。",
            "これは正解です。Apexでカスタム例外クラスを定義する場合、クラス名は”Exception”で終わらせる必要があります。"
        ]
    },
    {
        "number": "208",
        "question": "開発者は、あるクラスに対するテストを作成しており、機能を検証するためにレコードを挿入する必要があります。テストクラスのすべてのメソッドに対してレコードを作成するには、どのアノテーションを使うべきですか。",
        "choices": ["@StartTest", "@PreTest", "@TestSetup", "@isTest(SeeAllData=true)"],
        "correct": ["@TestSetup"],
        "explanations":["@StartTest", "@PreTest", "@TestSetup", "@isTest(SeeAllData=true)"],
        "descriptions":[
            "これは不正解です。Salesforceには@StartTestというアノテーションは存在しません。",
            "これは不正解です。Salesforceには@PreTestというアノテーションは存在しません。",
            "これは正解です。@TestSetupアノテーションは、テストクラス内のすべてのテストメソッドが実行される前に一度だけ実行されるメソッドを定義するために使用されます。このメソッド内でレコードを作成すると、それらのレコードはテストクラス内のすべてのテストメソッドで利用できます。",
            "これは不正解です。@isTest(SeeAllData=true)は、テストメソッドが本番環境のデータにアクセスできるようにするアノテーションです。しかし、テストのために新たにレコードを作成する目的には適していません。通常、テストの分離と独立性を保つために、実稼働環境のデータへのアクセスは避けるべきです。"
        ]
    },
    {
        "number": "209",
        "question": "開発者チームは、さまざまな組織構成で独立して作業できるソース主導型のプロジェクトに取り組んでいます。開発チームは、どのタイプのSalesforce組織を使用して開発を行うべきでしょうか。",
        "choices": ["スクラッチ組織", "Developer Sandbox", "Full Sandbox", "開発者組織"],
        "correct": ["スクラッチ組織"],
        "explanations":["スクラッチ組織", "Developer Sandbox", "Full Sandbox", "開発者組織"],
        "descriptions":[
            "これは正解です。スクラッチ組織は、Salesforce DXの一部で、ソース主導型開発に最適です。これらは一時的で軽量な組織であり、開発者が特定のプロジェクトや機能に取り組むために必要な構成を備えています。スクラッチ組織は、さまざまな組織構成で独立して作業するのに適しており、チームが個々の機能やモジュールに集中できる環境を提供します。",
            "これは不正解です。Developer Sandboxは限られたデータと機能を持つ小規模なテスト環境です。複数の独立した開発チームが同時に作業するには、スケールや分離の面で制限があります。スクラッチ組織のように迅速なセットアップやカスタマイズが難しいため、このシナリオには最適ではありません。",
            "これは不正解です。Full Sandboxは本番環境の完全なコピーであり、主に大規模なテストやトレーニングに使用されます。しかし、これらのサンドボックスは通常、作成数が限られ(1組織につき1環境のみ)、独立して作業する複数のチームによる同時使用には適していません。また、セットアップとリフレッシュに時間がかかるため、短期間の開発サイクルには不向きです。",
            "これは不正解です。開発者組織は個人開発者や非常に小規模なプロジェクト向けです。複数のチームや独立した作業をサポートするためのスケーリングや柔軟性が不足しています。また、スクラッチ組織のように迅速にセットアップして廃棄することも難しく、ソース主導型のプロジェクトには適していません。"
        ]
    },
    {
        "number": "210",
        "question": "Universal Containers社は、商談がClosed Wonのフェーズに達したときに、商談を編集できないようにロックしたいと考えています。これを達成するために開発者が使用すべき戦略はどれですか。2つ選びなさい。",
        "choices": ["フロービルダーを使用する。", "入力規則を使用する。", "プロセスの自動化設定を使用する。", "トリガーを使用する。"],
        "correct": ["入力規則を使用する。", "トリガーを使用する。"],
        "explanations":["フロービルダーを使用する。", "入力規則を使用する。", "プロセスの自動化設定を使用する。", "トリガーを使用する。"],
        "descriptions":[
            "これは不正解です。フロービルダーは、特定のビジネスプロセスを自動化するために使用されますが、レコードの編集を直接ロックする機能は提供していません。フローを使って商談のステータスがClosed Wonに変更されたときに特定のアクションをトリガーすることはできますが、これだけでは編集を防ぐことはできません。",
            "これは正解です。入力規則を使用すると、商談のステータスがClosed Wonになったときに特定の条件を満たさない限り、レコードの編集を防ぐことができます。たとえば、「ステータスがClosed Wonである場合、他の項目を編集できない」という入力規則を設定することで、レコードがロックされる効果が得られます。",
            "これは不正解です。プロセスの自動化(プロセスビルダーなど)は、特定の条件に基づいて自動的にタスクを実行するために使用されますが、これ自体ではレコードの編集を直接制限することはできません。商談のステータスが特定の値になったときにアクションをトリガーすることはできますが、編集をロックする機能は提供していません。",
            "これは正解です。Apexトリガーは、特定のデータベース操作(例えばレコードの更新)が発生したときにカスタムコードを実行するために使用されます。商談のステータスがClosed Wonになった場合に編集をロックするには、Apexトリガーを使用して、そのステータスの商談に対する更新操作を拒否するロジックを実装できます。例えば、商談がClosed Wonのステータスになると、トリガーが発火し、それ以降の編集を阻止することができます。これはサーバー側で実行されるため、セキュリティが強く、例外的な状況に対しても効果的に機能します。"
        ]
    },
    {
        "number": "211",
        "question": "",
        "choices": ["", "", "", ""],
        "correct": [""],
        "explanations":["", "", "", ""],
        "descriptions":[
            "",
            "",
            "",
            ""
        ]
    },
    {
        "number": "212",
        "question": "データクリーンアップ戦略の一環として、AW Computing社は、関連するアカウントが削除されたときに、関連する商談レコードを自動的に削除したいと考えています。このビジネス要件を満たすには、どの自動化ツールを使用する必要がありますか。",
        "choices": ["プロセスビルダー", "レコードトリガーフロー", "ワークフロールール", "スケジュールされたジョブ"],
        "correct": ["レコードトリガーフロー"],
        "explanations":["プロセスビルダー", "レコードトリガーフロー", "ワークフロールール", "スケジュールされたジョブ"],
        "descriptions":[
            "これは不正解です。プロセスビルダーは、特定のレコードの変更に基づいてアクションを実行するのに使用されますが、レコードの削除をトリガーとするアクションを実行する機能はありません。プロセスビルダーは、項目の更新、メールの送信、タスクの作成などのアクションに適していますが、他のレコードの削除を直接トリガーすることはできません。また、Salesforceはワークフローおよびプロセスビルダーからより強力なフローへの移行を進めており、将来的にはこれらの機能は廃止されます。",
            "これは正解です。レコードトリガーフローは、レコードの作成、更新、削除などのイベントに基づいて自動化されたプロセスを実行するために使用されます。関連するアカウントが削除されたときに商談レコードを削除するには、レコードトリガーフローを使用して、アカウントの削除イベントに応じて関連する商談レコードを削除するロジックを実装できます。",
            "これは不正解です。ワークフロールールは、特定の条件に基づいて項目の更新、メールアラートの送信、タスクの作成などのアクションを実行しますが、レコードの削除をトリガーとして他のレコードを削除する機能は提供していません。また、Salesforceではワークフロールールやプロセスビルダーの使用を段階的に廃止し、より高機能な「フロー」への移行を進めています。",
            "これは不正解です。スケジュールされたジョブは、特定の時間に定期的に実行されるタスクやプロセスを設定するために使用されます。これは一般的にバッチ処理や定期的なデータのメンテナンスに適していますが、特定のレコードの削除イベントに基づいて即時にアクションを実行するのには適していません。"
        ]
    },
    {
        "number": "213",
        "question": "会社名「Universal Containers」を持つすべてのリード、取引先、および取引先責任者のIDおよび名前を取得するには、開発者は何を使用すればよいですか。",
        "choices": ["FIND Universal Containers社’ IN CompanyName Fietds RETURNING lead{ld. name), accounted, name), contacted, name)", "FIND ‘Universal Containers社’ IN Name Fields RETURNING lead(id, name), accounted, name), contacted, name)", "SELECT lead(id, name). accountId, name), contacted, name) FROM Lead, Account, Contact WHERE Name = “Universal Containers社’", "SELECT Lead.id. Lead.Name, Account.Id, AccountName, Contacted, Contact.Name FROM Lead, Account, Contact WHERE CompanvName * Universal Containers社’"],
        "correct": ["FIND ‘Universal Containers社’ IN Name Fields RETURNING lead(id, name), accounted, name), contacted, name)"],
        "explanations":[" FIND Universal Containers社’ IN CompanyName Fietds RETURNING lead{ld. name), accounted, name), contacted, name)", "FIND ‘Universal Containers社’ IN Name Fields RETURNING lead(id, name), accounted, name), contacted, name)", " SELECT lead(id, name). accountId, name), contacted, name) FROM Lead, Account, Contact WHERE Name = “Universal Containers社’", "SELECT Lead.id. Lead.Name, Account.Id, AccountName, Contacted, Contact.Name FROM Lead, Account, Contact WHERE CompanvName * Universal Containers社’"],
        "descriptions":[
            "これは不正解です。この文はSOSL(Salesforce Object Search Language)の構文ですが、いくつかの問題があります。まず、クエリ内の検索文字列「Universal Containers社」は引用符で囲む必要があります。また、「CompanyName Fields」は存在しないため、適切なフィールドグループ(例えば「NAME FIELDS」)を指定する必要があります。さらに、リード、取引先、および取引先責任者のオブジェクトには「CompanyName」という名前の標準フィールドは存在しません。代わりに「Name」フィールドを使用する必要があるでしょう。",
            "これは正解です。この文は正しいSOSLクエリで、リード、取引先、および取引先責任者の「Name」フィールドで「Universal Containers社」というテキストを検索し、それぞれのIDと名前を返します。",
            "これは不正解です。この文はSOQLの構文に似ていますが、正しくない構文です。SOQLでは複数のオブジェクトを同時にクエリすることはできません。",
            "これは不正解です。この文はSOQLの構文に似ていますが、正しくない構文です。SOQLでは複数のオブジェクトを同時にクエリすることはできず、また「CompanyName」はリード、取引先、取引先責任者のすべてのオブジェクトに存在する項目ではありません。"
        ]
    },
    {
        "number": "214",
        "question": "Universal Containers社には、カスタムオブジェクトであるEngineering_Support__cを使用して、ユーザーがエンジニアリングチームにサポートを要求できるサポートプロセスがあります。ユーザーは、複数のEngineering_Support__cレコードを1つの商談レコードに関連付けることができる必要があります。さらに、Engineering_Support__c レコードに関する集計情報を商談レコードに表示する必要があります。これらの要件をサポートするために、開発者は何を実装する必要がありますか。",
        "choices": ["商談からEngineering_Support__cへの主従関係", "Engineering_Support__cから商談への主従関係", "商談からEngineering_Support__cへの参照関係", "Engineering_support__cから商談への参照関係"],
        "correct": ["Engineering_Support__cから商談への主従関係"],
        "explanations":["□ 商談からEngineering_Support__cへの主従関係", "□ Engineering_Support__cから商談への主従関係", "□ 商談からEngineering_Support__cへの参照関係", "□ Engineering_support__cから商談への参照関係"],
        "descriptions":[
            "これは不正解です。商談からEngineering_Support__cへの主従関係を設定すると、各商談レコードはEngineering_Support__cの複数の子レコードを持つことができます。しかし、この問題の要件には、商談レコードにEngineering_Support__cレコードの集計情報を表示する必要があり、この目的には主従関係は適していません。主従関係は、子レコード(Engineering_Support__c)の集計情報を親レコード(商談)に表示するために使用されます。",
            "これは正解です。Engineering_Support__cから商談への主従関係を設定すると、Engineering_Support__cレコードが商談レコードに関連付けられます。これにより、商談レコードにEngineering_Support__cレコードの集計情報を表示することが可能になり、問題文で求められている要件を満たすことができます。",
            "これは不正解です。参照関係では、Engineering_Support__cレコードに関する集計情報を商談レコードに表示することはできません。参照関係は、レコード間のリンクを作成するために使用されるもので、親レコード上で子レコードの集計情報を表示する機能は提供しません。",
            "これは不正解です。Engineering_support__cから商談への参照関係では、Engineering_Support__cレコードを商談レコードに関連付けることはできますが、問題文の要件にあるように商談レコードにEngineering_Support__cレコードの集計情報を表示する機能は提供しません。この関係では、Engineering_Support__cレコードは商談レコードと独立して存在し、親レコードでの集計表示には利用できません。"
        ]
    },
    {
        "number": "215",
        "question": "",
        "choices": ["", "", "", ""],
        "correct": [""],
        "explanations":["", "", "", ""],
        "descriptions":[
            "",
            "",
            "",
            ""
        ]
    }
]
