[
    {
        "number": "1",
        "previous-code": [],
        "question": "デバッグログに書き込まれるときのxの値は何ですか。",
        "following-code": [
            "Integer x = 0;",
            "do {",
            "    x = 1;",
            "    x++;",
            "} while (x < 1);",
            "System.debug(x);"
        ],
        "choices": ["0", "1", "2", "3"],
        "choices-code": ["", "", "", ""],
        "correct": ["2"],
        "explanations": ["デバッグログには 2 が表示されます。以下がコードの実行フローです。"],
        "descriptions": [
            "1| x の初期値は0です。\n2| do ループが実行されます。\n3| x に1が代入されます。\n4| x の値がインクリメントされ、現在の値は2になります。\n5| while 条件式 x < 1 が評価されます。しかし、この時点で x の値は2なので条件式は false となります。\n6| ループを抜けて System.debug(x); が実行され、デバッグログには 2 が表示されます。"
        ]
    },
    {
        "number": "2",
        "previous-code": [],
        "question": "LightningコンポーネントからApexメソッドおよびプロパティへのアクセスを可能にするアノテーションはどれですか。",
        "following-code": [],
        "choices": ["@RestResource", "@AuraEnabled", "@RemoteAction", "@Httplnvocable"],
        "choices-code": ["", "", "", ""],
        "correct": ["@AuraEnabled"],
        "explanations": ["@RestResource","@AuraEnabled","@RemoteAction","@Httplnvocable"],
        "descriptions": [
            "これは不正解です。@RestResource アノテーションは、ApexクラスをRESTful Webサービスとして公開するために使用されます。Lightningコンポーネントから直接このアノテーションを用いてApexメソッドにアクセスすることは推奨されません。",
            "これは正解です。LightningコンポーネントからApexメソッドおよびプロパティへのアクセスを可能にするアノテーションは「@AuraEnabled」です。このアノテーションをApexメソッドまたはプロパティに追加すると、そのメソッドやプロパティがLightningコンポーネントから呼び出し可能になります。",
            "これは不正解です。@RemoteAction アノテーションは、VisualforceページからApexメソッドにアクセスするために使用されます。しかし、Lightningコンポーネントからは使用できません。",
            "これは不正解です。@Httplnvocable アノテーションは、存在しないアノテーションです。"
        ]
    },
    {
        "number": "119",
        "question": "開発者は、新しいApexクラスをテストするために、特定の項目値を持つレコードを用意する必要があります。開発者は、データがテストで利用可能であることを確認するために何をすべきですか。",
        "choices": ["匿名Apexを使用して、必要なデータを作成する。", "SOQLを使用して、必要なデータを組織にクエリする。", "Test.loadData()を使用し、静的リソースでCSVファイルを参照する。", "Test.loadData()を使用し、ドキュメント内のJSONファイルを参照する。"],
        "correct": ["Test.loadData()を使用し、静的リソースでCSVファイルを参照する。"],
        "explanations":["匿名Apexを使用して、必要なデータを作成する。", "SOQLを使用して、必要なデータを組織にクエリする。", "Test.loadData()を使用し、静的リソースでCSVファイルを参照する。", "Test.loadData()を使用し、ドキュメント内のJSONファイルを参照する。"],
        "descriptions":[
            "これは不正解です。匿名Apexは、本番環境やサンドボックス環境で直接スクリプトを実行するために使われます。テストクラス内でテストデータを準備する際には、テストメソッド内でデータを作成することが一般的です。匿名Apexは、テストの実行中にデータを作成するための適切な手段ではありません。",
            "これは不正解です。Apexテストメソッドは、デフォルトでテスト実行の際に本番環境のデータにアクセスできないため、SOQLを使用して既存のデータをクエリすることはできません。テストメソッドは隔離された環境で実行されるため、テスト用のデータはテストメソッド内で作成する必要があります。",
            "これは正解です。Test.loadData() メソッドは、静的リソースに格納されたCSVファイルからテストデータをロードするために使用されます。これにより、複雑なテストデータを簡単に準備することができ、テストの再現性と保守性が向上します。",
            "これは不正解です。Test.loadData() メソッドはCSVファイルのデータをロードするために使用されますが、JSONファイルを直接ロードする機能はありません。静的リソースからデータをロードする場合、データはCSV形式である必要があります。"
        ]
    },
    {
        "number": "120",
        "question": "有効なApexの代入はどれですか。",
        "choices": ["Integer x = 5*1.0;", "Integer x = 5.0;", "Double x = 5;", "Float x = 5.0;"],
        "correct": ["Double x = 5;"],
        "explanations":["Integer x = 5*1.0;", "Integer x = 5.0;", "Double x = 5;", "Float x = 5.0;"],
        "descriptions":[
            "これは不正解です。5*1.0の結果は5.0という浮動小数点数になります。Apexでは、浮動小数点数を整数型(Integer)に直接代入することは許可されていません。これは、データの精度の損失を防ぐためのものです。例えば、5.9という値を整数型に代入しようとすると、小数点以下の値が切り捨てられ、データの精度が失われる可能性があります。",
            "これは不正解です。5.0は浮動小数点数です。上記と同様の理由で、浮動小数点数を整数型に直接代入することは許可されていません。",
            "これは正解です。整数値5をDouble型の変数に代入することは許可されています。Apexでは、整数を浮動小数点数型に代入する際の暗黙的な型変換が許可されています。",
            "これは不正解です。ApexにはFloatというデータ型は存在しないためです。Apexで浮動小数点数を扱う場合は、Double型を使用します。"
        ]
    },
    {
        "number": "121",
        "question": "ApexとVisualforceページを使用する場合、MVCアーキテクチャのモデルを表すコードのタイプはどれですか。",
        "choices": ["SOQLを使用して取引先レコードのリストをクエリするコントローラ拡張メソッド", "取引先レコードのリストを保存するコントローラ拡張メソッド", "コントローラ拡張メソッドから返された取引先レコードのリスト", "取引先レコードのリストを処理するカスタムJavaScript"],
        "correct": ["コントローラ拡張メソッドから返された取引先レコードのリスト"],
        "explanations":["SOQLを使用して取引先レコードのリストをクエリするコントローラ拡張メソッド", "取引先レコードのリストを保存するコントローラ拡張メソッド", "コントローラ拡張メソッドから返された取引先レコードのリスト", "取引先レコードのリストを処理するカスタムJavaScript"],
        "descriptions":[
            "これは不正解です。このメソッドはデータを取得するロジックを含むため、MVCのコントローラの部分に該当します。",
            "これは不正解です。このメソッドはデータを保存するロジックを含むため、MVCのコントローラの部分に該当します。",
            "これは正解です。このリストはデータそのものを表しているため、MVCのモデルの部分に該当します。",
            "これは不正解です。このJavaScriptはデータの処理や表示のロジックを含むため、MVCのコントローラやビューの部分に該当する可能性がありますが、モデルの部分には該当しません。"
        ]
    },
    {
        "number": "122",
        "question": "開発者がトリガーでApexヒープ制限のエラーに遭遇した場合、このエラーを回避する方法はどれですか。 2つ選びなさい。",
        "choices": ["変数を宣言するときにtransientキーワードを使用する。", "関連するオブジェクトを更新するときに、関連するオブジェクトの項目をクエリしてコレクションに保存する。", "使用後にコレクションを削除するか、nullに設定する。", "大きなクエリ結果を単一のコレクションに割り当ててコレクションをループする代わりに、SOQLのループを使用する。"],
        "correct": ["使用後にコレクションを削除するか、nullに設定する。", "大きなクエリ結果を単一のコレクションに割り当ててコレクションをループする代わりに、SOQLのループを使用する。"],
        "explanations":["変数を宣言するときにtransientキーワードを使用する。", "関連するオブジェクトを更新するときに、関連するオブジェクトの項目をクエリしてコレクションに保存する。", "使用後にコレクションを削除するか、nullに設定する。", "大きなクエリ結果を単一のコレクションに割り当ててコレクションをループする代わりに、SOQLのループを使用する。"],
        "descriptions":[
            "これは不正解です。transient キーワードはVisualforceページのビューステートサイズを削減するため使用されますが、Apexのヒープ制限には直接関係ありません。",
            "これは不正解です。関連するオブジェクトの項目をクエリしてコレクションに保存するだけでは、ヒープ制限の問題を解決するわけではありません。",
            "これは正解です。コレクションからアイテムを削除することで、ランタイム中のヒープサイズを削減することができます。",
            "これは正解です。SOQL for ループは、クエリの結果を直接ループするための特別な構文です。この方法では、クエリの結果は一度にすべてメモリにロードされず、必要に応じて少しずつロードされます。これにより、大量のレコードを返すクエリでもヒープ制限を超えるリスクが低くなります。一方、通常の方法では、クエリが非常に多くのレコードを返す場合、すべてのレコードがメモリに格納されるため、ヒープ制限を超える可能性があります。"
        ]
    },
    {
        "number": "123",
        "question": "プラットフォーム開発者は、レコードが特定のレコードタイプに割り当てられている場合にのみ実行するApexメソッドを作成する必要があります。開発者が必要なレコードタイプIDをレコードタイプ名で動的に決定できる方法はどれですか。2つ選びなさい。",
        "choices": ["SOAP APIへのアウトバウンドWebサービス呼び出しを行う", "DescribeSObjectResultクラスでgetRecordTypeInfosByDeveloperNameメソッドを使用する", "Apexクラスの定数としてIDをハードコードする", "RecordTypeオブジェクトでSOQLクエリを実行する"],
        "correct": ["DescribeSObjectResultクラスでgetRecordTypeInfosByDeveloperNameメソッドを使用する", "RecordTypeオブジェクトでSOQLクエリを実行する"],
        "explanations":["SOAP APIへのアウトバウンドWebサービス呼び出しを行う", "DescribeSObjectResultクラスでgetRecordTypeInfosByDeveloperNameメソッドを使用する", "Apexクラスの定数としてIDをハードコードする", "RecordTypeオブジェクトでSOQLクエリを実行する"],
        "descriptions":[
            "これは不正解です。SOAP APIは外部システムとSalesforceとの間でデータを交換するために使いますが、Salesforce内で動的にレコードタイプIDを取得するのには適していません。",
            "これは正解です。DescribeSObjectResultクラスのgetRecordTypeInfosByDeveloperNameメソッドを使用することで、開発者名を基にレコードタイプの情報を動的に取得することができます。",
            "これは不正解です。IDをハードコードすると、異なる環境や組織間での移行時に問題が発生する可能性があります。また、レコードタイプが変更された場合や削除された場合に、コードの修正が必要になる可能性があります。",
            "これは正解です。RecordType オブジェクトを使用してSOQLクエリを実行することで、特定のオブジェクトのレコードタイプのIDを動的に取得することができます。"
        ]
    },
    {
        "number": "124",
        "question": "Visualforceページで外部CSSからのスタイリングが必要な場合、開発者はどのタグを含める必要がありますか。",
        "choices": ["apex:includeStyles", "apex:includeScript", "apex:require", "apex:stylesheet"],
        "correct": ["apex:stylesheet"],
        "explanations":["apex:includeStyles", "apex:includeScript", "apex:require", "apex:stylesheet"],
        "descriptions":[
            "これは不正解です。apex:includeStyles というタグはSalesforceのVisualforceには存在しません。",
            "これは不正解です。apex:includeScript タグは、Visualforce ページで使用できる JavaScript ライブラリへのリンクを提供します。このタグを使用すると、指定されたJavaScriptファイルをVisualforceページに含めることができます。しかし、このタグはCSSのスタイリングには使用されません。",
            "これは不正解です。apex:require というタグはSalesforceのVisualforceには存在しません。",
            "これは正解です。apex:stylesheet タグを使用すると、Visualforce ページでコンポーネントにスタイルを適用するためのスタイルシートへのリンクを提供します。このタグのvalue属性には、スタイルシートファイルのURLを指定します。この方法を使用すると、外部のCSSファイルをVisualforceページにリンクすることができます。"
        ]
    },
    {
        "number": "125",
        "question": "Apexクラスのプライベートメソッドの単体テストをどのように作成する必要がありますか。",
        "choices": ["SeeAllDataアノテーションを使用します", "Apexクラスにテストメソッドを追加します", "TestVisibleアノテーションを使用します", "Apexクラスをグローバルにします"],
        "correct": ["TestVisibleアノテーションを使用します"],
        "explanations":["SeeAllDataアノテーションを使用します", "Apexクラスにテストメソッドを追加します", "TestVisibleアノテーションを使用します", "Apexクラスをグローバルにします"],
        "descriptions":[
            "これは不正解です。@SeeAllDataは、テストメソッドが実際の組織データにアクセスできるかどうかを制御するためのものです。privateメソッドのテストとは関係ありません。",
            "これは不正解です。テストメソッドは、通常、別のテストクラスに含まれています。また、テストメソッド内からprivateメソッドを直接呼び出すことはできません。",
            "これは正解です。@TestVisibleをprivateメソッドの前に配置することで、そのメソッドはテストクラスからアクセス可能になります。これにより、privateメソッドの単体テストを書くことができます。",
            "これは不正解です。Apexクラスをグローバルにすることは、privateメソッドのテストのための適切な方法ではありません。グローバルなクラスは、任意のApexコードからアクセスできるようになりますが、これは通常、APIや他のパッケージからのアクセスが必要な場合にのみ行われます。"
        ]
    },
    {
        "number": "126",
        "previous-code": [
            "public class InsuranceRates{",
            "    public static final Decimal smokerCharge = 0.01;",
            "}\n",
            "trigger ContactTrigger on Contact(before insert){",
            "    InsuranceRates rates = new InsuranceRates();",
            "    Decimal baseCost = XXX;",
            "}"
        ],
        "question": "以上のクラスとトリガーのコードがあります。\nbaseCost変数にクラス変数smokerChargeの値を設定するために、開発者はXXXにどのコードを挿入する必要がありますか。",
        "choices": ["rates.smokerCharge", "InsuranceRates.smokerCharge", "ContactTrigger.InsuranceRates.smokerCharge", "rates.getSmokerCharge()"],
        "correct": ["InsuranceRates.smokerCharge"],
        "explanations":["rates.smokerCharge", "InsuranceRates.smokerCharge", "ContactTrigger.InsuranceRates.smokerCharge", "rates.getSmokerCharge()"],
        "descriptions":[
            "これは不正解です。smokerChargeはstatic変数であるため、クラスのインスタンスを使用してアクセスすることはできません。",
            "これは正解です。smokerChargeはstatic変数であるため、クラス名を使用して直接アクセスできます。",
            "これは不正解です。このようなネストされたクラスの参照は正しくありません。また、ContactTriggerトリガー内でInsuranceRatesクラスをネストしているわけではありません。",
            "これは不正解です。示されたコードにはgetSmokerCharge()というメソッドは存在しないため、この方法でsmokerChargeにアクセスすることはできません。"
        ]
    },
    {
        "number": "127",
        "question": "Universal Containers社には、特定のアカウントによってレンタルされているすべてのContainer__cのテーブルを表示するVisualforceページがあります。一部の顧客が100,000を超えるコンテナをレンタルしているため、ビューステートの最大制限エラーとなります。ページの読み込みエラーを解決するために、開発者はVisualforceページについて何を変更する必要がありますか。",
        "choices": ["SOQLのOFFSETでJavaScript Remotingを使用します", "StandardSetControllerを使用してページネーションを実装します", "遅延読み込みと一時的なリスト変数を使用します", "OffsetControllerを使用してページネーションを実装します"],
        "correct": ["StandardSetControllerを使用してページネーションを実装します"],
        "explanations":["SOQLのOFFSETでJavaScript Remotingを使用します", "StandardSetControllerを使用してページネーションを実装します", "遅延読み込みと一時的なリスト変数を使用します", "OffsetControllerを使用してページネーションを実装します"],
        "descriptions":[
            "これは不正解です。JavaScript Remotingはクライアント側での非同期データ取得に使用され、ビューステートのサイズを減らすのに役立ちますが、SOQLのOFFSET句には2000レコードまでの制限があり、100,000を超えるような大規模なデータセットでは使えません。",
            "これは正解です。StandardSetControllerは、大量のデータを扱うVisualforceページでページネーションを実装するためのものです。これにより、一度に表示されるレコードの数を制限し、ビューステートの制限を超えることなくページを表示することができます。",
            "これは不正解です。遅延読み込みはデータを必要に応じてロードする技術で、ビューステートのサイズを減らすことができます。しかし、これだけではビューステートの最大制限エラーを根本から解決するには不十分です。",
            "これは不正解です。OffsetControllerというものは、Salesforceの標準のクラスやコンポーネントとして存在しません。"
        ]
    },
    {
        "number": "128",
        "question": "Universal Containers社は、新しいSalesforceアプリケーションを構築するために、宣言型開発のみを使用することを決定しました。アプリケーションのデータベースレイヤーを構築するために使用すべきオプションはどれですか。3つ選びなさい。",
        "choices": ["フロー", "積み上げ集計項目", "トリガー", "リレーションシップ", "カスタムオブジェクトとカスタム項目"],
        "correct": ["積み上げ集計項目", "リレーションシップ", "カスタムオブジェクトとカスタム項目"],
        "explanations":["フロー", "積み上げ集計項目", "トリガー", "リレーションシップ", "カスタムオブジェクトとカスタム項目"],
        "descriptions":[
            "これは不正解です。フローはSalesforceの強力な自動化ツールであり、複雑なビジネスロジックやユーザーインタラクションを視覚的に設計するのに使用されます。しかし、フローは主にプロセス自動化やユーザー操作のガイドに焦点を当てているため、データベースレイヤーの構築そのものとは直接関連していません。フローはユーザーのアクションに応じて特定の操作を実行するために使用され、データベースの構造やデータの格納方法を定義するものではありません。",
            "これは正解です。積み上げ集計項目は宣言型機能で、関連オブジェクトのデータを集計して親オブジェクトに表示します。これにより、コードを書かずに関連データの集計を実現できます。",
            "これは不正解です。トリガーはApexコードを使用して特定の条件で自動的にアクションを実行するために使用され、宣言型開発ではなく、プログラマティックな開発手法に分類されます。",
            "これは正解です。主従関係や参照関係などのリレーションシップは、異なるオブジェクト間の関連を定義し、複雑なデータ構造を宣言型の方法で構築するのに役立ちます。",
            "これは正解です。カスタムオブジェクトとカスタム項目は、特定のビジネス要件に合わせて新しいデータ構造を宣言型で作成する基本的な方法です。"
        ]
    },
    {
        "number": "129",
        "question": "開発者は、Lightningコンポーネントが取引先責任者のレコードを検索するために使用できるApexクラス「ContactController」を作成する必要があります。Lightningコンポーネントのユーザーは、自分がアクセス権を持つ取引先責任者のレコードのみを検索できるようにするべきです。正しくレコードを制限するための方法は何ですか。2つ選びなさい。",
        "choices": ["public class ContactController", "public with sharing class ContactController", "public without sharing class ContactController", "public inherited sharing class ContactController"],
        "correct": ["public with sharing class ContactController", "public inherited sharing class ContactController"],
        "explanations":["public class ContactController", "public with sharing class ContactController", "public without sharing class ContactController", "public inherited sharing class ContactController"],
        "descriptions":[
            "これは不正解です。この宣言だけではレコードへのアクセス制限は明示的には行われません。このクラスは、呼び出し元のクラスやトリガーの共有設定に依存します。",
            "これは正解です。「with sharing」キーワードを使用すると、このクラスは実行ユーザーの共有設定を尊重します。つまり、ユーザーがアクセスできるレコードのみを検索や操作できるようになります。",
            "これは不正解です。「without sharing」キーワードを使用すると、このクラスは実行ユーザーの共有設定を無視します。これは、ユーザーがアクセスできないレコードにもアクセスできる可能性があるため、この要件には適していません。",
            "これは正解です。inherited sharingキーワードを使用すると、クラスは親クラスまたは呼び出し元の共有設定を継承します。これにより、クラスが他の「with sharing」クラスから呼び出される場合、ユーザーの共有設定を尊重することができます。このキーワードは、クラスが共有設定を持たない場合や、他のクラスから呼び出される場合に特に有用です。"
        ]
    },
    {
        "number": "130",
        "question": "匿名ブロックで実行されるApexコードに関して正しい答えはどれですか。2つ選びなさい。",
        "choices": ["コードは、runAs()ステートメントで指定されたユーザーの権限で実行されます", "コードは、ログインしているユーザーの権限で実行されます", "コードは、すべてのオブジェクトとフィールドにアクセスできるシステムモードで実行されます", "すべてのDML操作は自動的にロールバックされます", "成功したDML操作は自動的にコミットされます"],
        "correct": ["コードは、ログインしているユーザーの権限で実行されます", "成功したDML操作は自動的にコミットされます"],
        "explanations":["コードは、runAs()ステートメントで指定されたユーザーの権限で実行されます", "コードは、ログインしているユーザーの権限で実行されます", "コードは、すべてのオブジェクトとフィールドにアクセスできるシステムモードで実行されます", "すべてのDML操作は自動的にロールバックされます", "成功したDML操作は自動的にコミットされます"],
        "descriptions":[
            "これは不正解です。runAs()はテストメソッド内でのみ使用され、匿名ブロックでは使用されません。",
            "これは正解です。匿名ブロックは現在ログインしているユーザーの権限で実行されます。",
            "これは不正解です。匿名ブロックは現在のユーザーの権限で実行されるため、ユーザーのアクセス権限に違反するコードはコンパイルできない場合があります。",
            "これは不正解です。DML操作は、匿名ブロックの実行が失敗した場合のみロールバックされます。",
            "これは正解です。匿名ブロック内でのDML操作が成功した場合、その変更は自動的にデータベースにコミットされます。"
        ]
    },
    {
        "number": "131",
        "question": "開発者は、maxAttempts と呼ばれる整数変数を持っています。開発者は、一度maxAttemptsが初期化されると、トリガー実行の間で変数の状態を共有しながら、Apex処理の間、その値を確実に保持する必要があります。これらの要求を満たすために、開発者はどのようにmaxAttemptsを宣言する必要がありますか。",
        "choices": ["staticキーワードとfinalキーワードを使用して、maxattemptsを定数として宣言する。", "maxattempts をヘルパークラスの変数として宣言する。", "maxattempts をヘルパークラスの private static 変数として宣言する。", "maxattempts をトリガー定義のメンバ変数として宣言する。"],
        "correct": ["staticキーワードとfinalキーワードを使用して、maxattemptsを定数として宣言する。"],
        "explanations":["staticキーワードとfinalキーワードを使用して、maxattemptsを定数として宣言する。", "maxattempts をヘルパークラスの変数として宣言する。", "maxattempts をヘルパークラスの private static 変数として宣言する。", "maxattempts をトリガー定義のメンバ変数として宣言する。"],
        "descriptions":[
            "これは正解です。static finalを使用することで、変数を定数として宣言し、一度初期化されるとその後変更することができなくなります。",
            "これは不正解です。この方法だけでは変数の値が変更されないことを保証できません。",
            "これは不正解です。private staticだけでは、変数の値が変更されないことを保証できません。",
            "これは不正解です。トリガーのメンバ変数として宣言しても、変数の値が変更されないことを保証できません。"
        ]
    },
    {
        "number": "132",
        "question": "次のSOSL検索によって返されるデータ型は何ですか。",
        "choices": ["List<List<Account>, List<Opportunity>>", "Map<sObject, sObject>", "List<List<sObject>>", "Map<Id, sObject>"],
        "correct": ["List<List<sObject>>"],
        "explanations":["List<List<Account>, List<Opportunity>>", "Map<sObject, sObject>", "List<List<sObject>>", "Map<Id, sObject>"],
        "descriptions":[
            "これは不正解です。SOSL検索の結果は、異なるsObjectタイプごとにリストのリストとして返されますが、この具体的なデータ型は正確ではありません。",
            "これは不正解です。SOSLの結果はマップ型では返されません。",
            "これは正解です。SOSLクエリは複数のオブジェクトタイプにわたる検索を行うことができ、結果はList<List<sObject>>の形式で返されます。外側のListは異なるオブジェクトタイプごとの検索結果を含み、内側のListは特定のオブジェクトタイプに対する検索結果です。",
            "これは不正解です。SOSLの結果はマップ型では返されません。"
        ]
    },
    {
        "number": "133",
        "question": "ApexクラスをRESTfulWebサービスとして公開するアノテーションはどれですか。",
        "choices": ["@RemoteAction", "@HttpInvocable", "@AuraEnabled", "@RestResource"],
        "correct": ["@RestResource"],
        "explanations":["@RemoteAction", "@HttpInvocable", "@AuraEnabled", "@RestResource"],
        "descriptions":[
            "これは不正解です。@RemoteActionはVisualforceページからJavaScriptを介してApexメソッドを非同期で呼び出すためのアノテーションです。RESTful Webサービスとは関係ありません。",
            "これは不正解です。@Httplnvocableは存在しないアノテーションです。",
            "これは不正解です。@AuraEnabledは、Lightningコンポーネント(Lightning Web コンポーネントとAura コンポーネントの両方)からApexメソッドをアクセスするためのアノテーションです。RESTful Webサービスとしての公開には使用されません。",
            "これは正解です。@RestResourceはApexクラスをRESTful Webサービスとして公開するためのクラスレベルのアノテーションです。このアノテーションを使用することで、特定のURL経由でApexメソッドにアクセスできるようになります。"
        ]
    },
    {
        "number": "134",
        "question": "クロスオブジェクト数式項目に関する記述のうち、正しいものは どれですか。3つ選びなさい。",
        "choices": ["クロスオブジェクト数式項目は、最大10リレーション離れているオブジェクトの項目を参照できます", "クロスオブジェクト数式項目は、主従関係または参照関係の項目を参照できます", "クロスオブジェクト数式項目は、子項目を参照して平均を実行できます", "クロスオブジェクト数式項目は、ユーザーがアクセスできないデータをレコードに公開する可能性があります", "クロスオブジェクト数式項目は積み上げ集計項目を参照できます"],
        "correct": ["クロスオブジェクト数式項目は、最大10リレーション離れているオブジェクトの項目を参照できます", "クロスオブジェクト数式項目は、主従関係または参照関係の項目を参照できます", "クロスオブジェクト数式項目は、ユーザーがアクセスできないデータをレコードに公開する可能性があります"],
        "explanations":["クロスオブジェクト数式項目は、最大10リレーション離れているオブジェクトの項目を参照できます", "クロスオブジェクト数式項目は、主従関係または参照関係の項目を参照できます", "クロスオブジェクト数式項目は、子項目を参照して平均を実行できます", "クロスオブジェクト数式項目は、ユーザーがアクセスできないデータをレコードに公開する可能性があります", "クロスオブジェクト数式項目は積み上げ集計項目を参照できます"],
        "descriptions":[
            "これは正解です。クロスオブジェクト数式項目は最大10リレーション離れたオブジェクトの項目を参照します。",
            "これは正解です。クロスオブジェクト数式項目は主従関係の従側や参照関係の項目を参照します。",
            "これは不正解です。クロスオブジェクト数式項目は子項目を直接参照しての平均計算を行えません。",
            "これは正解です。ユーザーがアクセス権限を持たないオブジェクトレコードの項目も、クロスオブジェクト数式項目を通じて表示されます。",
            "これは不正解です。クロスオブジェクト数式項目は積み上げ集計項目を参照できません。"
        ]
    },
    {
        "number": "135",
        "question": "開発者はループ処理で、リスト内の各取引先責任者をチェックします。”Boss”というタイトルの取引先責任者が見つかった場合、Apexのメソッドはforループの外側のコードの最初の行にジャンプする必要があります。要件を実装するためのコーディングはどれですか。",
        "choices": ["break;", "continue;", "next;", "exit;"],
        "correct": ["break;"],
        "explanations":["break;", "continue;", "next;", "exit;"],
        "descriptions":[
            "これは正解です。Apexにおいてbreak;はループを完全に終了し、ループの後の次の行にジャンプします。今回の場合、”Boss”というタイトルの取引先責任者が見つかったときにループを終了します。",
            "これは不正解です。Apexにおいてcontinue;は現在のループのイテレーションをスキップし、次のイテレーションにジャンプします。今回の場合、”Boss”というタイトルの取引先責任者が見つかったときに、そのイテレーションをスキップして次のイテレーションに進みます。",
            "これは不正解です。Apexにはnextというキーワードは存在しません。",
            "これは不正解です。Apexにはexitというキーワードは存在しません。"
        ]
    },
    {
        "number": "136",
        "previous-code": [
            "Account myAccount = [SELECT Id, Name FROM Account];"
        ],
        "question": "以上のApexステートメントがあります。\nSOQLクエリによって複数のAccountが返された場合、何が発生しますか。",
        "choices": ["変数myAccountは自動的にListデータ型にキャストされます。", "最初に返された Account が myAccount に代入されます。", "クエリは失敗し、エラーがデバッグログに書き込まれます。", "未処理の例外がスローされ、コードが終了します。"],
        "correct": ["未処理の例外がスローされ、コードが終了します。"],
        "explanations":["変数myAccountは自動的にListデータ型にキャストされます。", "最初に返された Account が myAccount に代入されます。", "クエリは失敗し、エラーがデバッグログに書き込まれます。", "未処理の例外がスローされ、コードが終了します。"],
        "descriptions":[
            "これは不正解です。Apexでは自動的に変数のデータ型を変更することはできません。",
            "これは不正解です。単一のsObject変数に複数のレコードを代入することはできません。",
            "これは不正解です。Apexでは、SOQLクエリが複数のレコードを返す場合、単一のsObject変数に代入しようとすると「List has more than 1 row for assignment to SObject」という未処理の例外がスローされます。この例外はコードの実行を中断させると同時に、デバッグログに例外情報として記録されます。",
            "これは正解です。SOQLクエリが複数のレコードを返す場合、単一のsObject変数に代入しようとすると、「List has more than 1 row for assignment to SObject」という未処理の例外がスローされ、コードの実行が中断されます。"
        ]
    },
    {
        "number": "137",
        "question": "開発者は、Apexテストメソッドがサンドボックスで失敗することに気づきました。問題を特定するために、開発者はテストメソッド内のコードをコピーし、開発者コンソールの匿名実行ツールを使用してコードを実行したところ、コードは例外やエラーなしで実行されます。テストメソッドがサンドボックスで失敗し、開発者コンソールで合格したのはなぜですか。",
        "choices": ["テストメソッドは @future メソッドを呼び出しているため", "テストメソッドのコードに構文エラーがあるため", "テストメソッドは、特定のユーザーとして実行するためにSystem.runAsを使用しないため", "テストメソッドはサンドボックス内の既存のデータに依存しているため"],
        "correct": ["テストメソッドはサンドボックス内の既存のデータに依存しているため"],
        "explanations":["テストメソッドは @future メソッドを呼び出しているため", "テストメソッドのコードに構文エラーがあるため", "テストメソッドは、特定のユーザーとして実行するためにSystem.runAsを使用しないため", "テストメソッドはサンドボックス内の既存のデータに依存しているため"],
        "descriptions":[
            "これは不正解です。@future メソッドは非同期で実行されるため、テストメソッドの実行とは独立して動作します。しかし、今回の問題の直接的な原因とは考えられません。",
            "これは不正解です。構文エラーが存在する場合、開発者コンソールの匿名実行ツールでもエラーが発生するはずです。",
            "これは不正解です。System.runAsを使用しなかった場合、特定のユーザーコンテキストでの実行が問題になることがありますが、開発者コンソールでの匿名実行は実行ユーザーの権限で行われるため、この点が原因でテストがサンドボックスで失敗するとは限りません。",
            "これは正解です。Apexテストメソッドはデフォルトで隔離されたテスト環境で実行され、既存のデータにアクセスすることはありません(@isTest(SeeAllData=true)が設定されていない限り)。もしテストメソッドが既存のデータに依存している場合、サンドボックス内でそのデータが欠如しているか異なっている可能性があり、そのために失敗することがあります。しかし、開発者コンソールで匿名実行を行う場合は、実際の環境データを用いて実行されるため、問題が発生しなかった可能性があります。"
        ]
    },
    {
        "number": "138",
        "question": "ある開発者は、自分の組織でカスタムページがロードされたときにパフォーマンスの問題の原因を突き止めるためにトラブルシューティングを行う必要があります。開発者がトラブルシューティングに使用すべきツールはどれか。",
        "choices": ["Salesforce CLI", "AppExchange", "開発者コンソール", "Visual Studio Code IDE"],
        "correct": ["開発者コンソール"],
        "explanations":["Salesforce CLI", "AppExchange", "開発者コンソール", "Visual Studio Code IDE"],
        "descriptions":[
            "これは不正解です。Salesforce CLIは、Salesforce DXの一部として提供されるコマンドラインツールであり、主にメタデータの操作やスクリプトの実行などのタスクに使用されます。ページロードのパフォーマンス問題のトラブルシューティングには直接的には関係ありません。",
            "これは不正解です。AppExchangeはSalesforceのマーケットプレイスであり、アプリケーションやコンポーネントの公開や取得を行う場所です。パフォーマンスの問題のトラブルシューティングには使用されません。",
            "これは正解です。開発者コンソールは、Apexコードの実行、SOQLクエリの実行、ログの確認、パフォーマンスの問題の診断など、Salesforce開発者が使用する多くのツールを提供しています。特に、ログの詳細な分析や実行時間の計測など、パフォーマンスの問題を特定するための機能が含まれています。",
            "これは不正解です。Visual Studio Code IDEは、Salesforce開発のための強力なエディターであり、Salesforce Extensionsを使用してSalesforce DXと統合できます。しかし、直接的なパフォーマンスのトラブルシューティングのツールとしては使用されません。"
        ]
    },
    {
        "number": "139",
        "question": "スキーマビルダーを使用して開発者が実行できるアクションはどれですか。2つ選びなさい。",
        "choices": ["カスタムオブジェクトを作成し、そのオブジェクトに参照関係を定義する", "標準オブジェクトとシステムオブジェクトのみを含むビューを表示する", "カスタム項目を作成し、既存のページレイアウトに自動的に追加する", "項目のないオブジェクトとリレーションのビューを作成する"],
        "correct": ["カスタムオブジェクトを作成し、そのオブジェクトに参照関係を定義する", "標準オブジェクトとシステムオブジェクトのみを含むビューを表示する"],
        "explanations":["カスタムオブジェクトを作成し、そのオブジェクトに参照関係を定義する", "標準オブジェクトとシステムオブジェクトのみを含むビューを表示する", "カスタム項目を作成し、既存のページレイアウトに自動的に追加する", "項目のないオブジェクトとリレーションのビューを作成する"],
        "descriptions":[
            "これは正解です。スキーマビルダーを使用して、カスタムオブジェクトを作成し、そのオブジェクトに対して参照関係や主従関係を定義することができます。",
            "これは正解です。スキーマビルダーはオブジェクトとその関係を視覚的に表示するツールであり、標準オブジェクトやシステムオブジェクトを含むビューを表示することができます。",
            "これは不正解です。スキーマビルダーを使用してカスタム項目を作成することはできますが、それを既存のページレイアウトに自動的に追加する機能は提供していません。",
            "これは不正解です。項目のないオブジェクトは実際には存在しないため、そのようなオブジェクトを作成することはできません。スキーマビルダーはオブジェクトとその関係を視覚的に表示するツールであり、特定の「ビュー」を作成する機能は提供していません。"
        ]
    },
    {
        "number": "140",
        "question": "開発者は、リードオブジェクトにbefore insertトリガーを使用して、Territory__c.PostalCode__cがLead.PostalCodeと一致するTerritory__cオブジェクトを取得します。しかし、開発者がデータローダーを使用して10,000のリードレコードを挿入すると、コードが失敗します。\nどのコード行がコードブロックの失敗の原因となっていますか。",
        "following-code": [
            "for (Lead l : Trigger.new) {",
            "    if (l.PostalCode != null) {",
            "        List<Territory__c> terrList = [SELECT Id FROM Territory__c WHERE PostalCode__c = :l.PostalCode];",
            "        if(terrList.size() > 0) {",
            "            l.Territory__c = terrList[0].Id;",
            "        }",
            "    }",
            "}"
        ],
        "choices": ["3行目：SOQLクエリがforループコードの内部に配置されてるため", "1行目：before insertトリガーではTrigger:newは無効なため", "2行目：PostalCodeがnullの場合、NullPointer例外がスローされるため", "5行目：before insertトリガー内のLeadは更新できないため"],
        "correct": ["3行目：SOQLクエリがforループコードの内部に配置されてるため"],
        "explanations":["3行目：SOQLクエリがforループコードの内部に配置されてるため", "1行目：before insertトリガーではTrigger:newは無効なため", "2行目：PostalCodeがnullの場合、NullPointer例外がスローされるため", "5行目：before insertトリガー内のLeadは更新できないため"],
        "descriptions":[
            "これは正解です。大量のレコードを処理する際、ループの中でSOQLクエリを実行すると、すぐにSOQLクエリの制限に達してしまいます。このような設計は、大量のデータを処理する際に効率的ではありません。",
            "これは不正解です。Trigger.newはbefore insertトリガーで有効です。これは新しく挿入されるレコードのリストを参照します。",
            "これは不正解です。コードはl.PostalCodeがnullでない場合のみSOQLクエリを実行するようになっているため、NullPointer例外は発生しません。",
            "これは不正解です。before insertトリガー内では、Trigger.newのレコードの項目を変更することができます。そのため、この行は問題を引き起こすものではありません。"
        ]
    },
    {
        "number": "141",
        "question": "デバッグログフィルター設定はどこから設定できますか。2つ選びなさい。",
        "choices": ["ウェブUI内の監視ユーザー名の[Filters]リンク", "監視対象ユーザーの名前", "デバッグログのレコードの[詳細を表示]リンク", "クラスまたはトリガーの詳細ページの[追跡フラグ]タブ"],
        "correct": ["ウェブUI内の監視ユーザー名の[Filters]リンク", "クラスまたはトリガーの詳細ページの[追跡フラグ]タブ"],
        "explanations":["ウェブUI内の監視ユーザー名の[Filters]リンク", "監視対象ユーザーの名前", "デバッグログのレコードの[詳細を表示]リンク", "クラスまたはトリガーの詳細ページの[追跡フラグ]タブ"],
        "descriptions":[
            "これは正解です。デバッグログのフィルタ設定は、設定⇒デバッグログ⇒ユーザー追跡フラグのユーザー名の隣にある[Filters]リンクをクリックすることでアクセスできます。ここで、特定のユーザーのデバッグログの詳細レベルを設定することができます。",
            "これは不正解です。設定⇒デバッグログ⇒ユーザー追跡フラグのユーザー名をクリックしても、デバッグログのフィルタ設定にはアクセスできません。",
            "これは不正解です。[詳細を表示]というリンクは存在しないため、デバッグログのフィルタ設定にはアクセスできません。ただし、設定⇒デバッグログ⇒ユーザー追跡フラグ⇒デバッグレベル名をクリックすることで、そのデバッグレベル名のデバッグレベルの詳細が出てきます。",
            "これは正解です。クラスやトリガーの詳細ページには[追跡フラグ]タブがあり、このタブを使用してデバッグログのフィルター設定を行うことができます。"
        ]
    },
    {
        "number": "142",
        "previous-code": [
            "Opportunity opp = [select id, stagename from Opportunity Limit 1];"
        ],
        "question": "上記のコードがある場合、開発者はどのようにstagename項目のラベルを取得できますか。",
        "choices": ["“opp.stagename.label”を呼び出す", "“opp.stagename.getdescribe().getlabel()”を呼び出す", "“opportunity.stagename.label”を呼び出す", "“opportunity.stagename.getdescribe().getlabel()”を呼び出す"],
        "correct": ["“opp.stagename.getdescribe().getlabel()”を呼び出す"],
        "explanations":["“opp.stagename.label”を呼び出す", "“opp.stagename.getdescribe().getlabel()”を呼び出す", "“opportunity.stagename.label”を呼び出す", "“opportunity.stagename.getdescribe().getlabel()”を呼び出す"],
        "descriptions":[
            "これは不正解です。Apexでは、項目のラベルに直接アクセスする方法としてこのような構文はサポートされていません。",
            "これは正解です。opp.stagename.getDescribe().getLabel()は、ApexのDescribeメソッドを使用して項目のメタデータ情報を取得するための正しい方法です。これにより、stagename項目のラベルを取得できます。",
            "これは不正解です。opportunityはクラス名として使用されるものであり、インスタンス変数としてこの方法では使用できません。また、項目ラベルに直接アクセスする方法はサポートされていません。",
            "これは不正解です。opportunityはApexクラスの名前として使用されるため、インスタンス変数としてこの方法では使用できません。項目のラベルを取得するためには、インスタンス変数に対してDescribeメソッドを呼び出す必要があります。"
        ]
    },
    {
        "number": "143",
        "question": "テキストエリア (リッチ)項目が自動的に割り当てられるプリミティブデータ型はどれですか。",
        "choices": ["Blob", "Text", "Object", "String"],
        "correct": ["String"],
        "explanations":["Blob", "Text", "Object", "String"],
        "descriptions":[
            "これは不正解です。Blobはバイナリデータを格納するためのデータ型です。テキストエリア (リッチ)項目は文字列データを格納するため、Blobは適切なデータ型ではありません。",
            "これは不正解です。TextはApexにおける正式なプリミティブデータ型ではありません。テキスト項目は String データ型として扱われます。",
            "これは不正解です。Objectは特定のデータ型ではなく、全てのデータ型のスーパークラスです。特定の項目のデータ型としてObjectを使うことはありません。",
            "これは正解です。Salesforceのテキストエリア(リッチ)項目は、Apexコード内でStringデータ型として扱われます。String型はテキスト情報を保存するのに使われるので、リッチテキストを含む項目のデータ型としても使用されます。"
        ]
    },
    {
        "number": "144",
        "question": "開発者が、カスタムコントローラでカスタム例外が正しく機能することを確認するために単体テストを書きましたが、例外がスローされたためにテストが失敗しました。\nこの問題を解決し、例外を適切にテストするために、開発者が取るべき手順はどれでしょうか。",
        "choices": ["単体テスト内でtry/catchを使用して例外をキャッチする", "単体テスト内でfinallyブロックを使用して、例外を投入する", "データベースメソッドを、allまたはnoneをFALSEに設定して使用する", "カスタムコントローラ内でTest.isRunningTest()を使用する"],
        "correct": ["単体テスト内でtry/catchを使用して例外をキャッチする"],
        "explanations":["単体テスト内でtry/catchを使用して例外をキャッチする", "単体テスト内でfinallyブロックを使用して、例外を投入する", "データベースメソッドを、allまたはnoneをFALSEに設定して使用する", "カスタムコントローラ内でTest.isRunningTest()を使用する"],
        "descriptions":[
            "これは正解です。単体テスト中に例外がスローされることを期待する場合、try/catchブロックを使用してその例外をキャッチすることで、テストが失敗するのを防ぐことができます。例外が正しくスローされることを確認するためには、catchブロック内でアサーションを使用することが一般的です。",
            "これは不正解です。finallyブロックは、tryまたはcatchブロックの後に実行されるブロックで、例外が発生したかどうかに関係なく実行されます。例外を投入するためにfinallyブロックを使用することは、一般的な使用法ではありません。",
            "これは不正解です。allOrNoneパラメータは、データベース操作が部分的に成功した場合に、全体をコミットするかロールバックするかを制御します。このパラメータは例外のテストとは直接関係がありません。",
            "これは不正解です。Test.isRunningTest()メソッドは、現在のコードがテスト実行中かどうかを判断するために使用されます。これを使用して例外の動作を変更することは、実際の動作とテスト動作の間に差異を生じさせる可能性があり、推奨されません。"
        ]
    },
    {
        "number": "145",
        "question": "データの一意なキーと値のペアを提供するコレクション型はどれですか。",
        "choices": ["List", "Set", "Array", "Map"],
        "correct": ["Map"],
        "explanations":["List", "Set", "Array", "Map"],
        "descriptions":[
            "これは不正解です。Listは順序付けられたコレクションであり、要素にインデックスを使用してアクセスします。一意なキーと値のペアを提供するものではありません。",
            "これは不正解です。Setは一意の要素のコレクションであり、重複する要素を含むことはできません。キーと値のペアを持つわけではありません。",
            "これは不正解です。Arrayは他のプログラミング言語での一般的なデータ構造ですが、Apexには「Array」という型は存在しません。Apexでは、Listが配列の役割を果たします。",
            "これは正解です。Mapは一意なキーとそれに関連付けられた値のペアを格納するコレクションです。キーは一意であるため、同じキーに対する複数の値を持つことはできません。"
        ]
    },
    {
        "number": "146",
        "question": "Apex処理が100件のAccountレコードと2,000件のContactレコードを挿入した後、500件のOpportunityレコードを挿入しようとしてDML例外が発生しました。Accountレコードは、allOrNone引数をfalseに設定してdatabase.insert()メソッドを呼び出すことで挿入されます。ContactおよびOpportunityレコードは、スタンドアロンinsert文(通常のInsert 変数名;)を使用して挿入されます。この処理でデータベースにコミットされるレコードの総数はいくつですか。",
        "choices": ["2,000", "2,100", "0", "100"],
        "correct": ["100"],
        "explanations":["2,000", "2,100", "0", "100"],
        "descriptions":[
            "これは不正解です。2,000件のContactレコードの挿入時にDML例外が発生するため、これらのレコードはデータベースにコミットされません。",
            "これは不正解です。2,000件のContactレコードはDML例外のためコミットされません。したがって、100件のAccountレコードと2,000件のContactレコードの合計2,100件がコミットされることはありません。",
            "これは不正解です。100件のAccountレコードはDatabase.insert(obj, false)を使用して正常にデータベースにコミットされます。",
            "これは正解です。Database.insert(obj, false)を使用して100件のAccountレコードがデータベースに正常にコミットされます。しかし、2,000件のContactレコードの挿入時にDML例外が発生するため、これらのレコードはデータベースにコミットされません。したがって、データベースにコミットされるレコードの総数は100件のAccountレコードのみとなります。"
        ]
    },
    {
        "number": "147",
        "question": "開発者は、従来のオンプレミスのSQLデータベースと統合しています。統合されるデータが Salesforce内の適切なレコードと一致するようにするには、開発者は何を使用すればよいでしょうか。",
        "choices": ["外部オブジェクト", "外部ID項目", "参照関係", "数式項目"],
        "correct": ["外部ID項目"],
        "explanations":["外部オブジェクト", "外部ID項目", "参照関係", "数式項目"],
        "descriptions":[
            "これは不正解です。外部オブジェクトは、Salesforce Connectを使用して外部システムのデータにリアルタイムでアクセスするためのものです。オンプレミスのSQLデータベースと統合する場合には使用できますが、Salesforce内の適切なレコードと一致させるための直接的な方法ではありません。",
            "これは正解です。外部IDは、外部システムの一意の識別子をSalesforce内に保存し、データの整合性を保つために使用されます。これにより、オンプレミスのSQLデータベースからのデータがSalesforceのレコードと正確に一致するようになります。カスタム項目を外部IDとして使用することで、データの重複を防ぎ、一貫性を保つことができます。",
            "これは不正解です。参照関係は、Salesforce内のオブジェクト間の関係を作成するためのもので、外部システムのデータを一致させるためには使用されません。参照関係を使用することで、関連レコード間のナビゲーションが可能になりますが、外部データとの統合には適していません。",
            "これは不正解です。数式項目は、他の項目の値を基に自動的に計算される項目です。数式項目を使用して外部データと統合することはできませんし、Salesforce内のレコードと外部データベースのレコードを一致させるためのツールではありません。"
        ]
    },
    {
        "number": "148",
        "question": "ある開発者が、WithSharingキーワードを使用するVisualforceページとApexコントローラを作成しました。このページは営業マネージャーが使用し、実行中の営業マネージャーに報告する営業担当者が所有する取引先のみを表示する必要があります。取引先に対する組織全体の共有は非公開に設定されています。開発者が取るべき追加の手順はどれですか。",
        "choices": ["1つのプロファイル、1つの権限セット、1つのロールを作成する", "2つのプロファイル、1つの権限セット、1つのロールを作成する", "1つのプロファイル、1つの権限セット、2つのロールを作成する", "1つのプロファイル、2つの権限セット、1つのロールを作成する"],
        "correct": ["1つのプロファイル、1つの権限セット、2つのロールを作成する"],
        "explanations":["1つのプロファイル、1つの権限セット、1つのロールを作成する", "2つのプロファイル、1つの権限セット、1つのロールを作成する", "1つのプロファイル、1つの権限セット、2つのロールを作成する", "1つのプロファイル、2つの権限セット、1つのロールを作成する"],
        "descriptions":[
            "これは不正解です。この設定では、営業マネージャーと営業担当者間の階層的な関係を表現できません。営業マネージャーが自分に報告する営業担当者のデータのみを見るためには、ロール階層が必要です。",
            "これは不正解です。この設定では、ロール階層が適切に設定されていないため、営業マネージャーが自分に報告する営業担当者の取引先データにアクセスすることができません。プロファイルはオブジェクトや項目など基本的なアクセス権を定義しますが、ロール階層がないと、階層内でのデータ共有とアクセスは実現不可能です。",
            "これは正解です。この方法では、1つのプロファイルと権限セットで基本的なアクセス権を定義し、2つのロール(営業マネージャー用と営業担当者用)を作成して階層的なアクセス制御を実現します。営業マネージャーのロールは営業担当者のロールよりも上位に設定し、営業マネージャーが営業担当者が所有する取引先のデータにアクセスできるようにします。",
            "これは不正解です。この設定ではロール階層が不足しているため、営業マネージャーが直属の営業担当者が所有する取引先データにアクセスすることができません。営業マネージャーと営業担当者間のデータの可視性を確保するためには、異なるロールを持つ階層的な関係が必要ですが、この設定ではそれが実現されていません。"
        ]
    },
    {
        "number": "149",
        "previous-code": [
            "List<Contact> performSearch(String lastName) {",
            "    return Database.query('Select Id, FirstName, LastName FROM Contact WHERE LastName Like%' + lastName +'%');",
            "}"
        ],
        "question": "開発者は、システムに存在する ContactSearchApexクラスのセキュリティレビューを実行するよう命じられました。このクラスの中で、開発者は以上のメソッドがセキュリティ上の脅威であることを特定しました。\nSOQL インジェクション攻撃を防ぐために、開発者がメソッドを改善できる方法は何ですか。2つ選びなさい。",
        "choices": ["クラスに@ReadOnlyアノテーションとwith sharingキーワードを使用する。", "escapeSingleQuotes メソッドを使用して、使用前にパラメータをサニタイズする。", "パラメータに正規表現式を使用して特殊文字を削除する。", "変数バインディングを使用し、動的クエリを静的SOQLに置き換える。"],
        "correct": ["escapeSingleQuotes メソッドを使用して、使用前にパラメータを消去する。", "変数バインディングを使用し、動的クエリを静的SOQLに置き換える。"],
        "explanations":["クラスに@ReadOnlyアノテーションとwith sharingキーワードを使用する。", "escapeSingleQuotes メソッドを使用して、使用前にパラメータをサニタイズする。", "パラメータに正規表現式を使用して特殊文字を削除する。", "変数バインディングを使用し、動的クエリを静的SOQLに置き換える。"],
        "descriptions":[
            "これは不正解です。 @ReadOnly アノテーションはトランザクションが読み取り専用であることを指示し、リソースの制限を緩和するために使用されますが、SOQLインジェクション攻撃を防ぐものではありません。with sharing キーワードはレコードの可視性に基づいて実行を制御するもので、セキュリティを強化する可能性はありますが、SOQLインジェクションそのものを防ぐものではないため、ここでは不適切です。",
            "これは正解です。escapeSingleQuotes() メソッドは、文字列内のシングルクォートをエスケープしてSOQLインジェクション攻撃を防ぐために使用されます。このメソッドを使用することで、攻撃者が有害なSOQLを注入するリスクを軽減できます。",
            "これは不正解です。 正規表現を使用して特殊文字を削除することは一種のサニタイズと見なすことができますが、攻撃者がSOQLインジェクションを実行するために使う可能性のある特定の文字列パターンを除去するためには、非常に複雑で確実な正規表現が必要になります。これは一般的な解決策として推奨されず、エスケープ処理に比べて安全ではありません。",
            "これは正解です。変数バインディングを使用して静的なSOQLクエリに変換することで、SOQLインジェクションのリスクを取り除くことができます。これにより、Apexが提供するクエリの文字列を適切に処理し、ユーザーが提供した値を安全に使うことができるようになります。"
        ]
    },
    {
        "number": "150",
        "question": "Apex テストクラスで @testSetup アノテーションを使用することについて、正しい記述はどれですか。3つ選びなさい。",
        "choices": ["isTest(SeeAllData=True) アノテーションが使用されている場合、@testSetup アノテーションは使用できません。", "テストデータは、クラス内のすべてのテストメソッドに対して 1 回挿入されます。", "testSetup メソッドで作成されたレコードを、個々のテストメソッドで更新することはできません。", "テストクラスの各テストメソッドが実行される前に、@testSetup メソッドが自動的に実行されます。"],
        "correct": ["isTest(SeeAllData=True) アノテーションが使用されている場合、@testSetup アノテーションは使用できません。", "テストデータは、クラス内のすべてのテストメソッドに対して 1 回挿入されます。", "テストクラスの各テストメソッドが実行される前に、@testSetup メソッドが自動的に実行されます。"],
        "explanations":["isTest(SeeAllData=True) アノテーションが使用されている場合、@testSetup アノテーションは使用できません。", "テストデータは、クラス内のすべてのテストメソッドに対して 1 回挿入されます。", "testSetup メソッドで作成されたレコードを、個々のテストメソッドで更新することはできません。", "テストクラスの各テストメソッドが実行される前に、@testSetup メソッドが自動的に実行されます。"],
        "descriptions":[
            "これは正解です。isTest(SeeAllData=True) を使用すると、実際の組織データにアクセスすることになりますが、@testSetup はテスト実行の際に独自のテストデータを設定するために使用されるため、両者は同時には使用できません。",
            "これは正解です。@testSetup で定義されたメソッドは、テストクラス内の各テストメソッドが実行される前に一度だけ実行され、生成されたテストデータは各テストメソッドで使用されます。",
            "これは不正解です。@testSetup メソッドで作成されたレコードは、各テストメソッド内で更新することができます。ただし、各テストメソッドは独立しているため、あるテストメソッドでの変更は他のテストメソッドには影響しません。",
            "これは正解です。これは@testSetup アノテーションの基本的な動作であり、このメソッドは各テストメソッドが実行される前に自動的に一度だけ実行されます。これにより、すべてのテストメソッドに対して共通のテストデータを準備することができます。"
        ]
    },
    {
        "number": "151",
        "question": "以下のブロックコードがあるとします。SOQLクエリの後、retrieveRecordsリストが空の場合、コードの実行が中断されるようにするために、開発者は何をする必要がありますか。",
        "following-code": [
            "try {",
            "  List <Accounts> retrieveRecords = [SELECT Id FROM Account WHERE Website = null];",
            "} catch(Exception e){",
            "  //例外ロジック",
            "}"
        ],
        "choices": ["retrieveRecords変数の状態をチェックし、変数が空の場合はカスタム例外をスローする。", "retrieveRecords変数の状態をチェックし、変数が空の場合はSystem.assert(false)を使用する。", "retrieveRecords変数の状態をチェックし、変数が空の場合はリストの最初の要素にアクセスする。", "retrieveRecords変数の宣言を、リストのAccountから単一のAccountに置き換える。"],
        "correct": ["retrieveRecords変数の状態をチェックし、変数が空の場合はSystem.assert(false)を使用する。"],
        "explanations":["retrieveRecords変数の状態をチェックし、変数が空の場合はカスタム例外をスローする。", "retrieveRecords変数の状態をチェックし、変数が空の場合はSystem.assert(false)を使用する。", "retrieveRecords変数の状態をチェックし、変数が空の場合はリストの最初の要素にアクセスする。", "retrieveRecords変数の宣言を、リストのAccountから単一のAccountに置き換える。"],
        "descriptions":[
            "これは不正解です。カスタム例外をスローすると、catch(Exception e)ブロックでキャッチされ、コードの実行が中断されません。しかし、通常の開発プラクティスでは、このような方法で例外を適切にハンドルし、エラー情報を明確にするためにカスタム例外を使用することが推奨されます。",
            "これは正解です。System.assert(false)は、条件がfalseの場合にエラーをスローし、コードの実行を中断します。ただし、通常の開発ではアサーションはテストクラス内でのみ使用され、途中で処理を中断する目的で使われることはありません。",
            "これは不正解です。リストが空の場合、最初の要素にアクセスしようとするとNullPointerExceptionがスローされますが、catch(Exception e)ブロックでキャッチされ、コードの実行は中断されません。通常の開発プラクティスでは、リストにアクセスする前にそのリストが空でないことを確認することが推奨されます。",
            "これは不正解です。変数の宣言を単一のAccountに変更しても、コードの実行が中断されるわけではありません。通常の開発プラクティスでは、変数の目的や使用方法に応じて適切なデータ型を選択し、変数を宣言することが重要です。リストを期待している場面で単一のオブジェクトを使用すると、予期しないエラーや問題が発生する可能性があります。"
        ]
    },
    {
        "number": "152",
        "previous-code": [
            "List<Contact> theContacts = new List<Contact>();\n",
            "for (Account a : Trigger.new) {",
            "    for (Contact c : [SELECT Id, Account_Date__c FROM Contact WHERE AccountId = :a.Id]) {",
            "        c.Account_Date__c = Date.today();",
            "        theContacts.add(c);",
            "    }",
            "}",
            "update theContacts;"
        ],
        "question": "開発者は、取引先オブジェクトの’after update’トリガーを使用して、取引先に関連するすべての取引先責任者を更新します。以上に示すトリガーコードは、ランダムに失敗します。\nこのコードブロックが失敗する原因は次のうちどれですか。",
        "choices": ["theContactsが空の場合は例外がスローされます。", "Account_Date__cがnullの場合、例外がスローされます。", "トリガーは、forループで200 以上のレコードを処理します。", "SOQLクエリがforループ内にあります。"],
        "correct": ["SOQLクエリがforループ内にあります。"],
        "explanations":["theContactsが空の場合は例外がスローされます。", "Account_Date__cがnullの場合、例外がスローされます。", "トリガーは、forループで200 以上のレコードを処理します。", "SOQLクエリがforループ内にあります。"],
        "descriptions":[
            "これは不正解です。theContactsリストが空の場合でも、updateステートメントを使用してそのリストを更新しようとしても、例外はスローされません。更新するレコードがない場合、単に何も実行されないだけです。",
            "これは不正解です。Account_Date__cがnullであっても、Date.today()メソッドで現在の日付を代入しているため、null値による例外は発生しません。この代入は問題なく機能します。",
            "これは不正解です。問題の主な原因は「forループ内でのSOQLクエリの発行」にあります。もしTrigger.newが200のレコードを持っている場合、このコードは200回のSOQLクエリを発行することになり、これがガバナ制限の「発行される SOQL クエリの合計数」の制限を超える可能性があります。ただし、単純にforループで200以上のレコードを処理すること自体は問題ではありません。",
            "これは正解です。forループ内でSOQLクエリを実行すると、多数の取引先レコードが更新される場合にSOQLクエリのガバナ制限に達するリスクが高まります。このような設計は、ガバナ制限を超える可能性があるため、ランダムに失敗する原因となります。通常の開発プラクティスでは、ループ内でのSOQLクエリの発行は避けることが推奨されます。"
        ]
    },
    {
        "number": "153",
        "question": "ある開発者がVisualforceページと、ページ上で発生するさまざまなボタンやイベントを処理するメソッドを持つカスタムコントローラを作成しました。本番環境にデプロイするために、開発者は何をすべきですか。",
        "choices": ["Visualforceページをカバーするテストクラスを作成する", "Visualforceページをカバーするテストページを作成する", "カスタムコントローラをカバーするテストページを作成する", "カスタムコントローラをカバーするテストクラスを作成する"],
        "correct": ["カスタムコントローラをカバーするテストクラスを作成する"],
        "explanations":["Visualforceページをカバーするテストクラスを作成する", "Visualforceページをカバーするテストページを作成する", "カスタムコントローラをカバーするテストページを作成する", "カスタムコントローラをカバーするテストクラスを作成する"],
        "descriptions":[
            "これは不正解です。Visualforceページ自体をカバーするテストクラスを作成することはできません。テストクラスは、Apexコードのロジックをテストするためのものであり、Visualforceページのマークアップやレイアウトをテストするためのものではありません。",
            "これは不正解です。テストページという概念はSalesforce開発には存在しないため、Visualforceページをカバーするテストページを作成することはできません。",
            "これは不正解です。同様に、テストページという概念はSalesforce開発には存在しないため、カスタムコントローラをカバーするテストページを作成することはできません。",
            "これは正解です。Salesforceの本番環境にデプロイする前に、カスタムコントローラのロジックをテストするためのテストクラスを作成する必要があります。このテストクラスは、カスタムコントローラ内のメソッドやロジックが正しく動作することを確認するためのものであり、デプロイ時に必要なコードカバレッジを提供します。"
        ]
    },
    {
        "number": "154",
        "question": "開発者はオブジェクトのVisualforceを使用してボタンをオーバーライドしたいと考えています。\nどんな要件を満たしている必要がありますか。",
        "choices": ["コントローラまたは拡張機能にPageReferenceメソッドを設定する。", "オブジェクトにstandardController属性を設定する。", "action属性をコントローラのメソッドに設定する。", "オブジェクトレコードは、コントローラまたは拡張機能でインスタンス化する必要があります。"],
        "correct": ["オブジェクトにstandardController属性を設定する。"],
        "explanations":["コントローラまたは拡張機能にPageReferenceメソッドを設定する。", "オブジェクトにstandardController属性を設定する。", "action属性をコントローラのメソッドに設定する。", "オブジェクトレコードは、コントローラまたは拡張機能でインスタンス化する必要があります。"],
        "descriptions":[
            "これは不正解です。ボタンをオーバーライドするためには、PageReferenceメソッドの設定は必須ではありません。PageReferenceは、ページのリダイレクトやURLの取得・設定、クエリ文字列パラメータの取得・設定など、ページの参照やナビゲーションに関連する操作を行うためのクラスです。",
            "これは正解です。ボタンをオーバーライドするためのVisualforceページを作成する際、関連するオブジェクトの標準コントローラを指定するために、standardController属性を使用します。この属性により、ページは特定のオブジェクトのデータと動作にアクセスできるようになります。",
            "これは不正解です。action属性は、Visualforceページが読み込まれる際や、特定のVisualforceコンポーネントがクリックされたときに実行されるコントローラのメソッドを指定するためのものです。ただし、この属性だけでボタンをオーバーライドするわけではありません。",
            "これは不正解です。ボタンをオーバーライドする際、その背後にあるロジックを実行するためのコントローラや拡張機能が必要となることがあります。しかし、オーバーライドの動作自体がオブジェクトレコードのインスタンス化を必要とするわけではありません。オブジェクトレコードのインスタンス化は、特定のデータ操作やビジネスロジックの実行時に必要となる場合がありますが、それはボタンのオーバーライドとは直接関連していません。"
        ]
    },
    {
        "number": "155",
        "question": "すべての値が一意であることを保証するために使用されるApexコレクションはどれですか。",
        "choices": ["List", "Enum", "Set", "sObject"],
        "correct": ["Set"],
        "explanations":["List", "Enum", "Set", "sObject"],
        "descriptions":[
            "これは不正解です。ListはApexの順序付きコレクションで、重複した値を持つことができます。",
            "これは不正解です。Enumは列挙型を定義するためのもので、コレクションとは異なります。",
            "これは正解です。SetはApexのコレクションで、すべての要素が一意であることを保証します。重複した値を追加しようとすると、それは無視されます。",
            "これは不正解です。sObjectはSalesforceのオブジェクトデータを表すもので、コレクションとは異なります。"
        ]
    },
    {
        "number": "156",
        "question": "MVCパラダイムの観点から、VisualforceよりもLightning Webコンポーネントベースの開発を使用してSalesforceアプリケーションのビューレイヤーを実装することの利点は何ですか。2つ選びなさい。",
        "choices": ["アプリケーションが自己完結型で再利用可能である", "豊富なコンポーネントエコシステム", "サーバー側のランタイムデバッグ", "自動コード生成"],
        "correct": ["アプリケーションが自己完結型で再利用可能である", "豊富なコンポーネントエコシステム"],
        "explanations":["アプリケーションが自己完結型で再利用可能である", "豊富なコンポーネントエコシステム", "サーバー側のランタイムデバッグ", "自動コード生成"],
        "descriptions":[
            "これは正解です。Lightning Webコンポーネントは再利用可能なコンポーネントを作成することを強化しており、これにより開発者は一度作成したコンポーネントを異なる場面やアプリケーションで再利用することができます。これはMVCの観点からビューレイヤーの再利用性を高める利点となります。",
            "これは正解です。Lightning WebコンポーネントはSalesforce Lightningプラットフォーム上でのモダンなコンポーネントベースの開発をサポートしており、豊富なコンポーネントエコシステムを持っています。これにより、開発者は既存のコンポーネントを利用して迅速にアプリケーションを構築することができます。",
            "これは不正解です。サーバー側のランタイムデバッグは、ビューレイヤーの実装に関連する特定の利点ではありません。また、MVCパラダイムの観点からの利点とは言えません。",
            "これは不正解です。自動コード生成は、特定の開発ツールやフレームワークに関連する機能であり、MVCパラダイムの観点からのビューレイヤーの実装に関する直接的な利点とは言えません。"
        ]
    },
    {
        "number": "157",
        "question": "ある開発者が、メールアドレス’dev@uc.com’を持つ取引先責任者とユーザーを取得したいと考えています。開発者が使用すべきSOSL文はどれですか。",
        "choices": ["FIND {dev@uc.com} IN Email Fields RETURNING Contact (Email), User (Email)", "FIND {Email = ‘dev@uc.com’} RETURNING Contact (Email), User (Email)", "FIND {Email = ‘dev@uc.com’} IN Contact, User", "FIND Email IN Contact, User FOR {dev2uc.com}"],
        "correct": ["FIND {dev@uc.com} IN Email Fields RETURNING Contact (Email), User (Email)"],
        "explanations":["FIND {dev@uc.com} IN Email Fields RETURNING Contact (Email), User (Email)", "FIND {Email = ‘dev@uc.com’} RETURNING Contact (Email), User (Email)", "FIND {Email = ‘dev@uc.com’} IN Contact, User", "FIND Email IN Contact, User FOR {dev2uc.com}"],
        "descriptions":[
            "これは正解です。このSOSL文は、Emailフィールド内で’dev@uc.com’を検索し、該当する取引先責任者(Contact)とユーザー(User)のEmailフィールドの値を返します。この文は正しく、要件を満たしています。",
            "これは不正解です。 このクエリは「IN [フィールド名]」の部分を欠いています。SOSLでは、どのフィールドを検索対象とするかを明示する必要があります。FIND {dev@uc.com} IN Email Fields RETURNING Contact (Email), User (Email) のように「IN Email Fields」を追加することで、メールフィールド内での検索を指定します。",
            "これは不正解です。 このクエリは「IN [フィールド名]」の形式が間違っています。また、検索値が正しく指定されていません。FIND {dev@uc.com} IN Email Fields RETURNING Contact, User のように、正しい「IN [フィールド名]」の形式を使用し、検索値を適切に指定する必要があります。",
            "これは不正解です。 このクエリは全体的に文法が間違っており、SOSLの構文に従っていません。また、検索値が誤っています。FIND {dev@uc.com} IN Email Fields RETURNING Contact (Email), User (Email) のように、正しいSOSL構文を使用し、正しい検索値を指定する必要があります。"
        ]
    },
    {
        "number": "158",
        "question": "ユーザーが取引先の「Postal Code」を更新する際、取引先のカスタムテキスト項目「Timezone」は、カスタムオブジェクト「PostalCodeToTimezone__c」の情報を基に自動的に更新される必要があります。この機能を実装するため、開発者はどの手法を採用すべきでしょうか",
        "choices": ["取引先オブジェクトのワークフロールールを作成する。", "取引先オブジェクトの割り当てルールを作成する。", "取引先オブジェクトのカスタムトリガーを作成する。", "取引先オブジェクトの承認プロセスを作成する。"],
        "correct": ["取引先オブジェクトのカスタムトリガーを作成する。"],
        "explanations":["取引先オブジェクトのワークフロールールを作成する。", "取引先オブジェクトの割り当てルールを作成する。", "取引先オブジェクトのカスタムトリガーを作成する。", "取引先オブジェクトの承認プロセスを作成する。"],
        "descriptions":[
            "これは不正解です。ワークフロールールは、レコードが特定の条件を満たすときにアクションを自動化するために使用されますが、複雑なロジックや他のオブジェクトからデータを取得して項目を更新する機能はありません。したがって、PostalCodeToTimezone__cからデータを基に取引先のTimezone項目を更新するためには適していません。",
            "これは不正解です。割り当てルールはレコードの所有者を自動的に設定するためのものです。リードやケースに使用され、項目の自動更新や他のオブジェクトのデータを参照する機能はありません。このケースでは、割り当てルールは要件を満たしません。",
            "これは正解です。 Apexトリガーを使用することで、取引先のPostal Codeが更新された際に、カスタムオブジェクトPostalCodeToTimezone__cの情報を基にTimezone項目を自動的に更新することができます。トリガーは複雑なビジネスロジックを実装するための柔軟性を提供し、このような要件を満たすためのベストプラクティスです。",
            "これは不正解です。承認プロセスは、レコードが特定の基準を満たすときに承認を求めるためのフローを定義するために使用されます。項目の自動更新や他のオブジェクトからのデータ取得には適していません。"
        ]
    },
    {
        "number": "159",
        "question": "カスタムVisualforceコントローラとして使用するクラスの要件は何ですか。",
        "choices": ["PageReferenceを返すコンストラクタを持つ最上位のApexクラス", "PageReferenceを拡張する最上位のApexクラス", "デフォルトの引数なしコンストラクタを持つ最上位のApexクラス", "コントローラインターフェースを実装した最上位のApexクラス"],
        "correct": ["デフォルトの引数なしコンストラクタを持つ最上位のApexクラス"],
        "explanations":["PageReferenceを返すコンストラクタを持つ最上位のApexクラス", "PageReferenceを拡張する最上位のApexクラス", "デフォルトの引数なしコンストラクタを持つ最上位のApexクラス", "コントローラインターフェースを実装した最上位のApexクラス"],
        "descriptions":[
            "これは不正解です。Visualforceコントローラの主要な要件は、PageReferenceを返すコンストラクタを持つことではありません。コントローラは、VisualforceページとApexコードの間のロジックを処理するためのものであり、特定の型のコンストラクタを持つ必要はありません。",
            "これは不正解です。一般的に、PageReferenceを直接拡張することはカスタムVisualforceコントローラの作成には不適切です。PageReferenceはVisualforceページや外部URLへのリダイレクトを表すクラスであり、コントローラの主要なロジックを実装するためのものではありません。",
            "これは正解です。カスタムVisualforceコントローラとして使用するApexクラスは、デフォルトの引数なしのコンストラクタを持つ必要があります。このコンストラクタは、Visualforceページがロードされるときに自動的に呼び出されます。",
            "これは不正解です。Visualforceコントローラとして使用するApexクラスが特定のインターフェースを実装する必要はありません。ただし、特定の機能を持つコントローラを作成する場合、インターフェースの実装が役立つ場合がありますが、これは必須の要件ではありません。"
        ]
    },
    {
        "number": "160",
        "question": "ある企業は、顧客に教育ビデオを視聴してもらうための推進計画を実施しました。顧客は数日間にわたりビデオを視聴することができ、その進捗は記録されます。動画をすべて視聴完了すると、顧客に報奨ポイントが付与されます。動画がSalesforceで完了としてマークされた際、外部のWebサービスを呼び出して、ユーザーにポイントを付与する必要があります。\n開発者は、この要件をSalesforceのafter updateトリガー内で外部Webサービスへの呼び出しとして実装しました。しかし、実装後にSystem.CalloutExceptionが発生しています。このエラーを解消するために、開発者はどのような対応をすべきでしょうか。",
        "choices": ["after update トリガーを before insert トリガーに置き換える。", "外部 Web サービスと統合する REST サービスを作成する。", "外部呼び出しを try-catch ブロックで囲み、例外を処理する。", "@future(callout=true)を使用して、コールアウトを非同期メソッドに移動する。"],
        "correct": ["@future(callout=true)を使用して、コールアウトを非同期メソッドに移動する。"],
        "explanations":["after update トリガーを before insert トリガーに置き換える。", "外部 Web サービスと統合する REST サービスを作成する。", "外部呼び出しを try-catch ブロックで囲み、例外を処理する。", "@future(callout=true)を使用して、コールアウトを非同期メソッドに移動する。"],
        "descriptions":[
            "これは不正解です。このエラーはトリガーのタイミング(after update または before insert)に関連しているわけではありません。また、動画が完了としてマークされるときにポイントを付与するため、before insert トリガーはこのシナリオには適していません。",
            "これは不正解です。このエラーは、REST サービスの存在やその作成方法に関連しているわけではありません。エラーの原因はトリガー内での同期的なコールアウトに関連しています。",
            "これは不正解です。例外をキャッチすることは良い実践ですが、それだけではSystem.CalloutExceptionの根本的な原因を解決しません。トリガー内での同期的なコールアウトが許可されていないため、このエラーが発生します。",
            "これは正解です。Salesforceでは、トリガー内での同期的なコールアウトは許可されていません。そのため、非同期メソッドを使用してコールアウトを行う必要があります。@future(callout=true) アノテーションを使用することで、非同期的に外部サービスを呼び出すことができます。"
        ]
    },
    {
        "number": "161",
        "question": "セールスフォースには、Developer Sandbox、Developer Pro Sandbox、Partial Copy Sandbox、Full Sandboxの4つのサンドボックスタイプが存在します。その中で、Partial Copy SandboxとFull Sandboxの特徴は何ですか。2つ選びなさい。",
        "choices": ["メタデータの一部分のみを含みます", "サンドボックスのテンプレートが利用できます", "より頻繁な更新をサポートします", "より多くのデータレコードを保存できます"],
        "correct": ["サンドボックスのテンプレートが利用できます", "より多くのデータレコードを保存できます"],
        "explanations":["メタデータの一部分のみを含みます", "サンドボックスのテンプレートが利用できます", "より頻繁な更新をサポートします", "より多くのデータレコードを保存できます"],
        "descriptions":[
            "これは不正解です。すべてのサンドボックスタイプでメタデータはサポートされています。Partial Copy Sandboxはメタデータとサンプルデータを含み、Full Sandboxはメタデータとすべてのデータを含みます。",
            "これは正解です。Partial Copy Sandboxではサンドボックスのテンプレートが必須であり、Full Sandboxでもテンプレートを利用することができます。一方、Developer SandboxやDeveloper Pro Sandboxではテンプレートの利用はできません。",
            "これは不正解です。Partial Copy Sandboxは5日ごと、Full Sandboxは29日ごとに更新が可能です。一方、Developer SandboxやDeveloper Pro Sandboxは1日ごとに更新が可能です。より頻繁な更新をサポートしているのはDeveloper SandboxやDeveloper Pro Sandboxです。",
            "これは正解です。Full Sandboxは本番組織と同じストレージ制限を持ち、最も多くのデータレコードを保存する能力があります。Partial Copy Sandboxは5GBのデータストレージを提供します。これは、Developer SandboxやDeveloper Pro Sandboxと比べて、より多くのデータレコードを保存できることを意味します。"
        ]
    },
    {
        "number": "162",
        "question": "Before InsertトリガーのTrigger.oldコンテキスト変数の値は何ですか。",
        "choices": ["sObjectの空のリスト", "null", "Idなしで新しく作成されたsObjectのリスト", "Undefined"],
        "correct": ["null"],
        "explanations":["sObjectの空のリスト", "null", "Idなしで新しく作成されたsObjectのリスト", "Undefined"],
        "descriptions":[
            "これは不正解です。Trigger.oldは、Before Insertトリガーのコンテキストで使用される場合、利用できません。その理由は、Trigger.oldが元のレコードのリストを参照するものであるのに対し、Before Insertの際には新しいレコードがまだデータベースに挿入されていないため、”古い” バージョンのレコードが存在しないからです。",
            "これは正解です。Before Insertトリガーのコンテキストでは、Trigger.oldはnullとして返されます。これは、新しく挿入されるレコードはまだ保存されていないため、”古い” バージョンのレコードが存在しないからです。",
            "これは不正解です。この説明はTrigger.newのコンテキスト変数に関するもので、新しく挿入されるレコードのリストを参照します。Before Insertのコンテキストでは、これらのレコードはまだ保存されていないため、Idはまだ割り当てられていません。",
            "これは不正解です。Trigger.old は Before Insert トリガーのコンテキストではnullとなります。”Undefined” という状態はSalesforceのApex言語には存在しません。"
        ]
    },
    {
        "number": "163",
        "question": "Visualforce ページで標準アクションをオーバーライドするには、<apex:page>タグでどの属性を定義する必要がありますか。",
        "choices": ["pageReference", "override", "controller", "standardController"],
        "correct": ["standardController"],
        "explanations":["pageReference", "override", "controller", "standardController"],
        "descriptions":[
            "これは不正解です。pageReference は <apex:page>タグの属性として存在しません。",
            "これは不正解です。override は <apex:page>タグの属性として存在しません。",
            "これは不正解です。controller 属性は、カスタムApexコントローラを指定するために使用されます。標準アクションをオーバーライドするためには、この属性を使用するのではなく、標準コントローラを使用する必要があります。",
            "これは正解です。standardController 属性は、Visualforce ページが標準オブジェクトのレコードにアクセスするための標準コントローラを使用することを指定します。この属性を使用することで、標準アクションをオーバーライドすることができます。"
        ]
    },
    {
        "number": "164",
        "question": "本番環境にデプロイする際に必要なプロセスはどれですか。2つ選びなさい。",
        "choices": ["すべてのトリガーのテストカバレッジは75%以上である必要があります。", "すべてのトリガーのテストカバレッジは少なくとも1%以上である必要があります。", "すべてのApexコードのテストカバレッジは、少なくとも75%以上である必要があります。", "すべてのテストとトリガーのテストカバレッジを合わせて75%以上である必要があります。"],
        "correct": ["すべてのトリガーのテストカバレッジは少なくとも1%以上である必要があります。", "すべてのApexコードのテストカバレッジは、少なくとも75%以上である必要があります。"],
        "explanations":["すべてのトリガーのテストカバレッジは75%以上である必要があります。", "すべてのトリガーのテストカバレッジは少なくとも1%以上である必要があります。", "すべてのApexコードのテストカバレッジは、少なくとも75%以上である必要があります。", "すべてのテストとトリガーのテストカバレッジを合わせて75%以上である必要があります。"],
        "descriptions":[
            "これは不正解です。各Apexトリガーには最低1%のテストカバレッジが必要ですが、75%以上のカバレッジが各トリガーに必要というわけではありません。",
            "これは正解です。Apexトリガーについては、最低でも1%のカバレッジがないと、どんな場合でもデプロイに失敗します。",
            "これは正解です。運用環境にデプロイするためには、全てのApexコード(クラスやトリガーを含む)のテストカバレッジの合計が75%以上である必要があります。例えば、4つのApexクラスがあり、3つのクラスがそれぞれ100%のカバレッジを持ち、残りの1つのクラスがカバレッジ0%であっても、全体のカバレッジが75%となり、75%の要件を満たしているためデプロイはできます。",
            "これは不正解です。この選択肢は誤解を招く表現です。「すべてのテスト」と「トリガー」合わせて75%以上ではなく、「クラス」と「トリガー」を含むすべてのApexコードのテストの合計テストカバレッジが75%以上でなければなりません。"
        ]
    },
    {
        "number": "165",
        "question": "本番環境にデプロイする際に必要なプロセスはどれですか。2つ選びなさい。",
        "choices": ["すべてのプロセスビルダーのテストカバレッジは、少なくとも1%以上である必要があります。", "すべてのApexコードのテストカバレッジが75%以上である必要があります。", "すべてのトリガーのテストカバレッジは、少なくとも1%以上である必要があります。", "すべてのフローのテストカバレッジは、少なくとも1%以上である必要があります。"],
        "correct": ["すべてのApexコードのテストカバレッジが75%以上である必要があります。", "すべてのトリガーのテストカバレッジは、少なくとも1%以上である必要があります。"],
        "explanations":["すべてのプロセスビルダーのテストカバレッジは、少なくとも1%以上である必要があります。", "すべてのApexコードのテストカバレッジが75%以上である必要があります。", "すべてのトリガーのテストカバレッジは、少なくとも1%以上である必要があります。", "すべてのフローのテストカバレッジは、少なくとも1%以上である必要があります。"],
        "descriptions":[
            "これは不正解です。Salesforceのプロセスビルダーにはテストカバレッジの要件はありません。",
            "これは正解です。SalesforceでのApexコードの本番環境へのデプロイには、全体のテストカバレッジが75%以上であることが必要です。このカバレッジは、Apexクラスやトリガーを含む全てのApexコードのテスト結果を合計して評価されます。例えば、複数のApexクラスやトリガーが存在しても、それらのテスト結果の合計が75%以上であれば、デプロイの要件を満たします。",
            "これは正解です。各Apexトリガーには、最低でも1%のテストカバレッジが必要です。この要件は、トリガーごとに評価されます。たとえ全体のカバレッジが75%以上でも、1つのトリガーのカバレッジが1%未満の場合、そのトリガーの存在によりデプロイは許可されません。",
            "これは不正解です。Salesforceのフローにはテストカバレッジの要件は設定されていません。"
        ]
    },
    {
        "number": "166",
        "previous-code": [
            "trigger test on Lead (before update) {",
            "    List<Lead> leadsToUpdate = new List<Lead>();\n",
            "    for(Lead leadRecord : trigger.new){",
            "        if(leadRecord.Email != trigger.oldMap.get(leadRecord.Id).Email){",
            "            leadRecord.Prior_Email__c = trigger.oldMap.get(leadRecord.Id).Email;",
            "            leadsToUpdate.add(leadRecord);",
            "        }",
            "    }\n",
            "    if(leadsToUpdate.size() > 0) {",
            "        update leadsToUpdate;",
            "    }",
            "}"
        ],
        "question": "リードオブジェクトには、カスタム項目の優先メール(Prior_Email__c)があります。以上のトリガーは、メール項目(Email)が変更されるたびに、現在のメール(Email)を優先メール項目(Prior_Email__c)にコピーするものです。\nこのトリガーはどのタイプの組み込み例外を発生させますか。",
        "choices": ["NullPointerException", "CompileTimeException", "DmlException", "LimitException"],
        "correct": ["DmlException"],
        "explanations":["NullPointerException", "CompileTimeException", "DmlException", "LimitException"],
        "descriptions":[
            "これは不正解です。このトリガーでは、trigger.oldMap.get(leadRecord.Id).Emailを使用していますが、before updateトリガーのコンテキストでは、trigger.oldMapは更新前のレコードのマップを持っているため、この例外は発生しないと考えられます。",
            "これは不正解です。Apexの組み込み例外に「CompileTimeException」というものは存在しません。また、このトリガーのコードは正しくコンパイルされるため、コンパイル時の例外は発生しません。",
            "これは正解です。このトリガーは「before update」のタイミングで動作します。このタイミングでは、データベースに保存される前のレコードの状態を変更することができます。しかし、trigger.newのレコードに対して直接update操作を試みると、Salesforceはそれを許可しません。なぜなら、それは再帰的なトリガーの実行や無限ループを引き起こす可能性があるからです。このトリガーの中で、if(leadsToUpdate.size() > 0) { update leadsToUpdate; }という部分があります。ここでleadsToUpdateリストを更新しようとすると、このリストはtrigger.newの一部として扱われるため、DmlExceptionが発生します。簡単に言えば、before updateの中で既に更新中のレコードを再度更新しようとすると、エラーが発生するのです。",
            "これは不正解です。このトリガーでは、DML操作はif(leadsToUpdate.size() > 0)の条件の下で行われています。しかし、このトリガーのコード自体は、DML操作やSOQLクエリの制限を超えるような処理を行っていないため、LimitExceptionは発生しないと考えられます。"
        ]
    },
    {
        "number": "167",
        "question": "サポートされていない言語を使用できるプラットフォーム機能はどれですか。2つ選びなさい。",
        "choices": ["Heroku Acm", "Docker", "Buildpacks", "App.json"],
        "correct": ["Docker", "Buildpacks"],
        "explanations":["Heroku Acm", "Docker", "Buildpacks", "App.json"],
        "descriptions":[
            "これは不正解です。Heroku ACMは、HerokuアプリケーションのSSL/TLS証明書を自動的に管理する機能です。これは言語のサポートとは関係ありません。",
            "これは正解です。Dockerはコンテナ技術を使用してアプリケーションとその依存関係をパッケージ化するツールです。Dockerを使用すると、サポートされていない言語や特定のバージョンのランタイムも含め、任意の環境を構築して実行できます。",
            "これは正解です。BuildpacksはHerokuや他のクラウドプラットフォームで使用されるもので、アプリケーションのソースコードを実行可能なアプリケーションに変換するためのスクリプトのセットです。カスタムBuildpacksを使用することで、Herokuなどのプラットフォームでデフォルトでサポートされていない言語やフレームワークをサポートすることができます。",
            "これは不正解です。App.jsonはHerokuアプリケーションの設定を定義するためのマニフェストファイルです。これはアプリケーションのデプロイや設定に関連しており、言語のサポートとは直接関係ありません。"
        ]
    },
    {
        "number": "168",
        "question": "開発者は、テストメソッドのガバナ制限をどのように回避すべきでしょうか。",
        "choices": ["レコードを作成するメソッドで@TestVisibleを使用する。", "Test.loadData()を使用して、静的リソースからデータをロードする。", "既存のデータを使用するために、@IsTest(SeeAllData=true)を使用する。", "Test.startTest()を使用して、ガバナ制限をリセットする。"],
        "correct": ["Test.startTest()を使用して、ガバナ制限をリセットする。"],
        "explanations":["レコードを作成するメソッドで@TestVisibleを使用する。", "Test.loadData()を使用して、静的リソースからデータをロードする。", "既存のデータを使用するために、@IsTest(SeeAllData=true)を使用する。", "Test.startTest()を使用して、ガバナ制限をリセットする。"],
        "descriptions":[
            "これは不正解です。@TestVisibleアノテーションは、テストクラス内でのみアクセス可能なプライベートメンバーにアクセスするために使用されます。しかし、これはガバナ制限を回避するためのメカニズムではありません。",
            "これは不正解です。この選択肢は誤解を招く可能性があります。確かにTest.loadData()メソッドは、静的リソースからテストデータをロードし、DML操作に関連するデータベースのオーバーヘッドを軽減するのに役立ちます。これにより、テストメソッドの実行中のDMLステートメントやSOQLクエリの制限に対する影響を減らすことができ、テストのパフォーマンスが向上します。しかし、この方法はガバナ制限を完全に「回避」する手段ではなく、特にCPU時間などの他の種類のガバナ制限に対しては直接的な解決策にはなりません。",
            "これは不正解です。@IsTest(SeeAllData=true)は、テストクラスが本番環境のデータにアクセスすることを許可しますが、これは一般的には推奨されません。このアプローチはテストの信頼性を低下させ、意図しないデータ変更やガバナ制限の問題を引き起こす可能性があります。",
            "これは正解です。Test.startTest()とTest.stopTest()は、テストメソッド内でガバナ制限をリセットするために使用されます。これにより、テストメソッド内で行われる特定の操作のために新しいガバナ制限のコンテキストを提供し、これらの制限を適切に管理するのに役立ちます。"
        ]
    },
    {
        "number": "169",
        "question": "searchTermを指定してAccountsのリストを返すApexメソッドgetAccountsは、Lightning Webコンポーネントで使用できます。getAccountsメソッドを使用するLightning Webコンポーネントのプロパティの正しい定義は何ですか。",
        "choices": ["@wire(getAccounts, {searchTerm: ‘$searchTerm’})\naccountList;", "@wire(getAccounts, ‘$searchTerm’)\naccountList;", "@AuraEnabled(getAccounts, {searchTerm: ‘$searchTerm’})\naccountList;", "@AuraEnabled(getAccounts, ‘$searchTerm’)\naccountList;"],
        "correct": ["@wire(getAccounts, {searchTerm: ‘$searchTerm’})\naccountList;"],
        "explanations":["@wire(getAccounts, {searchTerm: ‘$searchTerm’})\naccountList;", "@wire(getAccounts, ‘$searchTerm’)\naccountList;", "@AuraEnabled(getAccounts, {searchTerm: ‘$searchTerm’})\naccountList;", "@AuraEnabled(getAccounts, ‘$searchTerm’)\naccountList;"],
        "descriptions":[
            "これは正解です。@wireアノテーションを使用して、getAccountsというApexメソッドからデータを取得しています。searchTermという名前のパラメータに動的にコンポーネントのsearchTermプロパティの値を渡しています。そして、取得したデータはaccoutListというプロパティに格納されます。",
            "これは不正解です。@wireアノテーションでパラメータを渡す際には、オブジェクト形式で指定する必要があります。",
            "これは不正解です。@AuraEnabledはApexクラスのメソッドをAuraコンポーネントやLWCで使用可能にするためのアノテーションです。しかし、LWC内でこのように直接使用することはできません。",
            "これは不正解です。@AuraEnabledアノテーションは、ApexメソッドをAuraコンポーネントやLWCで使用するためのものであり、LWC内でこのような形式で使用することはできません。"
        ]
    },
    {
        "number": "170",
        "question": "デバッグログに関する3つの記述のうち、正しいものはどれですか。3つ選びなさい。",
        "choices": ["デバッグログレベルは累積され、FINEログレベルにはDEBUG、INFO、WARN、ERRORレベルで記録されたすべてのイベントが含まれます。", "デバッグログの最大サイズは5MBです。", "最新の20件のデバッグログのみが保存されます。", "デバッグログは、特定のユーザー、クラス、およびトリガーに設定できます。", "システムデバッグログは24時間保存されます。"],
        "correct": ["デバッグログレベルは累積され、FINEログレベルにはDEBUG、INFO、WARN、ERRORレベルで記録されたすべてのイベントが含まれます。", "デバッグログは、特定のユーザー、クラス、およびトリガーに設定できます。", "システムデバッグログは24時間保存されます。"],
        "explanations":["デバッグログレベルは累積され、FINEログレベルにはDEBUG、INFO、WARN、ERRORレベルで記録されたすべてのイベントが含まれます。", "デバッグログの最大サイズは5MBです。", "最新の20件のデバッグログのみが保存されます。", "デバッグログは、特定のユーザー、クラス、およびトリガーに設定できます。", "システムデバッグログは24時間保存されます。"],
        "descriptions":[
            "これは正解です。デバッグログレベルは累積され、FINEレベルを選択すると、DEBUG、INFO、WARN、ERRORレベルでログ記録されたすべてのイベントが含まれます。",
            "これは不正解です。デバッグログの最大サイズは20MBです。",
            "これは不正解です。保存されるデバッグログのサイズと保存期間に制限はありますが、件数に制限は設定されていません。",
            "これは正解です。デバッグログは特定のユーザー、クラス、トリガーに対して設定できます。",
            "これは正解です。システムデバッグログは24時間保存され、監視デバッグログは7日間保持されます。"
        ]
    },
    {
        "number": "171",
        "question": "AccountListという名前のList<Account>コレクション内の各Accountを反復処理するための有効な選択肢はどれですか。2つ選びなさい。",
        "choices": ["for (Integer i=0; i < AccountList.Size(); i++) {…}", "for (Account theAccount : AccountList) {…}", "for (AccountList) {…}", "for (List L : AccountList) {…}"],
        "correct": ["for (Integer i=0; i < AccountList.Size(); i++) {…}", "for (Account theAccount : AccountList) {…}"],
        "explanations":["for (Integer i=0; i < AccountList.Size(); i++) {…}", "for (Account theAccount : AccountList) {…}", "for (AccountList) {…}", "for (List L : AccountList) {…}"],
        "descriptions":[
            "これは正解です。これは従来のforループのバリエーションに該当します。このループは、初期化ステートメント、終了条件、および増分ステートメントを使用して、指定された回数だけコードブロックを実行します。",
            "これは正解です。これはリストやセットの反復処理を行うforループのバリエーションに該当します。このループは、リストやセットの各要素を反復処理します。変数は、リストやセットの各要素のデータ型と一致する必要があります。",
            "これは不正解です。この構文は正しくありません。反復処理するための変数や条件が指定されていません。",
            "これは不正解です。AccountListはList型で、その中の要素は取引先オブジェクトです。したがって、List Lという型の変数でAccountListを反復処理することは構文的に正しくありません。"
        ]
    },
    {
        "number": "172",
        "question": "次のコードの実行時間を短縮するために、開発者が取るべき行動はどれですか。",
        "following-code": [
            "List<Account> allAccounts = [SELECT Id FROM Account];",
            "List<Contact> allContacts = [SELECT Id, AccountId FROM Contact];\n",
            "for (Account a : allAccounts) {",
            "    for (Contact c : allContacts) {",
            "        if (c.AccountId == a.Id) {",
            "            // do work",
            "        }",
            "    }",
            "}"
        ],
        "choices": ["取引先責任者のSOQLにGROUP BYオプションを追加する", "allaccountsに対してMap<Id,Account>を使用する", "SOQL用のApexヘルパークラスを作成する", "Contactループの中にAccountループを入れる"],
        "correct": ["allaccountsに対してMap<Id,Account>を使用する"],
        "explanations":["取引先責任者のSOQLにGROUP BYオプションを追加する", "allaccountsに対してMap<Id,Account>を使用する", "SOQL用のApexヘルパークラスを作成する", "Contactループの中にAccountループを入れる"],
        "descriptions":[
            "これは不正解です。このコードの問題は、ネストされたループの中での比較にあります。GROUP BYオプションを追加することは、この問題を解決するものではありません。",
            "これは正解です。Map<Id, Account>を使用することで、各ContactのAccountIdをキーとして関連するAccountを効率的に検索できます。これにより、ネストされたループを使用する必要がなくなり、実行時間が大幅に短縮されます。",
            "これは不正解です。ヘルパークラスの作成は、コードの整理や再利用を容易にするためのものであり、実行時間の短縮には直接的には寄与しません。",
            "これは不正解です。ループの順序を変更するだけでは、実行時間の問題は解決されません。ネストされたループの問題は、ループの順序に関係なく発生します。"
        ]
    },
    {
        "number": "173",
        "question": "開発者は、AccountレコードまたはContactレコードを処理できるApexメソッドが必要です。開発者はどのメソッドを使用する必要がありますか。",
        "choices": ["Public void doWork(Account || Contact)", "Public void doWork(Record theRecord)", "Public void doWork(sObject theRecord)", "Public void doWork(Account Contact)"],
        "correct": ["Public void doWork(sObject theRecord)"],
        "explanations":["Public void doWork(Account || Contact)", "Public void doWork(Record theRecord)", "Public void doWork(sObject theRecord)", "Public void doWork(Account Contact)"],
        "descriptions":[
            "これは不正解です。Apexのメソッドのパラメータとして、||を使用して複数のデータ型を指定することはできません。この構文はApexでは無効です。",
            "これは不正解です。ApexにはRecordというデータ型は存在しません。",
            "これは正解です。sObjectはSalesforceのすべてのオブジェクト(標準オブジェクト、カスタムオブジェクト)の基本データ型です。このメソッドは、AccountやContactなどの任意のsObject型のレコードを引数として受け取ることができます。",
            "これは不正解です。この構文はApexでは無効です。メソッドのパラメータとして複数のデータ型を同時に指定することはできません。"
        ]
    },
    {
        "number": "174",
        "question": "開発者は、複数のLightningウェブコンポーネントを含む天気アプリを作成しました。コンポーネントの１つはToggleと呼ばれ、華氏または摂氏の単位を切り替えます。Toggleコンポーネントでユーザーが華氏から摂氏、またはその逆に切り替えると、その情報はTemperatureコンポーネントに送信され、温度が変換されて表示されます。これを実現するには、どのような方法が推奨されますか。",
        "choices": ["コンポーネント間の通信を処理するカスタムイベントを作成する。", "ToggleコンポーネントでTemperatureコンポーネントのメソッドを呼び出す。", "コンポーネント間の通信にアプリケーションイベントを使用する。", "コンポーネント間の通信にはLightning Message Serviceを使用する。"],
        "correct": ["コンポーネント間の通信を処理するカスタムイベントを作成する。"],
        "explanations":["コンポーネント間の通信を処理するカスタムイベントを作成する。", "ToggleコンポーネントでTemperatureコンポーネントのメソッドを呼び出す。", "コンポーネント間の通信にアプリケーションイベントを使用する。", "コンポーネント間の通信にはLightning Message Serviceを使用する。"],
        "descriptions":[
            "これは正解です。カスタムイベントは、Lightning Web Components (LWC) 内のコンポーネント間の通信に特に適しています。特に、親子関係や同じ階層にあるコンポーネント間でのデータの受け渡しに非常に効果的です。今回のシナリオでは、Toggle コンポーネントと Temperature コンポーネントという2つのLWCコンポーネント間での通信が必要なため、この方法が最も推奨されます。",
            "これは不正解です。LWCでは、他のコンポーネントのメソッドを直接呼び出すことは推奨されません。コンポーネント間の疎結合を保つため、イベントベースの通信が好ましいです。",
            "これは不正解です。アプリケーションイベントはAuraコンポーネントで使用され、LWCではサポートされていません。LWCでは、カスタムイベントやLightning Message Serviceが推奨されます。",
            "これは不正解です。Lightning Message Serviceは、LWC、Auraコンポーネント、Visualforceページ間での通信を可能にするサービスですが、同じLWC内のコンポーネント間の通信には、カスタムイベントがより適しています。このオプションは、異なる技術間での通信やページ全体にわたる広範な通信が必要な場合に特に役立ちますが、今回のシナリオでは不適切です。"
        ]
    },
    {
        "number": "175",
        "question": "開発者が組織内でテストを実行するための方法は何ですか。2つ選びなさい。",
        "choices": ["Tooling API", "開発者コンソール", "メタデータ API", "Bulk API"],
        "correct": ["Tooling API", "開発者コンソール"],
        "explanations":["Tooling API", "開発者コンソール", "メタデータ API", "Bulk API"],
        "descriptions":[
            "これは正解です。Tooling APIは、開発者がSalesforceのカスタマイズをプログラムで管理するためのAPIです。これには、Apexテストの実行などの開発タスクも含まれます。",
            "これは正解です。開発者コンソールは、Apexコードの記述、実行、デバッグ、およびテストを行うための統合開発環境(IDE)です。開発者はここでApexテストを実行することができます。",
            "これは不正解です。メタデータ APIは、組織のメタデータを操作するためのAPIです。これは主に組織のカスタマイズや設定をデプロイまたは取得するために使用されますが、テストの実行には使用されません。",
            "これは不正解です。Bulk APIは、大量のレコードをSalesforceにインポートまたはエクスポートするためのAPIです。これはテストの実行とは関係ありません。"
        ]
    },
    {
        "number": "176",
        "question": "ある開発者が2つのカスタムコントローラ拡張を持っており、それぞれにsave()メソッドがあります。次のVisualforceページでは、どのsave()メソッドが呼び出されますか。",
        "following-code": [
            "<apex:page standardController=”Account” extensions=”ExtensionA, ExtensionB”>",
            "    <apex:commandButton action=”{!save}” value=”Save” />",
            "</apex:page>"
        ],
        "choices": ["ExtensionB save()", "Standard controller save()", "ExtensionA save()", "ランタイムエラーが発生する"],
        "correct": ["ExtensionA save()"],
        "explanations":["ExtensionB save()", "Standard controller save()", "ExtensionA save()", "ランタイムエラーが発生する"],
        "descriptions":[
            "これは不正解です。ExtensionBのsave()メソッドは、ExtensionAにsave()メソッドが存在しない場合にのみ呼び出されます。しかし、この問題の文脈では、両方の拡張にsave()メソッドが存在すると明記されているため、ExtensionBのsave()メソッドは呼び出されません。",
            "これは不正解です。標準コントローラのsave()メソッドは、拡張にsave()メソッドが存在しない場合にのみ呼び出されます。この問題では、両方の拡張にsave()メソッドが存在するため、標準コントローラのメソッドは呼び出されません。",
            "これは正解です。Visualforceページで複数のコントローラ拡張を指定する場合、最初にリストされた拡張のメソッドが優先されます。したがって、この場合はExtensionAのsave()メソッドが呼び出されます。",
            "これは不正解です。この設定ではランタイムエラーは発生しません。正しくExtensionAのsave()メソッドが呼び出されます。"
        ]
    },
    {
        "number": "177",
        "question": "以下のコードから、コントローラ変数を作成するために使用できるステートメントはどれですか。3つ選びなさい。",
        "following-code": [
            "public class AccountListController {",
            "    public List<Account> getAccounts() {",
            "        return controller.getRecords();",
            "    }",
            "}"
        ],
        "choices": ["Apexpages.standardsetcontroller controller = new apexpages.standardsetcontroller(database.query(‘select id from account’));", "Apexpages.standardsetcontroller controller = new apexpages.standardsetcontroller(database.getquerylocator(‘select id from account’));", "Apexpages.standardcontroller controller = new apexpages.standardcontroller(database.getquerylocator(‘select id from account’));", "Apexpages.standardcontroller controller = new apexpages.standardcontroller([select id from account]);", "Apexpages.standardsetcontroller controller = new apexpages.standardsetcontroller(database.getquerylocator([select id from account]));"],
        "correct": ["Apexpages.standardsetcontroller controller = new apexpages.standardsetcontroller(database.query(‘select id from account’));", "Apexpages.standardsetcontroller controller = new apexpages.standardsetcontroller(database.getquerylocator(‘select id from account’));", "Apexpages.standardsetcontroller controller = new apexpages.standardsetcontroller(database.getquerylocator([select id from account]));"],
        "explanations":["Apexpages.standardsetcontroller controller = new apexpages.standardsetcontroller(database.query(‘select id from account’));", "Apexpages.standardsetcontroller controller = new apexpages.standardsetcontroller(database.getquerylocator(‘select id from account’));", "Apexpages.standardcontroller controller = new apexpages.standardcontroller(database.getquerylocator(‘select id from account’));", "Apexpages.standardcontroller controller = new apexpages.standardcontroller([select id from account]);", "Apexpages.standardsetcontroller controller = new apexpages.standardsetcontroller(database.getquerylocator([select id from account]));"],
        "descriptions":[
            "これは正解です。StandardSetControllerは、sObjectのリストを引数として受け取ることができます。このステートメントでは、database.queryを使用してAccountのIDを取得し、それをStandardSetControllerのコンストラクタに渡しています。",
            "これは正解です。StandardSetControllerは、Database.QueryLocatorオブジェクトを引数として受け取ることもできます。このステートメントでは、database.getquerylocatorを使用してクエリロケータを取得し、それをStandardSetControllerのコンストラクタに渡しています。",
            "これは不正解です。StandardControllerは、単一のsObjectレコードを引数として受け取る必要があります。Database.QueryLocatorオブジェクトは受け取れません。さらに、Database.QueryLocatorは複数のレコードを返す可能性がありますが、StandardControllerは単一のレコードのみを期待しています。",
            "これは不正解です。このステートメントは、SOQLクエリを使用して取引先オブジェクトのすべてのレコードのIDを取得しようとします。もし取引先オブジェクトに2つ以上のレコードが存在する場合、”List has more than 1 row for assignment to SObject”というエラーが発生します。StandardControllerのコンストラクタは、単一のsObjectレコードのみを受け取ることを期待しています。",
            "これは正解です。Database.getQueryLocatorメソッドは、SOQLクエリ文字列または直接のSOQLクエリを引数として受け取ることができます。このステートメントでは、直接のSOQLクエリを使用してDatabase.getQueryLocatorを呼び出し、その結果をStandardSetControllerのコンストラクタに渡しています。"
        ]
    },
    {
        "number": "178",
        "question": "ある開発者が、StatusComponentというLightning Webコンポーネントを作成し、Accountレコードページに挿入しました。このコンポーネントを利用できるようにするために、開発者が行うべきことはどれですか。2つ選びなさい。",
        "choices": ["<target>Lightning_RecordPage</target>をstatusComponent.js-meta.xmlファイルに追加する。", "<target>Lightning_RecordPage</target>をstatusComponent.jsファイルに追加する。", "<masterLabel>Account</masterLabel>をstatusComponent.js-meta.xmlファイルに追加する。", "<isExposed>true</isExposed>をstatusComponent.js-meta.xmlファイルに追加する。"],
        "correct": ["<target>Lightning_RecordPage</target>をstatusComponent.js-meta.xmlファイルに追加する。", "<isExposed>true</isExposed>をstatusComponent.js-meta.xmlファイルに追加する。"],
        "explanations":["<target>Lightning_RecordPage</target>をstatusComponent.js-meta.xmlファイルに追加する。", "<target>Lightning_RecordPage</target>をstatusComponent.jsファイルに追加する。", "<masterLabel>Account</masterLabel>をstatusComponent.js-meta.xmlファイルに追加する。", "<isExposed>true</isExposed>をstatusComponent.js-meta.xmlファイルに追加する。"],
        "descriptions":[
            "これは正解です。手順3に該当します。",
            "これは不正解です。.jsファイルはコンポーネントのロジックを記述する場所であり、ページのタイプや利用可能なオブジェクトを指定するための場所ではありません。このような設定は.js-meta.xmlファイルに追加する必要があります。",
            "これは不正解です。<masterLabel>タグはコンポーネントの表示名を指定するためのもので、特定のオブジェクトにコンポーネントを関連付けるためのものではありません。",
            "これは正解です。手順2に該当します。"
        ]
    },
    {
        "number": "179",
        "question": "以下のコードを実行した場合、xの値は何になりますか。",
        "following-code": [
            "Boolean isOK;",
            "Integer x;",
            "String theString = 'Hello';\n",
            "if (isOK == false && theString == 'Hello') {",
            "    x = 1;",
            "} else if (isOK == true && theString =='Hello') {",
            "    x = 2;",
            "} else if (isOK != null && theString == 'Hello') {",
            "    x = 3;",
            "} else {",
            "    x = 4;",
            "}"
        ],
        "choices": ["1", "2", "3", "4"],
        "correct": ["4"],
        "explanations":["1", "2", "3", "4"],
        "descriptions":[
            "",
            "",
            "",
            "デバッグログには 4 が表示されます。\n以下がコードの実行フローです。\n\n１．isOKの初期値は設定されていないため、nullです。\n２．theStringの初期値は'Hello'です。\n３．最初のif条件isOK == false && theString == 'Hello'を評価します。isOKはnullなので、この条件はfalseとなります。\n４．次にelse if条件isOK == true && theString =='Hello'を評価します。isOKはnullなので、この条件もfalseとなります。\n５．さらに次のelse if条件isOK != null && theString == 'Hello'を評価します。isOKはnullなので、この条件もfalseとなります。\n６．3つの条件がすべてfalseなので、最後のelseブロックが実行されます。\n７．xに4が代入されます。"
        ]
    },
    {
        "number": "180",
        "question": "アプリケーションイベントは従来のpublish-subscribeモデルに従っています。イベントを発生させるには、どのメソッドを使用しますか。",
        "choices": ["emit()", "fireEvent()", "fire()", "registerEvent()"],
        "correct": ["fire()"],
        "explanations":["emit()", "fireEvent()", "fire()", "registerEvent()"],
        "descriptions":[
            "これは不正解です。Aura コンポーネントには emit() メソッドは存在しません。",
            "これは不正解です。Aura コンポーネントには fireEvent() メソッドは存在しません。",
            "これは正解です。コンポーネントイベントを起動するためにはfire()メソッドを使用します。具体的には、cmp.getEvent(”evtName”).fire();のように使用されます。",
            "これは不正解です。Aura コンポーネントにはregisterEvent()メソッドは存在しません。"
        ]
    },
    {
        "number": "181",
        "question": "開発者は、取引先オブジェクトにトリガーを作成し、そのトリガーが正常に一度に多数のレコードを処理できるかテストしたいと考えています。開発者チームは、一意の名前を持つ200個の取引先レコードでトリガーをテストする必要があると判断しました。\n最小限のコード量で単体テスト内のテストデータを作成するためには、どのような作業を行う必要がありますか。2つ選びなさい。",
        "choices": ["テストデータを含む静的リソースを作成します。", "テストクラスで@isTest(isParallel=true)を使用します。", "テストクラスで@isTest(seeAllData=true)を使用します。", "Test.loadDataを使用して、テストメソッドにデータを入力します。"],
        "correct": ["テストデータを含む静的リソースを作成します。", "Test.loadDataを使用して、テストメソッドにデータを入力します。"],
        "explanations":["テストデータを含む静的リソースを作成します。", "テストクラスで@isTest(isParallel=true)を使用します。", "テストクラスで@isTest(seeAllData=true)を使用します。", "Test.loadDataを使用して、テストメソッドにデータを入力します。"],
        "descriptions":[
            "これは正解です。静的リソースを使用してテストデータを保存し、Test.loadData メソッドを利用してそれらのデータをテストクラスでロードすることは、大量のテストデータを効率的に作成する有効な方法です。",
            "これは不正解です。@isTest(isParallel=true) アノテーションは、テストクラスの並列実行を許可するものであり、テストデータの作成とは関係ありません。",
            "これは不正解です。@isTest(seeAllData=true) は、テストメソッドが本番環境のデータにアクセスすることを許可するものです。テストデータの作成には関係なく、通常は避けるべき実施方法です。",
            "これは正解です。Test.loadData メソッドは、静的リソースからのデータをロードして、テスト環境内で使用するための効率的な方法です。これは、大量のテストデータを迅速かつ効率的に作成するのに適しています。"
        ]
    },
    {
        "number": "182",
        "question": "開発者が非同期メソッドまたはfutureメソッドに関する情報を確認できる場所はどこですか。2つ選びなさい。",
        "choices": ["Apex ジョブ", "一時停止中の失敗したフローインタビュー", "[時間ベースのワークフロー]モニター", "Apex Flex キュー"],
        "correct": ["Apex ジョブ", "Apex Flex キュー"],
        "explanations":["Apex ジョブ", "一時停止中の失敗したフローインタビュー", "[時間ベースのワークフロー]モニター", "Apex Flex キュー"],
        "descriptions":[
            "これは正解です。Apexジョブページは、非同期Apexの実行に関する情報を提供します。これには、@futureメソッドやバッチApex、スケジュールされたApexの実行情報が含まれます。",
            "これは不正解です。一時停止中の失敗したフローインタビューは、一時停止されたフローのインスタンスに関する情報を提供します。非同期メソッドやfutureメソッドの実行情報とは関係ありません。",
            "これは不正解です。[時間ベースのワークフロー]モニターは、時間ベースのワークフローアクションの実行を監視するためのものです。非同期メソッドやfutureメソッドの実行情報とは関係ありません。",
            "これは正解です。Apex Flexキューは、バッチApexジョブの待機行列を表示するためのものです。非同期処理の一部として、バッチApexジョブの実行順序を管理するために使用されます。"
        ]
    },
    {
        "number": "183",
        "question": "開発者は、Salesforce の様々な種類のケースを独立した要件でテストできるようにするために、一連のテスト全体の基本データセット (取引先、取引先責任者、商品、納入商品) を作成する必要があります。\n各単体テストに必要なデータを効率的に生成できるのはどの方法でしょうか。",
        "choices": ["viodメソッドで@TestSetupを使用する", "単体テストクラスの先頭に@isTest(seeAllData = true)を追加する", "単体テストのTest.startTest()の前にテストデータを作成する", "スタブAPIを使ってモックを作成する"],
        "correct": ["viodメソッドで@TestSetupを使用する"],
        "explanations":["viodメソッドで@TestSetupを使用する", "単体テストクラスの先頭に@isTest(seeAllData = true)を追加する", "単体テストのTest.startTest()の前にテストデータを作成する", "スタブAPIを使ってモックを作成する"],
        "descriptions":[
            "これは正解です。@TestSetupを使用すると、単体テストの前に一度だけ実行されるセットアップメソッドを作成できます。このメソッド内で作成されたデータは、その後のすべてのテストメソッドで利用できるため、基本データセットを効率的に生成するのに適しています。",
            "これは不正解です。@isTest(seeAllData = true)は、テストメソッドが実際の組織データにアクセスできるようにするものですが、通常は使用を避けるべきです。テストデータの分離と組織データへの依存を避けるため、テスト内で独自のデータを生成することが推奨されます。",
            "これは不正解です。Test.startTest()とTest.stopTest()は、テストのガバナ制限を分離するために使用されますが、テストデータの生成を効率化するためのものではありません。",
            "これは不正解です。スタブAPIは、外部システムへの呼び出しを模倣するために使用されるもので、テストデータの生成には関係ありません。"
        ]
    },
    {
        "number": "184",
        "question": "メタデータAPIを使用してデプロイできるコンポーネントはどれですか。2つ選びなさい。",
        "choices": ["ケースのレイアウト", "ケースフィードのレイアウト", "コンソールレイアウト", "取引先のレイアウト"],
        "correct": ["ケースのレイアウト", "取引先のレイアウト"],
        "explanations":["ケースのレイアウト", "ケースフィードのレイアウト", "コンソールレイアウト", "取引先のレイアウト"],
        "descriptions":[
            "これは正解です。メタデータAPIを使用して、ケースのレイアウトをデプロイすることができます。ケースレイアウトは、ケースオブジェクトのページレイアウトを定義するためのもので、メタデータAPIを通じて操作が可能です。",
            "これは不正解です。メタデータAPIを使用してケースフィードのレイアウトを直接デプロイすることはできません。変更を適用するためには手動で行う必要があります。",
            "これは不正解です。メタデータAPIを使用してコンソールレイアウトを直接デプロイすることはできません。変更を適用するためには手動で行う必要があります。",
            "これは正解です。メタデータAPIを使用して、取引先のレイアウトをデプロイすることができます。取引先レイアウトは、取引先オブジェクトのページレイアウトを定義するためのもので、メタデータAPIを通じて操作が可能です。"
        ]
    },
    {
        "number": "185",
        "question": "多くの開発者からなるチームが、本番組織と同じ構成を持つ個々の組織で作業しています。このシナリオに最も適しているのはどのタイプの組織ですか。",
        "choices": ["Developer Sandbox", "Developer Edition", "Full Sandbox", "Partner Developer Edition"],
        "correct": ["Developer Sandbox"],
        "explanations":["Developer Sandbox", "Developer Edition", "Full Sandbox", "Partner Developer Edition"],
        "descriptions":[
            "これは正解です。Developer Sandboxは隔離された環境での開発とテストを目的としており、本番組織の設定(メタデータ)のコピーが含まれます。多くの開発者がそれぞれの組織で作業する際に、本番組織と同じ構成を持つ環境が必要な場合に適しています。",
            "これは不正解です。Developer Editionは、Salesforceの機能を試すための独立した組織ですが、本番組織のコピーではありません。",
            "これは不正解です。Full Sandboxは本番組織の完全なコピーを提供しますが、1つの組織に対して1つしか作成できない制限があるため、多数の開発者がそれぞれ持つことはできません。",
            "これは不正解です。Partner Developer Editionは、Dev Hub パートナービジネス組織から作成できるスクラッチ組織の一つです。これは、パートナーがSalesforceの機能を試すための独立した組織として提供されます。しかし、このシナリオにおいて、本番組織と同じ構成を持つ個々の組織での作業には適していません。"
        ]
    },
    {
        "number": "186",
        "question": "Universal Containers社は、Salesforce組織内のすべてのデータと添付ファイルを月に1回バックアップしたいと考えています。この要件を満たすために、開発者はどのアプローチを使用すべきでしょうか。",
        "choices": ["データローダーのコマンドラインを使用します。", "データエクスポートのスケジュールされたジョブを定義します。", "スケジュール可能なApexクラスを作成します。", "レポートをスケジュールします。"],
        "correct": ["データエクスポートのスケジュールされたジョブを定義します。"],
        "explanations":["データローダーのコマンドラインを使用します。", "データエクスポートのスケジュールされたジョブを定義します。", "スケジュール可能なApexクラスを作成します。", "レポートをスケジュールします。"],
        "descriptions":[
            "これは不正解です。データローダーのコマンドラインは、特定のオブジェクトのデータをエクスポート、インポート、更新、削除するためのものですが、Salesforce組織内のすべてのデータと添付ファイルを自動的にエクスポートするためのものではありません。",
            "これは正解です。Salesforceの[設定] > [データのエクスポート] > [マンスリーエクスポートサービス] > [エクスポートをスケジュール]から、月に1回などの頻度指定や添付ファイルを含めるなどのオプション設定を行い、全オブジェクトのバックアップデータをエクスポートさせることができます。",
            "これは不正解です。Apexを使用してデータを直接エクスポートすることはできません。Apexは主にビジネスロジックの実行やデータの操作に使用されますが、大量のデータのバックアップには適していません。",
            "これは不正解です。レポートのスケジュールと登録は、特定のレポートの結果を定期的に取得するためのもので、手動でレポートを実行せずに、最も関心のある総計値について常に情報を把握するための通知を受信することができます。しかし、組織内のすべてのデータと添付ファイルをバックアップするためには、この方法は適していません。"
        ]
    },
    {
        "number": "187",
        "question": "トリガーが同じオブジェクトとイベントに関連付けられている場合の実行順序に関して正しい説明はどれですか。",
        "choices": ["トリガーはトリガー名のアルファベット順に実行されます。", "トリガーの実行順序は保証されません。", "変更された順序で実行されます。", "トリガーは作成された順序で実行されます。"],
        "correct": ["トリガーの実行順序は保証されません。"],
        "explanations":["トリガーはトリガー名のアルファベット順に実行されます。", "トリガーの実行順序は保証されません。", "変更された順序で実行されます。", "トリガーは作成された順序で実行されます。"],
        "descriptions":[
            "これは不正解です。Salesforceでは、トリガーの実行順序はトリガー名のアルファベット順に基づいているわけではありません。",
            "これは正解です。Salesforceでは、同じオブジェクトとイベントに関連付けられている複数のトリガーの実行順序は保証されていません。そのため、特定の順序でトリガーを実行する必要がある場合は、複数のトリガーを1つのトリガーに統合し、その中で明示的な順序でロジックを実行する必要があります。",
            "これは不正解です。トリガーの実行順序は、変更された順序に基づいているわけではありません。",
            "これは不正解です。トリガーの実行順序は、作成された順序に基づいているわけではありません。"
        ]
    },
    {
        "number": "188",
        "question": "開発者は、インスタンス化できないShippingCalculatorクラスを作成する必要があり、サブクラスがオーバーライドできるcalculateメソッドの実用的なデフォルト実装を含める必要があります。 ShippingCalculatorクラスの正しい実装はどれですか。",
        "choices": ["Public abstract class ShippingCalculator {\n    public override calculate() { /*implementation*/ }\n}", "Public abstract class ShippingCalculator {\n    public virtual void calculate() { /*implementation*/ }\n}", "Public abstract class ShippingCalculator {\n    public abstract calculate() { /*implementation*/ }\n}", "Public abstract class ShippingCalculator {\n    public void calculate() { /*implementation*/ }\n}"],
        "correct": ["Public abstract class ShippingCalculator {\n    public virtual void calculate() { /*implementation*/ }\n}"],
        "explanations":["Public abstract class ShippingCalculator {\n    public override calculate() { /*implementation*/ }\n}", "Public abstract class ShippingCalculator {\n    public virtual void calculate() { /*implementation*/ }\n}", "Public abstract class ShippingCalculator {\n    public abstract calculate() { /*implementation*/ }\n}", "Public abstract class ShippingCalculator {\n    public void calculate() { /*implementation*/ }\n}"],
        "descriptions":[
            "これは不正解です。overrideキーワードは、サブクラスで既存のvirtualまたはabstractメソッドをオーバーライドするために使用されます。しかし、このクラスにはオーバーライドする元となるvirtualまたはabstractメソッドが存在しません。また、calculateメソッドの戻り値の型が指定されていません。",
            "これは正解です。virtualキーワードは、メソッドがサブクラスでオーバーライドされることを許可するために使用されます。この選択肢では、calculateメソッドはデフォルトの実装を持ち、サブクラスでオーバーライドすることができます。",
            "これは不正解です。abstractメソッドは実装(コードブロック)を持つことができません。この選択肢では、abstractメソッドに具体的な実装が含まれているため、不正確です。また、calculateメソッドの戻り値の型が指定されていません。",
            "これは不正解です。この選択肢のcalculateメソッドは、サブクラスでオーバーライドすることができない普通のメソッドとして定義されています。オーバーライドを許可するためには、calculateメソッドにvirtualキーワードが必要です。"
        ]
    },
    {
        "number": "189",
        "question": "継続的インテグレーションの一環として、デプロイと単体テストの実行をスクリプト化するために、開発者は何を使用する必要がありますか。",
        "choices": ["開発者コンソール", "VS Code", "Salesforce CLI", "匿名実行"],
        "correct": ["Salesforce CLI"],
        "explanations":["開発者コンソール", "VS Code", "Salesforce CLI", "匿名実行"],
        "descriptions":[
            "これは不正解です。開発者コンソールは、コードの編集やデバッグ、SOQLクエリの実行など、Salesforceの開発作業をサポートするツールです。しかし、継続的インテグレーションの一環としてのデプロイや単体テストの実行を自動化するためのスクリプト化には適していません。",
            "これは不正解です。VS Codeは、Salesforceの開発作業をサポートするコードエディターの一つです。Salesforceの拡張機能を使用することで、VS Codeからもデプロイやテストの実行は可能ですが、継続的インテグレーションの一環としてのスクリプト化には、Salesforce CLIの使用が必要です。",
            "これは正解です。Salesforce CLIは、コマンドラインからSalesforceの各種操作を行うためのツールです。デプロイやテストの実行、結果の取得など、継続的インテグレーションの一環として必要な操作をスクリプト化して自動化するためには、Salesforce CLIを使用するのが適しています。",
            "これは不正解です。匿名実行は、Salesforceの開発者コンソール内で即座にApexコードを実行する機能です。これは主にコードの小さな断片をテストするためや、短いスクリプトを一時的に実行するために使用されます。しかし、継続的インテグレーションの一環としてのデプロイや単体テストの実行を自動化・スクリプト化する主要なツールとしては適していません。"
        ]
    },
    {
        "number": "190",
        "question": "Lightning Experienceで取引先の既存の編集ボタンを押下するときに、ユーザーにカスタムユーザーインターフェースを提供したいと考えています。どのように提供すべきですか。",
        "choices": ["取引先の[編集]ボタンをLightningアクションで上書きします", "取引先の[編集]ボタンをLightningコンポーネントで上書きします", "取引先の[編集]ボタンをLightningページで上書きします", "取引先の[編集]ボタンをSalesforce フローで上書きします"],
        "correct": ["取引先の[編集]ボタンをLightningコンポーネントで上書きします"],
        "explanations":["取引先の[編集]ボタンをLightningアクションで上書きします", "取引先の[編集]ボタンをLightningコンポーネントで上書きします", "取引先の[編集]ボタンをLightningページで上書きします", "取引先の[編集]ボタンをSalesforce フローで上書きします"],
        "descriptions":[
            "これは不正解です。Lightningアクションを使用して新たなアクションを作成し、それをレコードページに追加することは可能ですが、既存の[編集]ボタンの動作を直接上書きすることはできません。",
            "これは正解です。Lightningコンポーネントを使用して、取引先の[編集]ボタンの動作を完全にカスタマイズすることができます。具体的には、新しいLightningコンポーネントを作成し、そのコンポーネントを[編集]ボタンの動作として指定することで、ボタンをクリックしたときの動作を上書きすることができます。",
            "これは不正解です。Lightningページは、Salesforceのレコードページやホームページ、アプリページなどのUIをカスタマイズするためのものであり、特定のボタンの動作を上書きするためのものではありません。",
            "これは不正解です。Salesforce フローは、ユーザーのインタラクションに基づいて一連のステップやロジックを実行するためのツールです。ボタンの動作自体を上書きするためのものではありませんが、ボタンやアクションをクリックしたときにフローを起動することは可能です。"
        ]
    },
    {
        "number": "191",
        "question": "開発者は、Salary__cカスタム項目を含むContactレコードを作成するために、ユーザーがContactレコード情報を入力できるLightningコンポーネントを作成する必要があります。\nSalary__c 項目が通貨入力として機能し、Salary__c の正しい項目レベル権限を持っているユーザーのみが表示および編集できるようにするには、Lightning-record-edit-form とともに何を使用する必要がありますか。",
        "choices": ["<lightning-input-field field-name = “Salary__c”></ lightning-input-field>", "<lightning-input-currency value = “Salary__c”></ lightning-input-currency>", "<lightning-input type = “number” value = “Salary__c” formatter = “currency”></ lightning-input>", "<lightning-formatted-number value = “Salary__c” format-style = “currency”></ lightning-formatted-number>"],
        "correct": ["<lightning-input-field field-name = “Salary__c”></ lightning-input-field>"],
        "explanations":["<lightning-input-field field-name = “Salary__c”></ lightning-input-field>", "<lightning-input-currency value = “Salary__c”></ lightning-input-currency>", "<lightning-input type = “number” value = “Salary__c” formatter = “currency”></ lightning-input>", "<lightning-formatted-number value = “Salary__c” format-style = “currency”></ lightning-formatted-number>"],
        "descriptions":[
            "これは正解です。<lightning-input-field>は、Salesforceのオブジェクトの項目を表示および編集するためのLightning Web Componentです。<lightning-record-edit-form>と組み合わせることで、項目レベルの権限を考慮してフィールドを表示・編集することができます。このコンポーネントを使用すると、Salary__c項目の権限に基づいて、適切なユーザーにのみ入力フィールドが表示されます。",
            "これは不正解です。<lightning-input-currency>は存在しないコンポーネントです。",
            "これは不正解です。<lightning-input>は一般的な入力フィールドを提供するコンポーネントですが、Salesforceの項目レベルの権限を考慮する機能はありません。したがって、このコンポーネントを使用してもSalary__cの項目レベルの権限は適用されません。",
            "これは不正解です。<lightning-formatted-number>は数値を特定の形式で表示するためのコンポーネントです。このコンポーネントは入力フィールドを提供するものではなく、また項目レベルの権限を考慮する機能もありません。"
        ]
    },
    {
        "number": "192",
        "question": "開発者は、Apexクラスのメソッドを特定する必要があります。このメソッドは、Account上のSOQL文の結果セットを繰り返し処理することで、メモリ内でリソース負荷が高い処理を実行します。また、このメソッドは変更をデータベースに保存するためにDMLステートメントを実行します。トランザクション制御を確実にし、ガバナー制限の超過を回避するための最善の方法として、開発者が実装すべき１つの技法はどれですか。",
        "choices": ["Database.Savepointメソッドを使用して、データベースの整合性を強制します。", "部分的なDML文を使用して、有効なデータのみがコミットされるようにします。", "@ReadOnlyアノテーションを使用して、SOQLによって返される行数を回避します。", "System.Limitクラスを使用して、現在のCPUガバナー制限の消費量を監視します。"],
        "correct": ["System.Limitクラスを使用して、現在のCPUガバナー制限の消費量を監視します。"],
        "explanations":["Database.Savepointメソッドを使用して、データベースの整合性を強制します。", "部分的なDML文を使用して、有効なデータのみがコミットされるようにします。", "@ReadOnlyアノテーションを使用して、SOQLによって返される行数を回避します。", "System.Limitクラスを使用して、現在のCPUガバナー制限の消費量を監視します。"],
        "descriptions":[
            "これは不正解です。Apexには「Database.Savepointメソッド」という名前のメソッドは存在しません。しかし、SalesforceにはDatabase.setSavepoint()というメソッドが存在し、これを使用するとトランザクションの特定の時点をマークすることができます。その後、Database.rollback(databaseSavepoint)メソッドを利用して、指定したセーブポイントまでのDML操作を取り消すことができます。このrollbackメソッドを使うことで、エラーが発生した場合や予期せぬ問題が生じた時に、データベースの状態を元の状態に戻すことができるのです。したがって、「データベースの整合性を強制する」という文脈での使用は正しいと言えますが、問題文のメソッド名が不正確であるため、この選択肢は不正解となります。",
            "これは不正解です。Database.insert(records, false)やその他の部分的なDML操作はエラーを起こすレコードだけを失敗させ、他のレコードは正常に操作します。しかし、レコード数が多い場合やすべてのレコードが有効である場合、ガバナー制限を超える可能性があります。",
            "これは不正解です。@ReadOnlyアノテーションは、SOQLの行数制限を増やすことができますが、DML操作は許可されていません。このシナリオでは、メソッドがDMLステートメントを実行するため、このアノテーションは適切ではありません。",
            "これは正解です。System.Limitsクラスを使用することで、ガバナ制限の消費量をリアルタイムで監視することができます。これにより、リソースを大量に消費しているメソッドや処理を特定し、ガバナ制限の超過を回避するための最適化を行うことができます。"
        ]
    },
    {
        "number": "193",
        "question": "組織には商談を作成するフローがあります。開発者はこのフローを変更し、取引先責任者を新しく作成し、その取引先責任者のIDを商談に関連付ける必要があります。フローにどのような要素を追加する必要がありますか。",
        "choices": ["新しい[レコードを取得]要素を追加します。", "新しい[レコードを更新]要素を追加します。", "新しい[アクション要素] (※作成タイプ) を追加します。", "新しい[レコードを作成]要素を追加します。"],
        "correct": ["新しい[レコードを作成]要素を追加します。"],
        "explanations":["新しい[レコードを取得]要素を追加します。", "新しい[レコードを更新]要素を追加します。", "新しい[アクション]要素 (※作成タイプ) を追加します。", "新しい[レコードを作成]要素を追加します。"],
        "descriptions":[
            "これは不正解です。このシナリオでは新しい取引先責任者を作成する必要がありますが、[レコードを取得]要素は既存のレコードを取得するためのものであり、新しいレコードを作成するためのものではありません。",
            "これは不正解です。この要素は既存のレコードを更新するためのもので、新しいレコードを作成するためのものではありません。",
            "これは不正解です。この要素は特定のアクションを実行するためのもので、新しいレコードを直接作成するためのものではありません。",
            "これは正解です。取引先責任者を新しく作成するためには、[レコードを作成]要素を使用するのが最も適切です。この要素を使用して取引先責任者を作成した後、そのIDを取得し、次に[レコードを更新]要素を使用して商談に保存することができます。"
        ]
    },
    {
        "number": "194",
        "question": "値’High’、’Medium’、’Low’は、異なるオブジェクト間で複数の選択リストに共通する値として識別されています。値を上記のものに制限しつつ、選択リストとその値のメンテナンスを合理化するために、開発者が取ることのできる方法は何でしょうか。",
        "choices": ["各オブジェクトに選択リストを作成し、値を含むグローバル選択リスト値セットを使用します。", "各オブジェクトに必須項目として選択リストを作成し、”値を入力順ではなく文字コード順に表示”を選択します。", "各オブジェクトに選択リストを作成し、データの整合性を確保するための入力規則を追加します。", "各オブジェクトに選択リストを作成し、”値セットで定義された値に選択リストを制限します”を選択します。"],
        "correct": ["各オブジェクトに選択リストを作成し、値を含むグローバル選択リスト値セットを使用します。"],
        "explanations":["各オブジェクトに選択リストを作成し、値を含むグローバル選択リスト値セットを使用します。", "各オブジェクトに必須項目として選択リストを作成し、”値を入力順ではなく文字コード順に表示”を選択します。", "各オブジェクトに選択リストを作成し、データの整合性を確保するための入力規則を追加します。", "各オブジェクトに選択リストを作成し、”値セットで定義された値に選択リストを制限します”を選択します。"],
        "descriptions":[
            "これは正解です。グローバル選択リスト値セットを使用することで、複数のオブジェクト間で共通の選択リスト値を一元管理することができます。これにより、選択リストの値のメンテナンスを合理化することができます。",
            "これは不正解です。この選択肢は選択リストの表示順に関するものであり、選択リストの値のメンテナンスを合理化するための方法とは関係ありません。",
            "これは不正解です。入力規則を使用してデータの整合性を確保することは可能ですが、選択リストの値のメンテナンスを合理化するための最も効率的な方法ではありません。",
            "これは不正解です。この選択肢は選択リストの値を制限するためのものですが、複数のオブジェクト間で共通の選択リスト値を一元管理するための方法としては不適切です。"
        ]
    },
    {
        "number": "195",
        "question": "Batchableインターフェースを実装しているApexクラスのexecute()メソッドの内部でApexコードが実行される場合、ガバナ制限に関して正しい記述を2つ選びなさい。",
        "choices": ["Apexのガバナ制限は、execute()メソッドの繰り返しごとにリセットされます。", "トランザクションが非同期であるため、Apexガバナの制限を超えることはありません。", "トランザクションが非同期であるため、Apexガバナの制限値が高くなる可能性があります。", "Apexクラスのコンストラクタを呼び出している間、Apexガバナ制限は緩和されます。"],
        "correct": ["Apexのガバナ制限は、execute()メソッドの繰り返しごとにリセットされます。", "トランザクションが非同期であるため、Apexガバナの制限値が高くなる可能性があります。"],
        "explanations":["Apexのガバナ制限は、execute()メソッドの繰り返しごとにリセットされます。", "トランザクションが非同期であるため、Apexガバナの制限を超えることはありません。", "トランザクションが非同期であるため、Apexガバナの制限値が高くなる可能性があります。", "Apexクラスのコンストラクタを呼び出している間、Apexガバナ制限は緩和されます。"],
        "descriptions":[
            "これは正解です。Batchableインターフェースのexecute()メソッドは、各バッチの処理ごとに新しいトランザクションとして実行されるため、ガバナ制限は各バッチの処理ごとにリセットされます。",
            "これは不正解です。トランザクションが非同期であるからといって、Apexガバナの制限を超えないわけではありません。非同期処理でもガバナ制限は適用され、その制限を超えるとエラーが発生します。",
            "これは正解です。非同期処理、特にBatch ApexやFutureメソッドなどでは、同期処理と比べてガバナ制限が緩和される場合があります。",
            "これは不正解です。コンストラクタの呼び出し時にApexガバナ制限が緩和されるわけではありません。コンストラクタは通常のApexコードと同じガバナ制限の下で実行されます。"
        ]
    },
    {
        "number": "196",
        "question": "すべてのテストを実行した後、開発者はクラスのコードカバレッジをチェックするために何をすべきですか。",
        "choices": ["[Apex クラス]ページのビューの[コードカバレッジ]列を表示します。", "開発者コンソールの[Tests]タブの[Overall Code Coverage]を使用して、クラスのコードカバー率を表示します。", "[Apex クラス]ページのビューの[Class test Coverage]タブを表示します。", "[Apex テスト実行]ページでクラスを選択して実行します。"],
        "correct": ["開発者コンソールの[Tests]タブの[Overall Code Coverage]を使用して、クラスのコードカバー率を表示します。"],
        "explanations":["[Apex クラス]ページのビューの[コードカバレッジ]列を表示します。", "開発者コンソールの[Tests]タブの[Overall Code Coverage]を使用して、クラスのコードカバー率を表示します。", "[Apex クラス]ページのビューの[Class test Coverage]タブを表示します。", "[Apex テスト実行]ページでクラスを選択して実行します。"],
        "descriptions":[
            "これは不正解です。Salesforceのセットアップメニューの[Apex クラス]ページには直接「コードカバレッジ」列は存在しません。しかし、[組織のコードカバー率を見積る]リンクを使用して、組織全体のコードカバー率を確認することは可能です。",
            "これは正解です。開発者コンソールの[Tests]タブには、全体のコードカバレッジを表示する[Overall Code Coverage]セクションがあります。また、各クラスやトリガーのカバレッジも確認することができます。",
            "これは不正解です。Salesforceの[Apex クラス]ページには[Class test Coverage]というタブは存在しません。",
            "これは不正解です。[Apex テスト実行]ページはテストの実行を行うためのものであり、コードカバレッジを直接確認するためのものではありません。"
        ]
    },
    {
        "number": "197",
        "question": "スクラッチ組織を作成するために何を使用すべきですか。",
        "choices": ["Salesforce CLI", "Workbench", "Developer Console", "Sandbox の更新"],
        "correct": ["Salesforce CLI"],
        "explanations":["Salesforce CLI", "Workbench", "Developer Console", "Sandbox の更新"],
        "descriptions":[
            "これは正解です。Salesforce CLI (Command Line Interface) は、スクラッチ組織の作成、管理、削除など、多くの開発者タスクを行うためのツールです。しかし、スクラッチ組織を作成する前に、設定画面からDev Hubを有効化する必要があります。Dev Hubを有効化した後、sfdx force:org:create コマンドを使用してスクラッチ組織を作成することができます。",
            "これは不正解です。WorkbenchはSalesforceのデータやメタデータを操作するためのツールですが、スクラッチ組織の作成には使用されません。",
            "これは不正解です。Developer ConsoleはApexコードの編集やデバッグ、SOQLクエリの実行などを行うためのツールですが、スクラッチ組織の作成には使用されません。",
            "これは不正解です。Sandboxの更新は、本番環境のデータや設定をSandboxに反映するためのものです。スクラッチ組織の作成とは関係ありません。"
        ]
    },
    {
        "number": "198",
        "question": "単体テストで実行可能なシナリオはどれですか。",
        "choices": ["別のユーザーとして匿名Apexを実行する。", "コールアウトを使用してリモートサイトからデータを読み込む。", "システムメソッドを使用してレコードの作成日を設定する。", "geccontentAsPDF()を使用してVisualforcePDFを生成する。"],
        "correct": ["システムメソッドを使用してレコードの作成日を設定する。"],
        "explanations":["別のユーザーとして匿名Apexを実行する。", "コールアウトを使用してリモートサイトからデータを読み込む。", "システムメソッドを使用してレコードの作成日を設定する。", "geccontentAsPDF()を使用してVisualforcePDFを生成する。"],
        "descriptions":[
            "これは不正解です。テストメソッド内で特定のユーザーとしてコードを実行することはSystem.runAs()を使用することで可能ですが、匿名Apexとして実行することはできません。",
            "これは不正解です。単体テスト中にリアルタイムの外部コールアウトを行うことはできません。しかし、テストメソッドでコールアウトの動作をシミュレートするためのTest.setMock()メソッドが提供されています。",
            "これは正解です。 System.Test.setCreatedDate() メソッドを使用して、単体テスト内でレコードの作成日を設定することができます。",
            "これは不正解です。getContentAsPDF()メソッドはテストメソッド内での使用がサポートされていません。テストメソッド内でこのメソッドを使用すると、テストは失敗します。"
        ]
    },
    {
        "number": "199",
        "question": "開発者が、@remoteActionデコレータを使用してグローバルなサーバー側メソッドを呼び出そうとするとエラーが発生します。このエラーを解決するにはどうすればよいですか。",
        "choices": ["サーバー側のメソッドを (static=false) でデコレートする。", "サーバー側のメソッドのシグネチャにstaticを追加する。", "サーバー側のメソッドを(static=true)でデコレートする。", "関数のシグネチャをprivate staticに変更する。"],
        "correct": ["サーバー側のメソッドのシグネチャにstaticを追加する。"],
        "explanations":["サーバー側のメソッドを (static=false) でデコレートする。", "サーバー側のメソッドのシグネチャにstaticを追加する。", "サーバー側のメソッドを(static=true)でデコレートする。", "関数のシグネチャをprivate staticに変更する。"],
        "descriptions":[
            "これは不正解です。static=false というデコレーションはApexに存在しません。また、@remoteActionで呼び出されるメソッドはstaticである必要があります。",
            "これは正解です。@remoteActionで呼び出されるメソッドはstaticである必要があります。したがって、メソッドのシグネチャにstaticキーワードを追加することでエラーを解決できます。",
            "これは不正解です。Apexにはstatic=trueというデコレーションは存在しません。正しくは、メソッドのシグネチャにstaticキーワードを追加するだけです。",
            "これは不正解です。@remoteActionで呼び出されるメソッドはpublicまたはglobalなアクセス修飾子を持つ必要があります。したがって、private staticにすると、Visualforceページからアクセスできなくなります。"
        ]
    },
    {
        "number": "200",
        "question": "ある開発チームは、デプロイスクリプトを使用して、開発サイクル中にサンドボックスに自動的にデプロイしたいと考えています。サンドボックスにデプロイするスクリプトを実行するために使用できるツールはどれですか。2つ選びなさい。",
        "choices": ["開発者コンソール", "Salesforce CLI", "Ant 移行ツール", "変更セット"],
        "correct": ["Salesforce CLI", "Ant 移行ツール"],
        "explanations":["開発者コンソール", "Salesforce CLI", "Ant 移行ツール", "変更セット"],
        "descriptions":[
            "これは不正解です。開発者コンソールはコードの編集やデバッグ、SOQLクエリの実行などのタスクを行うためのツールですが、自動的なデプロイのスクリプト実行には使用されません。",
            "これは正解です。Salesforce CLI (Command Line Interface) は、メタデータのデプロイや取得、スクラッチ組織の管理など、多くの開発者タスクを行うためのツールです。CLIを使用して、スクリプトを通じて自動的にサンドボックスにデプロイすることができます。",
            "これは正解です。Ant 移行ツールは、SalesforceのメタデータAPIを使用して、メタデータのデプロイや取得を行うためのJava/Antベースのコマンドラインツールです。ビルドファイルを使用して、自動的にサンドボックスにデプロイするスクリプトを実行することができます。",
            "これは不正解です。変更セットは、組織間でメタデータの変更を移行するためのツールです。変更セットは、ユーザーが手動で作成し、送信する必要があります。自動的なデプロイのスクリプト実行には使用されません。"
        ]
    },
    {
        "number": "201",
        "question": "Accountオブジェクトのafterトリガーは、Accountのすべての子OpportunityでDML更新操作を実行します。 Opportunityオブジェクトにアクティブなトリガーはありませんが、特定の状況で「最大トリガー深度を超えました」エラーが発生します。Accountトリガーの再帰的な起動を説明する理由はどれですか。 2つ選びなさい",
        "choices": ["Opportunityを変更すると、Accountの積み上げ集計項目が更新されます。", "Opportunityの変更により、Accountの項目が自動的に更新されるクロスオブジェクトのワークフローが実行されています。", "無関係な並列保存操作中にAccountに変更が加えられています。", "条件に基づく共有ルールの評価中にAccountに変更が加えられています。"],
        "correct": ["Opportunityを変更すると、Accountの積み上げ集計項目が更新されます。", "Opportunityの変更により、Accountの項目が自動的に更新されるクロスオブジェクトのワークフローが実行されています。"],
        "explanations":["Opportunityを変更すると、Accountの積み上げ集計項目が更新されます。", "Opportunityの変更により、Accountの項目が自動的に更新されるクロスオブジェクトのワークフローが実行されています。", "無関係な並列保存操作中にAccountに変更が加えられています。", "条件に基づく共有ルールの評価中にAccountに変更が加えられています。"],
        "descriptions":[
            "これは正解です。Opportunityの変更がAccountの積み上げ集計項目の再計算を引き起こす可能性があります。この再計算はAccountの更新を引き起こし、その結果としてAccountのトリガーが再度実行される可能性があります。",
            "これは正解です。Opportunityの変更がクロスオブジェクトのワークフローを引き起こすことで、Accountの項目が自動的に更新される可能性があります。このような更新はAccountのトリガーの再実行を引き起こす可能性があります。",
            "これは不正解です。無関係な並列保存操作は、特定の状況でのトリガーの再帰的な起動を引き起こすものではありません。",
            "これは不正解です。条件に基づく共有ルールの評価は、レコードの可視性を変更するためのものであり、トリガーの再帰的な起動を直接引き起こすものではありません。"
        ]
    },
    {
        "number": "202",
        "question": "Salesforce管理者は、レコードによってトリガーされるフローを作成しています。特定の基準が満たされた場合、フローはApexメソッドを呼び出して、いくつかのタイプのオブジェクトを含む複雑な検証を実行する必要があります。Apexメソッドを作成する場合、メソッドをフロー内で使用できるようにするために、開発者はどのアノテーションを使用する必要がありますか。",
        "choices": ["@future", "@InvocableMethod", "@AuraEnaled", "@RemoteAction"],
        "correct": ["@InvocableMethod"],
        "explanations":["@future", "@InvocableMethod", "@AuraEnabled", "@RemoteAction"],
        "descriptions":[
            "これは不正解です。@future アノテーションは、メソッドを非同期で実行するために使用されます。これは、フローからApexメソッドを直接呼び出すためのアノテーションではありません。",
            "これは正解です。@InvocableMethod アノテーションは、フローやプロセスビルダーからApexメソッドを呼び出すために使用されます。このアノテーションが付けられたメソッドは、フロー内で直接呼び出すことができます。",
            "これは不正解です。@AuraEnabled アノテーションは、LightningコンポーネントやAuraコンポーネントからApexメソッドを呼び出すために使用されます。フローからの呼び出しには関連していません。",
            "これは不正解です。@RemoteAction アノテーションは、VisualforceページからJavaScriptを使用してApexメソッドを呼び出すために使用されます。フローからの呼び出しには関連していません。"
        ]
    },
    {
        "number": "203",
        "question": "ワークフローで、既存のAccountのカスタム項目の値を更新します。開発者は、トリガーによって更新する予定のカスタム項目の値にどのようにアクセスしますか。",
        "choices": ["before updateトリガーを記述し、Trigger.newから項目値にアクセスする。", "before insertトリガーを記述し、Trigger.newから項目値にアクセスする。", "after insertトリガーを記述し、Trigger.oldから項目値にアクセスする。", "after updateトリガーを記述し、Trigger.oldから項目値にアクセスする。"],
        "correct": ["before updateトリガーを記述し、Trigger.newから項目値にアクセスする。"],
        "explanations":["before updateトリガーを記述し、Trigger.newから項目値にアクセスする。", "before insertトリガーを記述し、Trigger.newから項目値にアクセスする。", "after insertトリガーを記述し、Trigger.oldから項目値にアクセスする。", "after updateトリガーを記述し、Trigger.oldから項目値にアクセスする。"],
        "descriptions":[
            "これは正解です。before updateトリガーは、レコードが保存される前に実行されます。Trigger.newを使用すると、更新される予定の値にアクセスできます。",
            "これは不正解です。before insertトリガーは新規レコードの作成時に使用されるため、既存のレコードの更新には関係ありません。",
            "これは不正解です。after insertトリガーは新規レコードの作成後に実行されるため、既存のレコードの更新には関係ありません。また、Trigger.oldはbefore updateとafter updateトリガーでのみアクセス可能です。",
            "これは不正解です。after updateトリガーは、レコードが保存された後に実行されます。Trigger.oldを使用すると、更新前の古い値にアクセスできますが、更新された新しい値にはアクセスできません。新しい値にアクセスするには、Trigger.newを使用する必要があります。"
        ]
    },
    {
        "number": "204",
        "question": "Apexのカスタム例外に関して正しいものはどれですか。3つ選びなさい。",
        "choices": ["カスタム例外クラスは、例外クラス以外のクラスを拡張できます。", "カスタム例外クラスは、1つまたは複数のインターフェースを実装できます。", "カスタム例外クラスにメンバ変数またはメソッドを含めることはできません。", "カスタム例外クラスは、組み込み例外クラスを拡張する必要があります。", "カスタム例外クラス名は「Exception」で終わる必要があります。"],
        "correct": ["カスタム例外クラスは、1つまたは複数のインターフェースを実装できます。", "カスタム例外クラスは、組み込み例外クラスを拡張する必要があります。", "カスタム例外クラス名は「Exception」で終わる必要があります。"],
        "explanations":["カスタム例外クラスは、例外クラス以外のクラスを拡張できます。", "カスタム例外クラスは、1つまたは複数のインターフェースを実装できます。", "カスタム例外クラスにメンバ変数またはメソッドを含めることはできません。", "カスタム例外クラスは、組み込み例外クラスを拡張する必要があります。", "カスタム例外クラス名は「Exception」で終わる必要があります。"],
        "descriptions":[
            "これは不正解です。 カスタム例外クラスは、必ずExceptionクラスを拡張する必要があります。他のクラスを拡張することはできません。",
            "これは正解です。 Apexのカスタム例外クラスは、他のクラスと同様にインターフェースを実装することができます。",
            "これは不正解です。 カスタム例外クラスはメンバ変数やメソッドを含めることができます。これにより、例外に関連する追加情報を保持したり、特定の機能を提供することが可能です。",
            "これは正解です。Apexのカスタム例外は、必ず組み込み例外クラス(Exceptionクラス)を拡張しなければなりません。",
            "これは正解です。 カスタム例外の命名規則として、クラス名は「Exception」で終わる必要があります。"
        ]
    },
    {
        "number": "205",
        "question": "開発者は、親LightningWebコンポーネント内にネストされた子LightningWebコンポーネントを作成しました。親コンポーネントは、文字列値を子コンポーネントに渡す必要があります。これを達成できる方法はどれですか。2つ選びなさい。",
        "choices": ["親コンポーネントは、カスタムイベントを使用して、データを子コンポーネントに渡すことができます。", "親コンポーネントはApexコントローラークラスを使用して、子コンポーネントにデータを送信できます。", "親コンポーネントは子コンポーネントのメソッドを呼び出すことができます。", "親コンポーネントは、パブリックプロパティを使用して、データを子コンポーネントに渡すことができます。"],
        "correct": ["親コンポーネントは子コンポーネントのメソッドを呼び出すことができます。", "親コンポーネントは、パブリックプロパティを使用して、データを子コンポーネントに渡すことができます。"],
        "explanations":["親コンポーネントは、カスタムイベントを使用して、データを子コンポーネントに渡すことができます。", "親コンポーネントはApexコントローラークラスを使用して、子コンポーネントにデータを送信できます。", "親コンポーネントは子コンポーネントのメソッドを呼び出すことができます。", "親コンポーネントは、パブリックプロパティを使用して、データを子コンポーネントに渡すことができます。"],
        "descriptions":[
            "これは不正解です。カスタムイベントは、子コンポーネントから親コンポーネントにデータを送信するために使用されます。逆の方向(親から子へ)には使用されません。",
            "これは不正解です。Apexコントローラーは、サーバーサイドのデータをフロントエンドのコンポーネントに提供するために使用されますが、親コンポーネントから子コンポーネントへのデータの直接的な送信には使用されません。",
            "これは正解です。親コンポーネントは、子コンポーネントの公開メソッドを呼び出して、データを渡すことができます。",
            "これは正解です。親コンポーネントは、子コンポーネントの公開プロパティを使用して、データを直接渡すことができます。"
        ]
    },
    {
        "number": "206",
        "question": "コンポーネントとアプリケーションのイベント処理に関するベストプラクティスはどれですか。2つ選びなさい。",
        "choices": ["イベントハンドラで低レベルのイベントを処理し、高レベルのイベントとして再起動する。", "コンポーネントイベントではなく、アプリケーションイベントを使用する。", "ロジックをヘルパーに配置して、コンポーネントバンドルでイベントロジックを再利用する。", "アプリケーションレベルで処理されるべきアクションを伝達するためにコンポーネントイベントを使用する。"],
        "correct": ["イベントハンドラで低レベルのイベントを処理し、高レベルのイベントとして再起動する。", "ロジックをヘルパーに配置して、コンポーネントバンドルでイベントロジックを再利用する。"],
        "explanations":["イベントハンドラで低レベルのイベントを処理し、高レベルのイベントとして再起動する。", "コンポーネントイベントではなく、アプリケーションイベントを使用する。", "ロジックをヘルパーに配置して、コンポーネントバンドルでイベントロジックを再利用する。", "アプリケーションレベルで処理されるべきアクションを伝達するためにコンポーネントイベントを使用する。"],
        "descriptions":[
            "これは正解です。低レベルのイベントをイベントハンドラで処理し、ビジネスロジックイベントなどの高レベルのイベントとして再起動することが推奨されています。",
            "これは不正解です。ベストプラクティスとして、可能な場合は常にコンポーネントイベントを使用することが推奨されています。アプリケーションイベントは、アプリケーションレベルでの処理が必要な場合に適しています。",
            "これは正解です。コンポーネントのバンドルでロジックを再利用する必要がある場合、そのロジックをヘルパーに配置することが推奨されています。",
            "これは不正解です。アプリケーションレベルでの処理には、アプリケーションイベントを使用することが推奨されています。"
        ]
    },
    {
        "number": "207",
        "question": "Apexクラスとインターフェースに関して、次のうち正しいステートメントはどれでしょうか。２つ選択してください。",
        "choices": ["クラスは複数のレベルの内部クラスを持つことができます。", "インターフェースのデフォルトの修飾子はprivateです。", "クラスのデフォルトの修飾子はprivateです。", "例外クラスはExceptionというワードで終わる必要があります。"],
        "correct": ["クラスのデフォルトの修飾子はprivateです。", "例外クラスはExceptionというワードで終わる必要があります。"],
        "explanations":["クラスは複数のレベルの内部クラスを持つことができます。", "インターフェースのデフォルトの修飾子はprivateです。", "クラスのデフォルトの修飾子はprivateです。", "例外クラスはExceptionというワードで終わる必要があります。"],
        "descriptions":[
            "これは不正解です。Apexでは、最上位クラスの中に内部クラスを持つことはできますが、内部クラスは1つ下のレベルのみです。",
            "これは不正解です。Apexのインターフェース内のメソッドはアクセス修飾子を指定せずに定義されると、自動的にグローバルとなります。",
            "これは正解です。Apexのトップレベルのクラスはデフォルトでprivateです。",
            "これは正解です。Apexでカスタム例外クラスを定義する場合、クラス名は”Exception”で終わらせる必要があります。"
        ]
    },
    {
        "number": "208",
        "question": "開発者は、あるクラスに対するテストを作成しており、機能を検証するためにレコードを挿入する必要があります。テストクラスのすべてのメソッドに対してレコードを作成するには、どのアノテーションを使うべきですか。",
        "choices": ["@StartTest", "@PreTest", "@TestSetup", "@isTest(SeeAllData=true)"],
        "correct": ["@TestSetup"],
        "explanations":["@StartTest", "@PreTest", "@TestSetup", "@isTest(SeeAllData=true)"],
        "descriptions":[
            "これは不正解です。Salesforceには@StartTestというアノテーションは存在しません。",
            "これは不正解です。Salesforceには@PreTestというアノテーションは存在しません。",
            "これは正解です。@TestSetupアノテーションは、テストクラス内のすべてのテストメソッドが実行される前に一度だけ実行されるメソッドを定義するために使用されます。このメソッド内でレコードを作成すると、それらのレコードはテストクラス内のすべてのテストメソッドで利用できます。",
            "これは不正解です。@isTest(SeeAllData=true)は、テストメソッドが本番環境のデータにアクセスできるようにするアノテーションです。しかし、テストのために新たにレコードを作成する目的には適していません。通常、テストの分離と独立性を保つために、実稼働環境のデータへのアクセスは避けるべきです。"
        ]
    },
    {
        "number": "209",
        "question": "開発者チームは、さまざまな組織構成で独立して作業できるソース主導型のプロジェクトに取り組んでいます。開発チームは、どのタイプのSalesforce組織を使用して開発を行うべきでしょうか。",
        "choices": ["スクラッチ組織", "Developer Sandbox", "Full Sandbox", "開発者組織"],
        "correct": ["スクラッチ組織"],
        "explanations":["スクラッチ組織", "Developer Sandbox", "Full Sandbox", "開発者組織"],
        "descriptions":[
            "これは正解です。スクラッチ組織は、Salesforce DXの一部で、ソース主導型開発に最適です。これらは一時的で軽量な組織であり、開発者が特定のプロジェクトや機能に取り組むために必要な構成を備えています。スクラッチ組織は、さまざまな組織構成で独立して作業するのに適しており、チームが個々の機能やモジュールに集中できる環境を提供します。",
            "これは不正解です。Developer Sandboxは限られたデータと機能を持つ小規模なテスト環境です。複数の独立した開発チームが同時に作業するには、スケールや分離の面で制限があります。スクラッチ組織のように迅速なセットアップやカスタマイズが難しいため、このシナリオには最適ではありません。",
            "これは不正解です。Full Sandboxは本番環境の完全なコピーであり、主に大規模なテストやトレーニングに使用されます。しかし、これらのサンドボックスは通常、作成数が限られ(1組織につき1環境のみ)、独立して作業する複数のチームによる同時使用には適していません。また、セットアップとリフレッシュに時間がかかるため、短期間の開発サイクルには不向きです。",
            "これは不正解です。開発者組織は個人開発者や非常に小規模なプロジェクト向けです。複数のチームや独立した作業をサポートするためのスケーリングや柔軟性が不足しています。また、スクラッチ組織のように迅速にセットアップして廃棄することも難しく、ソース主導型のプロジェクトには適していません。"
        ]
    },
    {
        "number": "210",
        "question": "Universal Containers社は、商談がClosed Wonのフェーズに達したときに、商談を編集できないようにロックしたいと考えています。これを達成するために開発者が使用すべき戦略はどれですか。2つ選びなさい。",
        "choices": ["フロービルダーを使用する。", "入力規則を使用する。", "プロセスの自動化設定を使用する。", "トリガーを使用する。"],
        "correct": ["入力規則を使用する。", "トリガーを使用する。"],
        "explanations":["フロービルダーを使用する。", "入力規則を使用する。", "プロセスの自動化設定を使用する。", "トリガーを使用する。"],
        "descriptions":[
            "これは不正解です。フロービルダーは、特定のビジネスプロセスを自動化するために使用されますが、レコードの編集を直接ロックする機能は提供していません。フローを使って商談のステータスがClosed Wonに変更されたときに特定のアクションをトリガーすることはできますが、これだけでは編集を防ぐことはできません。",
            "これは正解です。入力規則を使用すると、商談のステータスがClosed Wonになったときに特定の条件を満たさない限り、レコードの編集を防ぐことができます。たとえば、「ステータスがClosed Wonである場合、他の項目を編集できない」という入力規則を設定することで、レコードがロックされる効果が得られます。",
            "これは不正解です。プロセスの自動化(プロセスビルダーなど)は、特定の条件に基づいて自動的にタスクを実行するために使用されますが、これ自体ではレコードの編集を直接制限することはできません。商談のステータスが特定の値になったときにアクションをトリガーすることはできますが、編集をロックする機能は提供していません。",
            "これは正解です。Apexトリガーは、特定のデータベース操作(例えばレコードの更新)が発生したときにカスタムコードを実行するために使用されます。商談のステータスがClosed Wonになった場合に編集をロックするには、Apexトリガーを使用して、そのステータスの商談に対する更新操作を拒否するロジックを実装できます。例えば、商談がClosed Wonのステータスになると、トリガーが発火し、それ以降の編集を阻止することができます。これはサーバー側で実行されるため、セキュリティが強く、例外的な状況に対しても効果的に機能します。"
        ]
    },
    {
        "number": "211",
        "question": "",
        "choices": ["", "", "", ""],
        "correct": [""],
        "explanations":["", "", "", ""],
        "descriptions":[
            "",
            "",
            "",
            ""
        ]
    },
    {
        "number": "212",
        "question": "データクリーンアップ戦略の一環として、AW Computing社は、関連するアカウントが削除されたときに、関連する商談レコードを自動的に削除したいと考えています。このビジネス要件を満たすには、どの自動化ツールを使用する必要がありますか。",
        "choices": ["プロセスビルダー", "レコードトリガーフロー", "ワークフロールール", "スケジュールされたジョブ"],
        "correct": ["レコードトリガーフロー"],
        "explanations":["プロセスビルダー", "レコードトリガーフロー", "ワークフロールール", "スケジュールされたジョブ"],
        "descriptions":[
            "これは不正解です。プロセスビルダーは、特定のレコードの変更に基づいてアクションを実行するのに使用されますが、レコードの削除をトリガーとするアクションを実行する機能はありません。プロセスビルダーは、項目の更新、メールの送信、タスクの作成などのアクションに適していますが、他のレコードの削除を直接トリガーすることはできません。また、Salesforceはワークフローおよびプロセスビルダーからより強力なフローへの移行を進めており、将来的にはこれらの機能は廃止されます。",
            "これは正解です。レコードトリガーフローは、レコードの作成、更新、削除などのイベントに基づいて自動化されたプロセスを実行するために使用されます。関連するアカウントが削除されたときに商談レコードを削除するには、レコードトリガーフローを使用して、アカウントの削除イベントに応じて関連する商談レコードを削除するロジックを実装できます。",
            "これは不正解です。ワークフロールールは、特定の条件に基づいて項目の更新、メールアラートの送信、タスクの作成などのアクションを実行しますが、レコードの削除をトリガーとして他のレコードを削除する機能は提供していません。また、Salesforceではワークフロールールやプロセスビルダーの使用を段階的に廃止し、より高機能な「フロー」への移行を進めています。",
            "これは不正解です。スケジュールされたジョブは、特定の時間に定期的に実行されるタスクやプロセスを設定するために使用されます。これは一般的にバッチ処理や定期的なデータのメンテナンスに適していますが、特定のレコードの削除イベントに基づいて即時にアクションを実行するのには適していません。"
        ]
    },
    {
        "number": "213",
        "question": "会社名「Universal Containers」を持つすべてのリード、取引先、および取引先責任者のIDおよび名前を取得するには、開発者は何を使用すればよいですか。",
        "choices": ["FIND Universal Containers社’ IN CompanyName Fietds RETURNING lead{ld. name), accounted, name), contacted, name)", "FIND ‘Universal Containers社’ IN Name Fields RETURNING lead(id, name), accounted, name), contacted, name)", "SELECT lead(id, name). accountId, name), contacted, name) FROM Lead, Account, Contact WHERE Name = “Universal Containers社’", "SELECT Lead.id. Lead.Name, Account.Id, AccountName, Contacted, Contact.Name FROM Lead, Account, Contact WHERE CompanvName * Universal Containers社’"],
        "correct": ["FIND ‘Universal Containers社’ IN Name Fields RETURNING lead(id, name), accounted, name), contacted, name)"],
        "explanations":[" FIND Universal Containers社’ IN CompanyName Fietds RETURNING lead{ld. name), accounted, name), contacted, name)", "FIND ‘Universal Containers社’ IN Name Fields RETURNING lead(id, name), accounted, name), contacted, name)", " SELECT lead(id, name). accountId, name), contacted, name) FROM Lead, Account, Contact WHERE Name = “Universal Containers社’", "SELECT Lead.id. Lead.Name, Account.Id, AccountName, Contacted, Contact.Name FROM Lead, Account, Contact WHERE CompanvName * Universal Containers社’"],
        "descriptions":[
            "これは不正解です。この文はSOSL(Salesforce Object Search Language)の構文ですが、いくつかの問題があります。まず、クエリ内の検索文字列「Universal Containers社」は引用符で囲む必要があります。また、「CompanyName Fields」は存在しないため、適切なフィールドグループ(例えば「NAME FIELDS」)を指定する必要があります。さらに、リード、取引先、および取引先責任者のオブジェクトには「CompanyName」という名前の標準フィールドは存在しません。代わりに「Name」フィールドを使用する必要があるでしょう。",
            "これは正解です。この文は正しいSOSLクエリで、リード、取引先、および取引先責任者の「Name」フィールドで「Universal Containers社」というテキストを検索し、それぞれのIDと名前を返します。",
            "これは不正解です。この文はSOQLの構文に似ていますが、正しくない構文です。SOQLでは複数のオブジェクトを同時にクエリすることはできません。",
            "これは不正解です。この文はSOQLの構文に似ていますが、正しくない構文です。SOQLでは複数のオブジェクトを同時にクエリすることはできず、また「CompanyName」はリード、取引先、取引先責任者のすべてのオブジェクトに存在する項目ではありません。"
        ]
    },
    {
        "number": "214",
        "question": "Universal Containers社には、カスタムオブジェクトであるEngineering_Support__cを使用して、ユーザーがエンジニアリングチームにサポートを要求できるサポートプロセスがあります。ユーザーは、複数のEngineering_Support__cレコードを1つの商談レコードに関連付けることができる必要があります。さらに、Engineering_Support__c レコードに関する集計情報を商談レコードに表示する必要があります。これらの要件をサポートするために、開発者は何を実装する必要がありますか。",
        "choices": ["商談からEngineering_Support__cへの主従関係", "Engineering_Support__cから商談への主従関係", "商談からEngineering_Support__cへの参照関係", "Engineering_support__cから商談への参照関係"],
        "correct": ["Engineering_Support__cから商談への主従関係"],
        "explanations":["□ 商談からEngineering_Support__cへの主従関係", "□ Engineering_Support__cから商談への主従関係", "□ 商談からEngineering_Support__cへの参照関係", "□ Engineering_support__cから商談への参照関係"],
        "descriptions":[
            "これは不正解です。商談からEngineering_Support__cへの主従関係を設定すると、各商談レコードはEngineering_Support__cの複数の子レコードを持つことができます。しかし、この問題の要件には、商談レコードにEngineering_Support__cレコードの集計情報を表示する必要があり、この目的には主従関係は適していません。主従関係は、子レコード(Engineering_Support__c)の集計情報を親レコード(商談)に表示するために使用されます。",
            "これは正解です。Engineering_Support__cから商談への主従関係を設定すると、Engineering_Support__cレコードが商談レコードに関連付けられます。これにより、商談レコードにEngineering_Support__cレコードの集計情報を表示することが可能になり、問題文で求められている要件を満たすことができます。",
            "これは不正解です。参照関係では、Engineering_Support__cレコードに関する集計情報を商談レコードに表示することはできません。参照関係は、レコード間のリンクを作成するために使用されるもので、親レコード上で子レコードの集計情報を表示する機能は提供しません。",
            "これは不正解です。Engineering_support__cから商談への参照関係では、Engineering_Support__cレコードを商談レコードに関連付けることはできますが、問題文の要件にあるように商談レコードにEngineering_Support__cレコードの集計情報を表示する機能は提供しません。この関係では、Engineering_Support__cレコードは商談レコードと独立して存在し、親レコードでの集計表示には利用できません。"
        ]
    },
    {
        "number": "215",
        "question": "",
        "choices": ["", "", "", ""],
        "correct": [""],
        "explanations":["", "", "", ""],
        "descriptions":[
            "",
            "",
            "",
            ""
        ]
    }
]
